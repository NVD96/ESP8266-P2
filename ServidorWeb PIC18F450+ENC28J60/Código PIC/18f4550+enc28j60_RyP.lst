CCS PCH C Compiler, Version 4.104, 5967               05-jul.-15 21:17

               Filename: E:\DISEÑO PIC\PROYECTOS\PROYECTOS EN CURSO PROPIOS\PIC + Ethernet\Webserver v4.104\Webserver PIC18F4550+ENC28J60 html - SPI (completo)\Código PIC\PIC WebServer.lst

               ROM used: 30472 bytes (93%)
                         Largest free fragment is 2294
               RAM used: 751 (37%) at main() level
                         944 (46%) worst case
               Stack:    15 worst case (14 in main + 1 for interrupts)

*
0000:  GOTO   71B4
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  FF2.5
004A:  GOTO   0054
004E:  BTFSC  FF2.2
0050:  GOTO   00B4
0054:  MOVFF  0E,00
0058:  MOVFF  0F,01
005C:  MOVFF  10,02
0060:  MOVFF  11,03
0064:  MOVFF  0C,FE9
0068:  MOVFF  07,FEA
006C:  BSF    07.7
006E:  MOVFF  08,FE1
0072:  MOVFF  09,FE2
0076:  MOVFF  0A,FD9
007A:  MOVFF  0B,FDA
007E:  MOVFF  12,FF3
0082:  MOVFF  13,FF4
0086:  MOVFF  14,FFA
008A:  MOVF   04,W
008C:  MOVFF  06,FE0
0090:  MOVFF  05,FD8
0094:  RETFIE 0
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //                                                                            // 
.................... //                SERVIDOR WEB CON PIC 18F4550 Y ENC28J60                     // 
.................... //                                                                            // 
.................... //                      ccs PIC C compiler v4.104                             // 
.................... //                                                                            // 
.................... //                         (c) RobotyPic 2015                                 // 
.................... //                                                                            // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // Conmuta encendido-apagado de 3 leds controlados desde la aplicación web    // 
.................... // Muestra variables leídas por el PIC: Canal analógico An0 y estado bit RE0  // 
.................... // Representa en lcd el texto introducido desde la aplicación web             // 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #device ADC=8 
.................... #use delay(clock=20000000) 
*
05DC:  MOVLW  03
05DE:  MOVWF  FEA
05E0:  MOVLW  22
05E2:  MOVWF  FE9
05E4:  MOVF   FEF,W
05E6:  BZ    0602
05E8:  MOVLW  06
05EA:  MOVWF  01
05EC:  CLRF   00
05EE:  DECFSZ 00,F
05F0:  BRA    05EE
05F2:  DECFSZ 01,F
05F4:  BRA    05EC
05F6:  MOVLW  7B
05F8:  MOVWF  00
05FA:  DECFSZ 00,F
05FC:  BRA    05FA
05FE:  DECFSZ FEF,F
0600:  BRA    05E8
0602:  RETLW  00
.................... #fuses HS,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,VREGEN,NOPBADEN,WRTB 
....................  
.................... #byte porte = 0xF84 
....................  
.................... /** Configuración para el uso del stack tcip **/ 
.................... #define STACK_USE_ICMP        1  //Módulo de respuesta ICMP (ping) 
.................... #define STACK_USE_ARP         1  //Para solucionar direccionamiento MAC de las IP 
.................... #define STACK_USE_TCP         1  //Para enviar paquetes TCP  
.................... #define STACK_USE_HTTP        1  //Uso de las funciones http del stack. 
.................... #define STACK_USE_CCS_PICENS  1  //CCS PICENS (Embedded Ethernet) 18F4620 + ENC28J60 
.................... #define STACK_USE_MCPENC      1  //Uso del enc28j60 por el stack (stacktsk.c) 
.................... #define STACK_USE_MAC         1  //Uso de la tarjeta de red 
....................  
.................... #define HTTP_SOCKET 80         //Nº de puerto asociado al socket. 
....................  
.................... /********** Definición del patillaje de conexión al enc28j60 ******************/ 
.................... /* Existen varias posibilidades: 
....................  
.................... Opción 1. No definir nada, en cuyo caso se implementará una comunicación SPI por  
.................... software y se tomarán la definición de patillas establecida en enc28j60.c 
....................  
.................... SO  PIN_D7 ---- ENC >>>> PIC 
.................... SI  PIN_D6 ---- PIC >>>> ENC 
.................... CLK PIN_D5 
.................... CS  PIN_D4 
.................... RST PIN_D3 
.................... INT PIN_D2 
.................... WOL PIN_D1 
....................  
.................... Opción 2. Definir todas las patillas de la comunicación SPI, en cuyo caso se  
.................... implementará una comunicación SPI por software con la definición de patillas  
.................... elegida. Por ejemplo... 
....................  
.................... #define PIN_ENC_MAC_SO  PIN_C4   //Entrada serie de datos 
.................... #define PIN_ENC_MAC_SI  PIN_C5   //Salida serie de datos 
.................... #define PIN_ENC_MAC_CLK PIN_B4   //Señal de reloj 
.................... #define PIN_ENC_MAC_CS  PIN_B5   //Chip select 
.................... #define PIN_ENC_MAC_RST PIN_B6   //Reset 
.................... #define PIN_ENC_MAC_INT PIN_B7   //Interrupción 
....................  
.................... Opción 3. El que aquí se ha utilizado, que consiste en habilitar el uso de SPI  
.................... por hardware del PIC y definir las patillas ajenas al hardware del módulo SPI  
.................... (CS, INT y RST). En este caso es imprescindible definir también la patilla SO  
.................... para que el stack (dentro de enc28j60.c) no habilite SPI por software. Da igual  
.................... que patilla SO se defina, la que se deberá cablear será la SO real del PIC    */ 
....................  
.................... #define ENC_MAC_USE_SPI 1           //Uso del SPI por hardware 
....................  
.................... #define PIN_ENC_MAC_SO  PIN_B0      //Entrada serie de datos 
.................... //#define PIN_ENC_MAC_SI  PIN_C7    //Salida serie de datos (no necesario definir) 
.................... //#define PIN_ENC_MAC_CLK PIN_B1    //Señal de reloj  (no necesario definir) 
.................... #define PIN_ENC_MAC_CS  PIN_B2      //Chip select 
.................... #define PIN_ENC_MAC_RST PIN_B3      //Reset 
.................... #define PIN_ENC_MAC_INT PIN_B4      //Interrupción 
....................  
.................... /******************************************************************************/ 
....................  
.................... #define use_portd_lcd TRUE       //Uso del puerto d para control del lcd 
.................... #include <LCD420PIC18F_RyP.c>    //Carga librería del lcd de 4x20 para familia 18F 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //                                                                            // 
.................... //           LIBRERIA PARA CONTROL DE LCD 4X20 con PIC 18F4550                // 
.................... //                                                                            // 
.................... //                                                                            // 
.................... //      Se debe llamar a este archivo mediante #include <LCD420PIC18_RyP.c>   // 
.................... //                                                                            // 
.................... //      Es necesariodefinir el puerto a utilizar para el teclado mediante:    // 
.................... //      #define use_portb_lcd TRUE   //para el puerto B                       // 
.................... //      #define use_portd_lcd TRUE   //para el puerto D                       // 
.................... //                                                                            // 
.................... //      FUNCIONES:                                                            // 
.................... //      void lcd_init(void);         //Inicializa el lcd.                     // 
.................... //                                                                            // 
.................... //                                                                            // 
.................... //                            RobotyPic 2013                                  // 
.................... //                    http://robotypic.blogspot.com/                          // 
.................... //                                                                            // 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //Elección del puerto y pines 
....................  
.................... #ifdef use_portd_lcd 
....................  
.................... #define LCD_DB4  PIN_D4 
.................... #define LCD_DB5  PIN_D5 
.................... #define LCD_DB6  PIN_D6 
.................... #define LCD_DB7  PIN_D7 
.................... #define LCD_E    PIN_D0 
.................... #define LCD_RS   PIN_D1 
.................... #define LCD_RW   PIN_D2 
....................  
.................... #else 
....................  
.................... #define LCD_DB4  PIN_B4 
.................... #define LCD_DB5  PIN_B5 
.................... #define LCD_DB6  PIN_B6 
.................... #define LCD_DB7  PIN_B7 
.................... #define LCD_E    PIN_B0 
.................... #define LCD_RS   PIN_B1 
.................... #define LCD_RW   PIN_B2 
....................  
.................... #endif 
....................  
.................... // If you only want a 6-pin interface to your LCD, then 
.................... // connect the R/W pin on the LCD to ground, and comment 
.................... // out the following line. 
....................  
.................... #define USE_LCD_RW  1     
....................  
....................  
.................... #define lcd_type 2 
.................... #define lcd_line_two 0x40 
....................  
.................... BYTE lcdline; 
....................  
.................... int8 const LCD_INIT_STRING[4] = 
.................... { 
....................  0x20 | (lcd_type << 2), // Func set: 4-bit, 2 lines, 5x8 dots 
....................  0xc,                    // Display on 
....................  1,                      // Clear display 
....................  6                      // Increment cursor 
....................  }; 
....................  
....................  
.................... //------------------------------------- 
.................... void lcd_send_nibble(int8 nibble) 
.................... { 
....................  output_bit(LCD_DB4, !!(nibble & 1)); 
0604:  MOVLB  3
0606:  BTFSC  x28.0
0608:  BRA    060E
060A:  BCF    F8C.4
060C:  BRA    0610
060E:  BSF    F8C.4
0610:  BCF    F95.4
....................  output_bit(LCD_DB5, !!(nibble & 2));  
0612:  BTFSC  x28.1
0614:  BRA    061A
0616:  BCF    F8C.5
0618:  BRA    061C
061A:  BSF    F8C.5
061C:  BCF    F95.5
....................  output_bit(LCD_DB6, !!(nibble & 4));   
061E:  BTFSC  x28.2
0620:  BRA    0626
0622:  BCF    F8C.6
0624:  BRA    0628
0626:  BSF    F8C.6
0628:  BCF    F95.6
....................  output_bit(LCD_DB7, !!(nibble & 8));   
062A:  BTFSC  x28.3
062C:  BRA    0632
062E:  BCF    F8C.7
0630:  BRA    0634
0632:  BSF    F8C.7
0634:  BCF    F95.7
....................  
....................  delay_cycles(1); 
0636:  NOP   
....................  output_high(LCD_E); 
0638:  BCF    F95.0
063A:  BSF    F8C.0
....................  delay_us(2); 
063C:  MOVLW  03
063E:  MOVWF  00
0640:  DECFSZ 00,F
0642:  BRA    0640
....................  output_low(LCD_E); 
0644:  BCF    F95.0
0646:  BCF    F8C.0
.................... } 
0648:  MOVLB  0
064A:  RETLW  00
....................  
.................... #ifdef USE_LCD_RW 
.................... int8 lcd_read_nibble(void) 
.................... { 
.................... int8 retval; 
.................... #bit retval_0 = retval.0 
.................... #bit retval_1 = retval.1 
.................... #bit retval_2 = retval.2 
.................... #bit retval_3 = retval.3 
....................  
.................... retval = 0; 
064C:  MOVLB  3
064E:  CLRF   x29
....................    
.................... output_high(LCD_E); 
0650:  BCF    F95.0
0652:  BSF    F8C.0
.................... delay_cycles(1); 
0654:  NOP   
....................  
.................... retval_0 = input(LCD_DB4); 
0656:  BSF    F95.4
0658:  BCF    x29.0
065A:  BTFSC  F83.4
065C:  BSF    x29.0
.................... retval_1 = input(LCD_DB5); 
065E:  BSF    F95.5
0660:  BCF    x29.1
0662:  BTFSC  F83.5
0664:  BSF    x29.1
.................... retval_2 = input(LCD_DB6); 
0666:  BSF    F95.6
0668:  BCF    x29.2
066A:  BTFSC  F83.6
066C:  BSF    x29.2
.................... retval_3 = input(LCD_DB7); 
066E:  BSF    F95.7
0670:  BCF    x29.3
0672:  BTFSC  F83.7
0674:  BSF    x29.3
....................   
.................... output_low(LCD_E); 
0676:  BCF    F95.0
0678:  BCF    F8C.0
....................    
.................... return(retval);   
067A:  MOVFF  329,01
.................... }   
067E:  MOVLB  0
0680:  RETLW  00
.................... #endif 
....................  
.................... #ifdef USE_LCD_RW 
.................... int8 lcd_read_byte(void) 
.................... { 
.................... int8 low; 
.................... int8 high; 
....................  
.................... output_high(LCD_RW); 
0682:  BCF    F95.2
0684:  BSF    F8C.2
.................... delay_cycles(1); 
0686:  NOP   
....................  
.................... high = lcd_read_nibble(); 
0688:  RCALL  064C
068A:  MOVFF  01,328
....................  
.................... low = lcd_read_nibble(); 
068E:  RCALL  064C
0690:  MOVFF  01,327
....................  
.................... return( (high<<4) | low); 
0694:  MOVLB  3
0696:  SWAPF  x28,W
0698:  MOVWF  00
069A:  MOVLW  F0
069C:  ANDWF  00,F
069E:  MOVF   00,W
06A0:  IORWF  x27,W
06A2:  MOVWF  01
.................... } 
06A4:  MOVLB  0
06A6:  GOTO   06B0 (RETURN)
.................... #endif 
....................  
.................... void lcd_send_byte(int8 address, int8 n) 
.................... { 
.................... output_low(LCD_RS); 
06AA:  BCF    F95.1
06AC:  BCF    F8C.1
....................  
.................... #ifdef USE_LCD_RW 
.................... while(bit_test(lcd_read_byte(),7)) ; 
06AE:  BRA    0682
06B0:  MOVFF  01,327
06B4:  MOVLB  3
06B6:  BTFSS  01.7
06B8:  BRA    06BE
06BA:  MOVLB  0
06BC:  BRA    06AE
.................... #else 
.................... delay_us(60);  
.................... #endif 
....................  
.................... if(address) 
06BE:  MOVF   x25,F
06C0:  BZ    06C8
....................   output_high(LCD_RS); 
06C2:  BCF    F95.1
06C4:  BSF    F8C.1
.................... else 
06C6:  BRA    06CC
....................   output_low(LCD_RS); 
06C8:  BCF    F95.1
06CA:  BCF    F8C.1
....................      
....................  delay_cycles(1); 
06CC:  NOP   
....................  
.................... #ifdef USE_LCD_RW 
.................... output_low(LCD_RW); 
06CE:  BCF    F95.2
06D0:  BCF    F8C.2
.................... delay_cycles(1); 
06D2:  NOP   
.................... #endif 
....................  
.................... output_low(LCD_E); 
06D4:  BCF    F95.0
06D6:  BCF    F8C.0
....................  
.................... lcd_send_nibble(n >> 4); 
06D8:  SWAPF  x26,W
06DA:  MOVWF  x27
06DC:  MOVLW  0F
06DE:  ANDWF  x27,F
06E0:  MOVFF  327,328
06E4:  MOVLB  0
06E6:  RCALL  0604
.................... lcd_send_nibble(n & 0xf); 
06E8:  MOVLB  3
06EA:  MOVF   x26,W
06EC:  ANDLW  0F
06EE:  MOVWF  x27
06F0:  MOVWF  x28
06F2:  MOVLB  0
06F4:  RCALL  0604
.................... } 
06F6:  RETLW  00
....................  
.................... void lcd_init(void) 
.................... { 
.................... int8 i; 
....................  
.................... output_low(LCD_RS); 
06F8:  BCF    F95.1
06FA:  BCF    F8C.1
....................  
.................... #ifdef USE_LCD_RW 
.................... output_low(LCD_RW); 
06FC:  BCF    F95.2
06FE:  BCF    F8C.2
.................... #endif 
....................  
.................... output_low(LCD_E); 
0700:  BCF    F95.0
0702:  BCF    F8C.0
....................  
.................... delay_ms(15); 
0704:  MOVLW  0F
0706:  MOVLB  3
0708:  MOVWF  x22
070A:  MOVLB  0
070C:  RCALL  05DC
....................  
.................... for(i=0 ;i < 3; i++) 
070E:  MOVLB  2
0710:  CLRF   xEE
0712:  MOVF   xEE,W
0714:  SUBLW  02
0716:  BNC   0732
....................   { 
....................     lcd_send_nibble(0x03); 
0718:  MOVLW  03
071A:  MOVLB  3
071C:  MOVWF  x28
071E:  MOVLB  0
0720:  RCALL  0604
....................     delay_ms(5); 
0722:  MOVLW  05
0724:  MOVLB  3
0726:  MOVWF  x22
0728:  MOVLB  0
072A:  RCALL  05DC
....................   } 
072C:  MOVLB  2
072E:  INCF   xEE,F
0730:  BRA    0712
....................  
.................... lcd_send_nibble(0x02); 
0732:  MOVLW  02
0734:  MOVLB  3
0736:  MOVWF  x28
0738:  MOVLB  0
073A:  RCALL  0604
....................  
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++) 
073C:  MOVLB  2
073E:  CLRF   xEE
0740:  MOVF   xEE,W
0742:  SUBLW  03
0744:  BNC   076C
....................   { 
....................     lcd_send_byte(0, LCD_INIT_STRING[i]); 
0746:  CLRF   03
0748:  MOVF   xEE,W
074A:  MOVFF  FF2,2EF
074E:  BCF    FF2.7
0750:  MOVLB  0
0752:  RCALL  0096
0754:  MOVLB  2
0756:  BTFSC  xEF.7
0758:  BSF    FF2.7
075A:  MOVWF  xEF
075C:  MOVLB  3
075E:  CLRF   x25
0760:  MOVWF  x26
0762:  MOVLB  0
0764:  RCALL  06AA
....................    
....................     #ifndef USE_LCD_RW 
....................     delay_ms(5); 
....................     #endif 
....................   } 
0766:  MOVLB  2
0768:  INCF   xEE,F
076A:  BRA    0740
....................  
.................... } 
076C:  MOVLB  0
076E:  GOTO   762A (RETURN)
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) 
.................... { 
....................   BYTE address; 
....................   
....................  
....................   switch(y) 
....................   { 
0772:  MOVLW  01
0774:  MOVLB  3
0776:  SUBWF  x23,W
0778:  ADDLW  FC
077A:  BC    07B6
077C:  ADDLW  04
077E:  MOVLB  0
0780:  GOTO   07C8
....................     case 1 : address=0x80; 
0784:  MOVLW  80
0786:  MOVLB  3
0788:  MOVWF  x24
....................     lcdline=1; 
078A:  MOVLW  01
078C:  MOVWF  16
....................     break; 
078E:  BRA    07B6
....................     case 2 : address=0xc0; 
0790:  MOVLW  C0
0792:  MOVLB  3
0794:  MOVWF  x24
....................     lcdline=2; 
0796:  MOVLW  02
0798:  MOVWF  16
....................     break; 
079A:  BRA    07B6
....................     case 3 : address=0x94; 
079C:  MOVLW  94
079E:  MOVLB  3
07A0:  MOVWF  x24
....................     lcdline=3; 
07A2:  MOVLW  03
07A4:  MOVWF  16
....................     break; 
07A6:  BRA    07B6
....................     case 4 : address=0xd4; 
07A8:  MOVLW  D4
07AA:  MOVLB  3
07AC:  MOVWF  x24
....................     lcdline=4; 
07AE:  MOVLW  04
07B0:  MOVWF  16
....................     break; 
07B2:  BRA    07B6
07B4:  MOVLB  3
....................   } 
....................  
....................   address+=x-1; 
07B6:  MOVLW  01
07B8:  SUBWF  x22,W
07BA:  ADDWF  x24,F
....................   lcd_send_byte(0,address); 
07BC:  CLRF   x25
07BE:  MOVFF  324,326
07C2:  MOVLB  0
07C4:  RCALL  06AA
.................... } 
07C6:  RETLW  00
....................  
....................  
.................... void lcd_putc(char c) 
.................... { 
....................  switch(c) 
....................   { 
*
07F4:  MOVLB  3
07F6:  MOVF   x21,W
07F8:  XORLW  0C
07FA:  MOVLB  0
07FC:  BZ    0808
07FE:  XORLW  06
0800:  BZ    0824
0802:  XORLW  02
0804:  BZ    0848
0806:  BRA    0856
....................     case '\f': 
....................       lcd_send_byte(0,1); 
0808:  MOVLB  3
080A:  CLRF   x25
080C:  MOVLW  01
080E:  MOVWF  x26
0810:  MOVLB  0
0812:  RCALL  06AA
....................       lcdline=1; 
0814:  MOVLW  01
0816:  MOVWF  16
....................       delay_ms(2); 
0818:  MOVLW  02
081A:  MOVLB  3
081C:  MOVWF  x22
081E:  MOVLB  0
0820:  RCALL  05DC
....................       break; 
0822:  BRA    0866
....................    
....................     case '\n': 
....................       lcd_gotoxy(1,++lcdline); 
0824:  INCF   16,F
0826:  MOVLW  01
0828:  MOVLB  3
082A:  MOVWF  x22
082C:  MOVFF  16,323
0830:  MOVLB  0
0832:  RCALL  0772
....................       if (lcdline>4) lcd_gotoxy(1,1); 
0834:  MOVF   16,W
0836:  SUBLW  04
0838:  BC    0846
083A:  MOVLW  01
083C:  MOVLB  3
083E:  MOVWF  x22
0840:  MOVWF  x23
0842:  MOVLB  0
0844:  RCALL  0772
....................       break; 
0846:  BRA    0866
....................    
....................     case '\b': 
....................       lcd_send_byte(0,0x10); 
0848:  MOVLB  3
084A:  CLRF   x25
084C:  MOVLW  10
084E:  MOVWF  x26
0850:  MOVLB  0
0852:  RCALL  06AA
....................       break; 
0854:  BRA    0866
....................    
....................     default: 
....................       lcd_send_byte(1,c); 
0856:  MOVLW  01
0858:  MOVLB  3
085A:  MOVWF  x25
085C:  MOVFF  321,326
0860:  MOVLB  0
0862:  RCALL  06AA
....................       break; 
0864:  BRA    0866
....................   } 
.................... } 
0866:  RETLW  00
....................  
.................... #ifdef USE_LCD_RW 
.................... char lcd_getc(int8 x, int8 y) 
.................... { 
.................... char value; 
....................  
.................... lcd_gotoxy(x,y); 
....................  
.................... // Wait until busy flag is low. 
.................... while(bit_test(lcd_read_byte(),7));  
....................  
.................... output_high(LCD_RS); 
.................... value = lcd_read_byte(); 
.................... output_low(lcd_RS); 
....................  
.................... return(value); 
.................... } 
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.c"      //Carga el stack TCP/IP de Microchip  
.................... /********************************************************************* 
....................  * 
....................  *               Microchip TCP/IP Stack FSM Implementation on PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.c 
....................  * Dependencies:    StackTsk.H 
....................  *                  ARPTsk.h 
....................  *                  MAC.h 
....................  *                  IP.h 
....................  *                  ICMP.h 
....................  *                  Tcp.h 
....................  *                  http.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/14/01  Original (Rev. 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Nilesh Rajbharti     12/5/02     Modified UDPProcess() and TCPProcess() 
....................  *                                  to include localIP as third param. 
....................  *                                  This was done to allow these functions 
....................  *                                  to calculate checksum correctly. 
....................  * Nilesh Rajbharti     7/26/04     Added code in StackTask() to not 
....................  *                                  clear statically IP address if link is 
....................  *                                  removed and DHCP module is disabled 
....................  *                                  at runtime. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A break; added to StackTask() after handling an ARP, else it would goto IP handler. 
....................  * Darren Rook (CCS)    06/28/04 Added 2.20 improvement that resets DHCP after unlink of ethernet 
....................  * Darren Rook (CCS)    06/29/04 A fix for 2.20 improvement (see above) if DHCP was dynamically disabled 
....................  * Darren Rook (CCS)    06/29/04 smStack no longer static 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    04/08/05 Task() and Init() execute any needed HTTP code 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #case 
....................  
.................... #define STACK_INCLUDE 
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC18 SFR Definitions 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        pic18.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or later 
....................  * 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     11/14/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  ********************************************************************/ 
.................... #ifndef COMPILER_H 
.................... #define COMPILER_H 
....................  
.................... #if !defined(__PCH__) 
.................... #error "This version only works with CCS PCH or PCWH" 
.................... #endif 
....................  
.................... // ** I/O PORT REGISTERS 
....................  
.................... #byte PORTA    =  0xF80 
.................... #byte PORTB    =  0xF81 
.................... #byte PORTC    =  0xF82 
.................... #byte PORTD    =  0xF83 
.................... #byte PORTE    =  0xF84 
.................... #byte PORTF    =  0xF85 
....................  
.................... #bit PORTA_RA5 =  0xF80.5 
.................... #bit PORTA_RA4 =  0xF80.4 
.................... #bit PORTA_RA3 =  0xF80.3 
.................... #bit PORTA_RA2 =  0xF80.2 
.................... #bit PORTA_RA1 =  0xF80.1 
.................... #bit PORTA_RA0 =  0xF80.0 
....................  
.................... #bit PORTB_RB7 =  0xF81.7 
.................... #bit PORTB_RB6 =  0xF81.6 
.................... #bit PORTB_RB5 =  0xF81.5 
.................... #bit PORTB_RB4 =  0xF81.4 
.................... #bit PORTB_RB3 =  0xF81.3 
.................... #bit PORTB_RB2 =  0xF81.2 
.................... #bit PORTB_RB1 =  0xF81.1 
.................... #bit PORTB_RB0 =  0xF81.0 
....................  
.................... #bit PORTC_RC7 =  0xF82.7 
.................... #bit PORTC_RC6 =  0xF82.6 
.................... #bit PORTC_RC5 =  0xF82.5 
.................... #bit PORTC_RC4 =  0xF82.4 
.................... #bit PORTC_RC3 =  0xF82.3 
.................... #bit PORTC_RC2 =  0xF82.2 
.................... #bit PORTC_RC1 =  0xF82.1 
.................... #bit PORTC_RC0 =  0xF82.0 
....................  
.................... #bit PORTD_RD7 =  0xF83.7 
.................... #bit PORTD_RD6 =  0xF83.6 
.................... #bit PORTD_RD5 =  0xF83.5 
.................... #bit PORTD_RD4 =  0xF83.4 
.................... #bit PORTD_RD3 =  0xF83.3 
.................... #bit PORTD_RD2 =  0xF83.2 
.................... #bit PORTD_RD1 =  0xF83.1 
.................... #bit PORTD_RD0 =  0xF83.0 
....................  
.................... #bit PORTE_RE7 =  0xF84.7 
.................... #bit PORTE_RE6 =  0xF84.6 
.................... #bit PORTE_RE5 =  0xF84.5 
.................... #bit PORTE_RE4 =  0xF84.4 
.................... #bit PORTE_RE3 =  0xF84.3 
.................... #bit PORTE_RE2 =  0xF84.2 
.................... #bit PORTE_RE1 =  0xF84.1 
.................... #bit PORTE_RE0 =  0xF84.0 
....................  
.................... #bit PORTF_RF7 =  0xF85.7 
.................... #bit PORTF_RF6 =  0xF85.6 
.................... #bit PORTF_RF5 =  0xF85.5 
.................... #bit PORTF_RF4 =  0xF85.4 
.................... #bit PORTF_RF3 =  0xF85.3 
.................... #bit PORTF_RF2 =  0xF85.2 
.................... #bit PORTF_RF1 =  0xF85.1 
.................... #bit PORTF_RF0 =  0xF85.0 
....................  
....................  
.................... // *** TRIS REGISTERS 
....................  
.................... #byte TRISA    =  0xF92 
.................... #byte TRISB    =  0xF93 
.................... #byte TRISC    =  0xF94 
.................... #byte TRISD    =  0xF95 
.................... #byte TRISE    =  0xF96 
.................... #byte TRISF    =  0xF97 
....................  
.................... #bit TRISA_RA7 =  0xF92.7 
.................... #bit TRISA_RA6 =  0xF92.6 
.................... #bit TRISA_RA5 =  0xF92.5 
.................... #bit TRISA_RA4 =  0xF92.4 
.................... #bit TRISA_RA3 =  0xF92.3 
.................... #bit TRISA_RA2 =  0xF92.2 
.................... #bit TRISA_RA1 =  0xF92.1 
.................... #bit TRISA_RA0 =  0xF92.0 
....................  
.................... #bit TRISB_RB7 =  0xF93.7 
.................... #bit TRISB_RB6 =  0xF93.6 
.................... #bit TRISB_RB5 =  0xF93.5 
.................... #bit TRISB_RB4 =  0xF93.4 
.................... #bit TRISB_RB3 =  0xF93.3 
.................... #bit TRISB_RB2 =  0xF93.2 
.................... #bit TRISB_RB1 =  0xF93.1 
.................... #bit TRISB_RB0 =  0xF93.0 
....................  
.................... #bit TRISC_RC7 =  0xF94.7 
.................... #bit TRISC_RC6 =  0xF94.6 
.................... #bit TRISC_RC5 =  0xF94.5 
.................... #bit TRISC_RC4 =  0xF94.4 
.................... #bit TRISC_RC3 =  0xF94.3 
.................... #bit TRISC_RC2 =  0xF94.2 
.................... #bit TRISC_RC1 =  0xF94.1 
.................... #bit TRISC_RC0 =  0xF94.0 
....................  
.................... #bit TRISD_RD7 =  0xF95.7 
.................... #bit TRISD_RD6 =  0xF95.6 
.................... #bit TRISD_RD5 =  0xF95.5 
.................... #bit TRISD_RD4 =  0xF95.4 
.................... #bit TRISD_RD3 =  0xF95.3 
.................... #bit TRISD_RD2 =  0xF95.2 
.................... #bit TRISD_RD1 =  0xF95.1 
.................... #bit TRISD_RD0 =  0xF95.0 
....................  
.................... #bit TRISE_RE7 =  0xF96.7 
.................... #bit TRISE_RE6 =  0xF96.6 
.................... #bit TRISE_RE5 =  0xF96.5 
.................... #bit TRISE_RE4 =  0xF96.4 
.................... #bit TRISE_RE3 =  0xF96.3 
.................... #bit TRISE_RE2 =  0xF96.2 
.................... #bit TRISE_RE1 =  0xF96.1 
.................... #bit TRISE_RE0 =  0xF96.0 
....................  
.................... #bit TRISF_RF7 =  0xF97.7 
.................... #bit TRISF_RF6 =  0xF97.6 
.................... #bit TRISF_RF5 =  0xF97.5 
.................... #bit TRISF_RF4 =  0xF97.4 
.................... #bit TRISF_RF3 =  0xF97.3 
.................... #bit TRISF_RF2 =  0xF97.2 
.................... #bit TRISF_RF1 =  0xF97.1 
.................... #bit TRISF_RF0 =  0xF97.0 
....................  
....................  
.................... // *** LAT REGISTERS 
.................... #byte LATA    =  0xF89 
.................... #byte LATB    =  0xF8A 
.................... #byte LATC    =  0xF8B 
.................... #byte LATD    =  0xF8C 
.................... #byte LATE    =  0xF8D 
.................... #byte LATF    =  0xF8E 
....................  
.................... #bit LATA_RA7 =  0xF89.7 
.................... #bit LATA_RA6 =  0xF89.6 
.................... #bit LATA_RA5 =  0xF89.5 
.................... #bit LATA_RA4 =  0xF89.4 
.................... #bit LATA_RA3 =  0xF89.3 
.................... #bit LATA_RA2 =  0xF89.2 
.................... #bit LATA_RA1 =  0xF89.1 
.................... #bit LATA_RA0 =  0xF89.0 
....................  
.................... #bit LATB_RB7 =  0xF8A.7 
.................... #bit LATB_RB6 =  0xF8A.6 
.................... #bit LATB_RB5 =  0xF8A.5 
.................... #bit LATB_RB4 =  0xF8A.4 
.................... #bit LATB_RB3 =  0xF8A.3 
.................... #bit LATB_RB2 =  0xF8A.2 
.................... #bit LATB_RB1 =  0xF8A.1 
.................... #bit LATB_RB0 =  0xF8A.0 
....................  
.................... #bit LATC_RC7 =  0xF8B.7 
.................... #bit LATC_RC6 =  0xF8B.6 
.................... #bit LATC_RC5 =  0xF8B.5 
.................... #bit LATC_RC4 =  0xF8B.4 
.................... #bit LATC_RC3 =  0xF8B.3 
.................... #bit LATC_RC2 =  0xF8B.2 
.................... #bit LATC_RC1 =  0xF8B.1 
.................... #bit LATC_RC0 =  0xF8B.0 
....................  
.................... #bit LATD_RD7 =  0xF8C.7 
.................... #bit LATD_RD6 =  0xF8C.6 
.................... #bit LATD_RD5 =  0xF8C.5 
.................... #bit LATD_RD4 =  0xF8C.4 
.................... #bit LATD_RD3 =  0xF8C.3 
.................... #bit LATD_RD2 =  0xF8C.2 
.................... #bit LATD_RD1 =  0xF8C.1 
.................... #bit LATD_RD0 =  0xF8C.0 
....................  
.................... #bit LATE_RE7 =  0xF8D.7 
.................... #bit LATE_RE6 =  0xF8D.6 
.................... #bit LATE_RE5 =  0xF8D.5 
.................... #bit LATE_RE4 =  0xF8D.4 
.................... #bit LATE_RE3 =  0xF8D.3 
.................... #bit LATE_RE2 =  0xF8D.2 
.................... #bit LATE_RE1 =  0xF8D.1 
.................... #bit LATE_RE0 =  0xF8D.0 
....................  
.................... #bit LATF_RF7 =  0xF8E.7 
.................... #bit LATF_RF6 =  0xF8E.6 
.................... #bit LATF_RF5 =  0xF8E.5 
.................... #bit LATF_RF4 =  0xF8E.4 
.................... #bit LATF_RF3 =  0xF8E.3 
.................... #bit LATF_RF2 =  0xF8E.2 
.................... #bit LATF_RF1 =  0xF8E.1 
.................... #bit LATF_RF0 =  0xF8E.0 
....................  
....................  
.................... // ** OTHER SPECIAL FILE REGISTERS USED BY SLIP 
....................  
.................... #bit  PIE1_TXIE       =  0xF9D.4 
.................... #bit  PIE1_RCIE       =  0xF9D.5 
.................... #bit  PIR1_TXIF       =  0xF9E.4 
.................... #bit  PIR1_RCIF       =  0xF9E.5 
.................... #byte TXSTA           =  0xFAC 
.................... #byte RCSTA           =  0xFAB 
.................... #bit  RCSTA_CREN      =  0xFAB.4 
.................... #byte RCREG           =  0xFAE 
.................... #byte SPBRG           =  0xFAF 
.................... #byte TXREG           =  0xFAD 
....................  
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                         HARDWARE.H                                //// 
.................... ////                                                                   //// 
.................... //// Hardware I/O definitions and TCP/IP stack configuration settings. //// 
.................... ////                                                                   //// 
.................... //// These values will probably change with each application.          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// RELEASE HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... ////    Jan 15, 2004: MODEM_RESPONSE_TIMEOUT and MODEM_CONNECT_TIMEOUT //// 
.................... ////                  moved to here.                                   //// 
.................... ////                                                                   //// 
.................... ////    Jan 09, 2004: Initial Public Release                           //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF ___TCPIP_STACK_CONFIGURATION 
.................... #define ___TCPIP_STACK_CONFIGURATION 
....................  
....................  
.................... #ifndef STACK_USE_CCS_PICNET 
.................... #define STACK_USE_CCS_PICNET  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_CCS_PICENS 
.................... #define STACK_USE_CCS_PICENS  FALSE 
.................... #endif 
....................  
....................  
.................... //// SET TCP_NO_WAIT_FOR_ACK TO FALSE IF TCP STACK SHOULD WAIT FOR ACK FROM 
.................... //// REMOTE HOST BEFORE TRANSMITTING ANOTHER PACKET.  THIS MAY REDUCE THROUGHPUT. 
.................... //// DEFAULT VALUE (TRUE) GETS LOADED IN TCP.H IF THIS LINE IS REMOVED. 
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE 
....................  
....................  
.................... ///DEFAULT HARDCODED IP ADDRESSES. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THESE TO AN EEPROM. 
.................... ///  OR USE AUTO IP ASSIGNMENT (DHCP). 
.................... ///  NO TWO DEVICES ON A NETwORK CAN HAVE THE SAME IP ADDRESS 
....................    #define MY_DEFAULT_IP_ADDR_BYTE1        192   //IP ADDRESS 
....................    #define MY_DEFAULT_IP_ADDR_BYTE2        168   // This unit's IP address. 
....................    #define MY_DEFAULT_IP_ADDR_BYTE3        1 
....................    #define MY_DEFAULT_IP_ADDR_BYTE4        10 
....................  
....................    #define MY_DEFAULT_MASK_BYTE1           0xff //NETMASK 
....................    #define MY_DEFAULT_MASK_BYTE2           0xff // Netmask tells the IP / ARP stack which 
....................    #define MY_DEFAULT_MASK_BYTE3           0xff // IP's are on your local network. 
....................    #define MY_DEFAULT_MASK_BYTE4           0x00 
....................  
....................    #define MY_DEFAULT_GATE_BYTE1           192  //GATEWAY IP ADDRESS 
....................    #define MY_DEFAULT_GATE_BYTE2           168  // Gateway acts as a conduit between two networks. 
....................    #define MY_DEFAULT_GATE_BYTE3           1 
....................    #define MY_DEFAULT_GATE_BYTE4           1 
....................  
.................... ///DEFAULT HARDCODED MAC ADDRESS. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THIS TO AN EEPROM, OR GENERATE 
.................... ///  A DYNAMIC ONE BASED UPON UNIT'S SERIAL NUMBER. 
.................... ///  NO TWO DEVICES ON THE SAME ETHERNET NETWORK CAN HAVE THE SAME MAC ADDRESS. 
.................... #define MY_DEFAULT_MAC_BYTE1            0x00 
.................... #define MY_DEFAULT_MAC_BYTE2            0x02 
.................... #define MY_DEFAULT_MAC_BYTE3            0xa3 
.................... #define MY_DEFAULT_MAC_BYTE4            0x04 
.................... #define MY_DEFAULT_MAC_BYTE5            0x05 
.................... #define MY_DEFAULT_MAC_BYTE6            0x06 
....................  
.................... ///Maximum sockets to be defined. 
.................... /// Note that each socket consumes 36 bytes of RAM. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
....................    #ifndef MAX_SOCKETS 
....................    #define MAX_SOCKETS                     5 
....................    #endif 
....................  
.................... ///Avaialble UDP Socket 
.................... /// DCHP takes 1 socket. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
....................    #ifndef MAX_UDP_SOCKETS 
....................    #define MAX_UDP_SOCKETS                 2 
....................    #endif 
....................  
.................... ///BUFFER SIZE DEFINITIONS 
.................... /// 
.................... /// For SLIP, there can only be one transmit and one receive buffer. 
.................... /// Both buffer must fit in one bank.  If bigger buffer is required, 
.................... /// you must manually locate tx and rx buffer in different bank 
.................... /// or modify your linker script file to support arrays bigger than 
.................... /// 256 bytes. 
.................... /// I think Microchip needs MAC_RX_BUFFER_SIZE to equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For PPP, there can only be one transmit and one receive buffer. 
.................... /// You can receive messages larger than the receive buffer if your 
.................... /// routines are fast enough.  You cannot transmit messages larger 
.................... /// than the TX buffer.  The larger the buffer you can make, the better. 
.................... /// BUG: MAC_RX_BUFFER_SIZE must equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For Ethernet, the Ethernet controler has many buffers that are 
.................... /// 1k in size.   Only one buffer is used for TX, rest are for RX. 
.................... /// Unlike SLIP and PPP, no RAM is used for these buffers. 
....................    #if STACK_USE_MAC 
....................        #define MAC_TX_BUFFER_SIZE          1024 //do not modify this line 
....................        #define MAC_TX_BUFFER_COUNT         1    //do not modify this line 
....................    #elif STACK_USE_PPP 
....................        #define MAC_TX_BUFFER_SIZE          1024 
....................        #define MAC_TX_BUFFER_COUNT         1 
....................    #elif STACK_USE_SLIP 
....................        #define MAC_TX_BUFFER_SIZE          250 
....................        #define MAC_TX_BUFFER_COUNT         1 
....................    #endif 
....................  
....................    #define MAC_RX_BUFFER_SIZE              MAC_TX_BUFFER_SIZE  //do not modify this line unless you are certain you know what you're doing 
....................  
.................... #endif 
....................  
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
*
4878:  MOVFF  31A,31F
487C:  MOVFF  319,31E
....................    sc2=s2; 
4880:  MOVFF  31C,321
4884:  MOVFF  31B,320
....................    if(sc2<sc1 && sc1 <sc2 +n) 
4888:  MOVLB  3
488A:  MOVF   x21,W
488C:  SUBWF  x1F,W
488E:  BNC   48F6
4890:  BNZ   4898
4892:  MOVF   x1E,W
4894:  SUBWF  x20,W
4896:  BC    48F6
4898:  MOVF   x1D,W
489A:  ADDWF  x20,W
489C:  MOVWF  01
489E:  MOVLW  00
48A0:  ADDWFC x21,W
48A2:  MOVWF  03
48A4:  MOVF   x1F,W
48A6:  SUBWF  03,W
48A8:  BNC   48F6
48AA:  BNZ   48B2
48AC:  MOVF   01,W
48AE:  SUBWF  x1E,W
48B0:  BC    48F6
....................       for(sc1+=n,sc2+=n;0<n;--n) 
48B2:  MOVF   x1D,W
48B4:  ADDWF  x1E,F
48B6:  MOVLW  00
48B8:  ADDWFC x1F,F
48BA:  MOVF   x1D,W
48BC:  ADDWF  x20,F
48BE:  MOVLW  00
48C0:  ADDWFC x21,F
48C2:  MOVF   x1D,W
48C4:  SUBLW  00
48C6:  BC    48F4
....................          *--sc1=*--sc2; 
48C8:  MOVF   x1E,W
48CA:  BTFSC  FD8.2
48CC:  DECF   x1F,F
48CE:  DECF   x1E,F
48D0:  MOVF   x20,W
48D2:  BTFSC  FD8.2
48D4:  DECF   x21,F
48D6:  DECF   x20,F
48D8:  MOVFF  320,FE9
48DC:  MOVFF  321,FEA
48E0:  MOVFF  FEF,324
48E4:  MOVFF  31F,FEA
48E8:  MOVFF  31E,FE9
48EC:  MOVFF  324,FEF
48F0:  DECF   x1D,F
48F2:  BRA    48C2
....................    else 
48F4:  BRA    4934
....................       for(;0<n;--n) 
48F6:  MOVF   x1D,W
48F8:  SUBLW  00
48FA:  BC    4934
....................          *sc1++=*sc2++; 
48FC:  MOVFF  31F,03
4900:  MOVF   x1E,W
4902:  INCF   x1E,F
4904:  BTFSC  FD8.2
4906:  INCF   x1F,F
4908:  MOVWF  x22
490A:  MOVFF  03,323
490E:  MOVFF  321,03
4912:  MOVF   x20,W
4914:  INCF   x20,F
4916:  BTFSC  FD8.2
4918:  INCF   x21,F
491A:  MOVWF  FE9
491C:  MOVFF  03,FEA
4920:  MOVFF  FEF,324
4924:  MOVFF  323,FEA
4928:  MOVFF  322,FE9
492C:  MOVFF  324,FEF
4930:  DECF   x1D,F
4932:  BRA    48F6
....................   return s1; 
4934:  MOVFF  319,01
4938:  MOVFF  31A,02
....................   } 
493C:  MOVLB  0
493E:  GOTO   4A14 (RETURN)
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
*
5D7E:  MOVFF  32C,331
5D82:  MOVFF  32B,330
5D86:  MOVLB  3
5D88:  MOVF   x2F,F
5D8A:  BZ    5DD4
5D8C:  MOVFF  32E,03
5D90:  MOVFF  32D,FE9
5D94:  MOVFF  32E,FEA
5D98:  MOVF   FEF,F
5D9A:  BZ    5DD4
....................      *s++ = *s2++; 
5D9C:  MOVFF  331,03
5DA0:  MOVF   x30,W
5DA2:  INCF   x30,F
5DA4:  BTFSC  FD8.2
5DA6:  INCF   x31,F
5DA8:  MOVWF  x32
5DAA:  MOVFF  03,333
5DAE:  MOVFF  32E,03
5DB2:  MOVF   x2D,W
5DB4:  INCF   x2D,F
5DB6:  BTFSC  FD8.2
5DB8:  INCF   x2E,F
5DBA:  MOVWF  FE9
5DBC:  MOVFF  03,FEA
5DC0:  MOVFF  FEF,334
5DC4:  MOVFF  333,FEA
5DC8:  MOVFF  332,FE9
5DCC:  MOVFF  334,FEF
5DD0:  DECF   x2F,F
5DD2:  BRA    5D88
....................   for (; n > 0; n--) 
5DD4:  MOVF   x2F,F
5DD6:  BZ    5DF0
....................      *s++ = '\0'; 
5DD8:  MOVFF  331,03
5DDC:  MOVF   x30,W
5DDE:  INCF   x30,F
5DE0:  BTFSC  FD8.2
5DE2:  INCF   x31,F
5DE4:  MOVWF  FE9
5DE6:  MOVFF  03,FEA
5DEA:  CLRF   FEF
5DEC:  DECF   x2F,F
5DEE:  BRA    5DD4
....................  
....................   return(s1); 
5DF0:  MOVFF  32B,01
5DF4:  MOVFF  32C,02
.................... } 
5DF8:  MOVLB  0
5DFA:  GOTO   5EE6 (RETURN)
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
43B8:  MOVLB  2
43BA:  MOVFF  2FC,FE9
43BE:  MOVFF  2FD,FEA
43C2:  MOVFF  FEF,300
43C6:  MOVFF  2FF,03
43CA:  MOVFF  2FE,FE9
43CE:  MOVFF  2FF,FEA
43D2:  MOVF   FEF,W
43D4:  MOVLB  3
43D6:  SUBWF  x00,W
43D8:  BNZ   4406
....................       if (*s1 == '\0') 
43DA:  MOVFF  2FD,03
43DE:  MOVLB  2
43E0:  MOVFF  2FC,FE9
43E4:  MOVFF  03,FEA
43E8:  MOVF   FEF,F
43EA:  BNZ   43F2
....................          return(0); 
43EC:  MOVLW  00
43EE:  MOVWF  01
43F0:  BRA    4436
43F2:  MOVFF  2FD,03
43F6:  MOVF   xFC,W
43F8:  INCF   xFC,F
43FA:  BTFSC  FD8.2
43FC:  INCF   xFD,F
43FE:  INCF   xFE,F
4400:  BTFSC  FD8.2
4402:  INCF   xFF,F
4404:  BRA    43BA
....................    return((*s1 < *s2) ? -1: 1); 
4406:  MOVFF  2FD,03
440A:  MOVLB  2
440C:  MOVFF  2FC,FE9
4410:  MOVFF  2FD,FEA
4414:  MOVFF  FEF,300
4418:  MOVFF  2FF,03
441C:  MOVFF  2FE,FE9
4420:  MOVFF  2FF,FEA
4424:  MOVF   FEF,W
4426:  MOVLB  3
4428:  SUBWF  x00,W
442A:  BC    4430
442C:  MOVLW  FF
442E:  BRA    4432
4430:  MOVLW  01
4432:  MOVWF  01
4434:  MOVLB  2
.................... } 
4436:  MOVLB  0
4438:  RETLW  00
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
443A:  MOVFF  34B,34D
....................    for(su=s;0<n;++su,--n) 
443E:  MOVFF  34A,34F
4442:  MOVFF  349,34E
4446:  MOVLB  3
4448:  MOVF   x4C,W
444A:  SUBLW  00
444C:  BC    4474
....................       if(*su==uc) 
444E:  MOVFF  34F,03
4452:  MOVFF  34E,FE9
4456:  MOVFF  34F,FEA
445A:  MOVF   x4D,W
445C:  SUBWF  FEF,W
445E:  BNZ   446A
....................       return su; 
4460:  MOVFF  34E,01
4464:  MOVFF  34F,02
4468:  BRA    447A
446A:  INCF   x4E,F
446C:  BTFSC  FD8.2
446E:  INCF   x4F,F
4470:  DECF   x4C,F
4472:  BRA    4448
....................    return NULL; 
4474:  MOVLW  00
4476:  MOVWF  01
4478:  MOVWF  02
.................... } 
447A:  MOVLB  0
447C:  RETLW  00
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
428C:  MOVFF  307,30B
4290:  MOVFF  306,30A
4294:  MOVFF  30B,03
4298:  MOVLB  3
429A:  MOVFF  30A,FE9
429E:  MOVFF  30B,FEA
42A2:  MOVF   FEF,F
42A4:  BZ    42FA
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
42A6:  MOVFF  309,30D
42AA:  MOVFF  308,30C
42AE:  MOVFF  30D,03
42B2:  MOVFF  30C,FE9
42B6:  MOVFF  30D,FEA
42BA:  MOVF   FEF,F
42BC:  BZ    42EE
....................          if (*sc1 == *sc2) 
42BE:  MOVFF  30A,FE9
42C2:  MOVFF  30B,FEA
42C6:  MOVFF  FEF,30E
42CA:  MOVFF  30D,03
42CE:  MOVFF  30C,FE9
42D2:  MOVFF  30D,FEA
42D6:  MOVF   FEF,W
42D8:  SUBWF  x0E,W
42DA:  BNZ   42E6
....................             return(sc1); 
42DC:  MOVFF  30A,01
42E0:  MOVFF  30B,02
42E4:  BRA    4300
42E6:  INCF   x0C,F
42E8:  BTFSC  FD8.2
42EA:  INCF   x0D,F
42EC:  BRA    42AE
42EE:  INCF   x0A,F
42F0:  BTFSC  FD8.2
42F2:  INCF   x0B,F
42F4:  MOVLB  0
42F6:  BRA    4294
42F8:  MOVLB  3
....................    return(0); 
42FA:  MOVLW  00
42FC:  MOVWF  01
42FE:  MOVWF  02
.................... } 
4300:  MOVLB  0
4302:  GOTO   437A (RETURN)
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
41FC:  MOVFF  307,30B
4200:  MOVFF  306,30A
4204:  MOVFF  30B,03
4208:  MOVLB  3
420A:  MOVFF  30A,FE9
420E:  MOVFF  30B,FEA
4212:  MOVF   FEF,F
4214:  BZ    4276
....................       for (sc2 = s2; ; sc2++) 
4216:  MOVFF  309,30D
421A:  MOVFF  308,30C
....................     if (*sc2 == '\0') 
421E:  MOVFF  30D,03
4222:  MOVFF  30C,FE9
4226:  MOVFF  30D,FEA
422A:  MOVF   FEF,F
422C:  BNZ   4242
....................        return(sc1 - s1); 
422E:  MOVF   x06,W
4230:  SUBWF  x0A,W
4232:  MOVWF  00
4234:  MOVF   x07,W
4236:  SUBWFB x0B,W
4238:  MOVWF  03
423A:  MOVFF  00,01
423E:  BRA    4286
....................          else if (*sc1 == *sc2) 
4240:  BRA    4262
4242:  MOVFF  30A,FE9
4246:  MOVFF  30B,FEA
424A:  MOVFF  FEF,30E
424E:  MOVFF  30D,03
4252:  MOVFF  30C,FE9
4256:  MOVFF  30D,FEA
425A:  MOVF   FEF,W
425C:  SUBWF  x0E,W
425E:  BNZ   4262
....................             break; 
4260:  BRA    426A
4262:  INCF   x0C,F
4264:  BTFSC  FD8.2
4266:  INCF   x0D,F
4268:  BRA    421E
426A:  INCF   x0A,F
426C:  BTFSC  FD8.2
426E:  INCF   x0B,F
4270:  MOVLB  0
4272:  BRA    4204
4274:  MOVLB  3
....................    return(sc1 - s1); 
4276:  MOVF   x06,W
4278:  SUBWF  x0A,W
427A:  MOVWF  00
427C:  MOVF   x07,W
427E:  SUBWFB x0B,W
4280:  MOVWF  03
4282:  MOVFF  00,01
.................... } 
4286:  MOVLB  0
4288:  GOTO   4338 (RETURN)
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
*
4306:  MOVLB  2
4308:  MOVF   xFE,W
430A:  IORWF  xFF,W
430C:  BZ    4316
430E:  MOVFF  2FF,03
4312:  MOVF   xFE,W
4314:  BRA    431C
4316:  MOVFF  49,03
431A:  MOVF   48,W
431C:  MOVLB  3
431E:  MOVWF  x02
4320:  MOVFF  03,303
....................    beg += strspn(beg, s2); 
4324:  MOVFF  303,307
4328:  MOVFF  302,306
432C:  MOVFF  301,309
4330:  MOVFF  300,308
4334:  MOVLB  0
4336:  BRA    41FC
4338:  MOVF   01,W
433A:  MOVLB  3
433C:  ADDWF  x02,F
433E:  MOVLW  00
4340:  ADDWFC x03,F
....................    if (*beg == '\0') 
4342:  MOVFF  303,03
4346:  MOVFF  302,FE9
434A:  MOVFF  303,FEA
434E:  MOVF   FEF,F
4350:  BNZ   4366
....................    { 
....................       *save = ' '; 
4352:  MOVFF  48,FE9
4356:  MOVFF  49,FEA
435A:  MOVLW  20
435C:  MOVWF  FEF
....................       return(0); 
435E:  MOVLW  00
4360:  MOVWF  01
4362:  MOVWF  02
4364:  BRA    43B4
....................    } 
....................    end = strpbrk(beg, s2); 
4366:  MOVFF  303,307
436A:  MOVFF  302,306
436E:  MOVFF  301,309
4372:  MOVFF  300,308
4376:  MOVLB  0
4378:  BRA    428C
437A:  MOVFF  02,305
437E:  MOVFF  01,304
....................    if (*end != '\0') 
4382:  MOVFF  305,03
4386:  MOVLB  3
4388:  MOVFF  304,FE9
438C:  MOVFF  305,FEA
4390:  MOVF   FEF,F
4392:  BZ    43A4
....................    { 
....................       *end = '\0'; 
4394:  MOVFF  304,FE9
4398:  MOVFF  305,FEA
439C:  CLRF   FEF
....................       end++; 
439E:  INCF   x04,F
43A0:  BTFSC  FD8.2
43A2:  INCF   x05,F
....................    } 
....................    save = end; 
43A4:  MOVFF  305,49
43A8:  MOVFF  304,48
....................    return(beg); 
43AC:  MOVFF  302,01
43B0:  MOVFF  303,02
.................... } 
43B4:  MOVLB  0
43B6:  RETLW  00
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
483E:  MOVFF  32C,32E
4842:  MOVFF  32B,32D
4846:  MOVFF  32E,03
484A:  MOVLB  3
484C:  MOVFF  32D,FE9
4850:  MOVFF  32E,FEA
4854:  MOVF   FEF,F
4856:  BZ    4864
4858:  INCF   x2D,F
485A:  BTFSC  FD8.2
485C:  INCF   x2E,F
485E:  MOVLB  0
4860:  BRA    4846
4862:  MOVLB  3
....................    return(sc - s); 
4864:  MOVF   x2B,W
4866:  SUBWF  x2D,W
4868:  MOVWF  00
486A:  MOVF   x2C,W
486C:  SUBWFB x2E,W
486E:  MOVWF  03
4870:  MOVFF  00,01
.................... } 
4874:  MOVLB  0
4876:  RETLW  00
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
*
4A54:  MOVLB  3
4A56:  MOVFF  315,FE9
4A5A:  MOVFF  316,FEA
4A5E:  MOVFF  FEF,319
4A62:  MOVFF  318,03
4A66:  MOVFF  317,FE9
4A6A:  MOVFF  318,FEA
4A6E:  MOVF   FEF,W
4A70:  SUBWF  x19,W
4A72:  BZ    4B04
4A74:  MOVFF  316,03
4A78:  MOVFF  315,FE9
4A7C:  MOVFF  316,FEA
4A80:  MOVFF  FEF,319
4A84:  MOVF   x19,W
4A86:  SUBLW  40
4A88:  BC    4A90
4A8A:  MOVF   x19,W
4A8C:  SUBLW  5A
4A8E:  BC    4A9C
4A90:  MOVF   x19,W
4A92:  SUBLW  60
4A94:  BC    4B2E
4A96:  MOVF   x19,W
4A98:  SUBLW  7A
4A9A:  BNC   4B2E
4A9C:  MOVFF  318,03
4AA0:  MOVFF  317,FE9
4AA4:  MOVFF  318,FEA
4AA8:  MOVFF  FEF,319
4AAC:  MOVF   x19,W
4AAE:  SUBLW  40
4AB0:  BC    4AB8
4AB2:  MOVF   x19,W
4AB4:  SUBLW  5A
4AB6:  BC    4AC4
4AB8:  MOVF   x19,W
4ABA:  SUBLW  60
4ABC:  BC    4B2E
4ABE:  MOVF   x19,W
4AC0:  SUBLW  7A
4AC2:  BNC   4B2E
4AC4:  MOVFF  315,FE9
4AC8:  MOVFF  316,FEA
4ACC:  MOVFF  FEF,319
4AD0:  MOVFF  318,03
4AD4:  MOVFF  317,FE9
4AD8:  MOVFF  318,FEA
4ADC:  MOVLW  20
4ADE:  ADDWF  FEF,W
4AE0:  SUBWF  x19,W
4AE2:  BZ    4B04
4AE4:  MOVFF  317,FE9
4AE8:  MOVFF  318,FEA
4AEC:  MOVFF  FEF,319
4AF0:  MOVFF  316,03
4AF4:  MOVFF  315,FE9
4AF8:  MOVFF  316,FEA
4AFC:  MOVLW  20
4AFE:  ADDWF  FEF,W
4B00:  SUBWF  x19,W
4B02:  BNZ   4B2E
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
4B04:  MOVFF  316,03
4B08:  MOVFF  315,FE9
4B0C:  MOVFF  316,FEA
4B10:  MOVF   FEF,F
4B12:  BNZ   4B1A
....................        return(0); 
4B14:  MOVLW  00
4B16:  MOVWF  01
4B18:  BRA    4B58
4B1A:  MOVFF  316,03
4B1E:  MOVF   x15,W
4B20:  INCF   x15,F
4B22:  BTFSC  FD8.2
4B24:  INCF   x16,F
4B26:  INCF   x17,F
4B28:  BTFSC  FD8.2
4B2A:  INCF   x18,F
4B2C:  BRA    4A56
....................  return((*s1 < *s2) ? -1: 1); 
4B2E:  MOVFF  316,03
4B32:  MOVFF  315,FE9
4B36:  MOVFF  316,FEA
4B3A:  MOVFF  FEF,319
4B3E:  MOVFF  318,03
4B42:  MOVFF  317,FE9
4B46:  MOVFF  318,FEA
4B4A:  MOVF   FEF,W
4B4C:  SUBWF  x19,W
4B4E:  BC    4B54
4B50:  MOVLW  FF
4B52:  BRA    4B56
4B54:  MOVLW  01
4B56:  MOVWF  01
.................... } 
4B58:  MOVLB  0
4B5A:  RETLW  00
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
5056:  MOVLB  3
5058:  CLRF   x04
....................    sign = 0; 
505A:  CLRF   x02
....................    base = 10; 
505C:  MOVLW  0A
505E:  MOVWF  x03
....................    result = 0; 
5060:  CLRF   x01
5062:  CLRF   x00
....................  
....................    if (!s) 
5064:  MOVLB  2
5066:  MOVF   xFE,W
5068:  IORWF  xFF,W
506A:  BNZ   5074
....................       return 0; 
506C:  MOVLW  00
506E:  MOVWF  01
5070:  MOVWF  02
5072:  BRA    5270
....................    c = s[index++]; 
5074:  MOVLB  3
5076:  MOVF   x04,W
5078:  INCF   x04,F
507A:  CLRF   03
507C:  MOVLB  2
507E:  ADDWF  xFE,W
5080:  MOVWF  FE9
5082:  MOVF   xFF,W
5084:  ADDWFC 03,W
5086:  MOVWF  FEA
5088:  MOVFF  FEF,305
508C:  MOVLB  3
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
508E:  MOVF   x05,W
5090:  SUBLW  2D
5092:  BNZ   50B2
....................    { 
....................       sign = 1;         // Set the sign to negative 
5094:  MOVLW  01
5096:  MOVWF  x02
....................       c = s[index++]; 
5098:  MOVF   x04,W
509A:  INCF   x04,F
509C:  CLRF   03
509E:  MOVLB  2
50A0:  ADDWF  xFE,W
50A2:  MOVWF  FE9
50A4:  MOVF   xFF,W
50A6:  ADDWFC 03,W
50A8:  MOVWF  FEA
50AA:  MOVFF  FEF,305
50AE:  MOVLB  3
....................    } 
....................    else if (c == '+') 
50B0:  BRA    50D0
50B2:  MOVF   x05,W
50B4:  SUBLW  2B
50B6:  BNZ   50D0
....................    { 
....................       c = s[index++]; 
50B8:  MOVF   x04,W
50BA:  INCF   x04,F
50BC:  CLRF   03
50BE:  MOVLB  2
50C0:  ADDWF  xFE,W
50C2:  MOVWF  FE9
50C4:  MOVF   xFF,W
50C6:  ADDWFC 03,W
50C8:  MOVWF  FEA
50CA:  MOVFF  FEF,305
50CE:  MOVLB  3
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
50D0:  MOVF   x05,W
50D2:  SUBLW  2F
50D4:  BTFSC  FD8.0
50D6:  BRA    5252
50D8:  MOVF   x05,W
50DA:  SUBLW  39
50DC:  BTFSS  FD8.0
50DE:  BRA    5252
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
50E0:  MOVF   x05,W
50E2:  SUBLW  30
50E4:  BNZ   513A
50E6:  CLRF   03
50E8:  MOVF   x04,W
50EA:  MOVLB  2
50EC:  ADDWF  xFE,W
50EE:  MOVWF  FE9
50F0:  MOVF   xFF,W
50F2:  ADDWFC 03,W
50F4:  MOVWF  FEA
50F6:  MOVF   FEF,W
50F8:  SUBLW  78
50FA:  BZ    511A
50FC:  CLRF   03
50FE:  MOVLB  3
5100:  MOVF   x04,W
5102:  MOVLB  2
5104:  ADDWF  xFE,W
5106:  MOVWF  FE9
5108:  MOVF   xFF,W
510A:  ADDWFC 03,W
510C:  MOVWF  FEA
510E:  MOVF   FEF,W
5110:  SUBLW  58
5112:  BTFSC  FD8.2
5114:  BRA    511A
5116:  MOVLB  3
5118:  BRA    513A
....................       { 
....................          base = 16; 
511A:  MOVLW  10
511C:  MOVLB  3
511E:  MOVWF  x03
....................          index++; 
5120:  INCF   x04,F
....................          c = s[index++]; 
5122:  MOVF   x04,W
5124:  INCF   x04,F
5126:  CLRF   03
5128:  MOVLB  2
512A:  ADDWF  xFE,W
512C:  MOVWF  FE9
512E:  MOVF   xFF,W
5130:  ADDWFC 03,W
5132:  MOVWF  FEA
5134:  MOVFF  FEF,305
5138:  MOVLB  3
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
513A:  MOVF   x03,W
513C:  SUBLW  0A
513E:  BNZ   518C
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
5140:  MOVF   x05,W
5142:  SUBLW  2F
5144:  BC    518A
5146:  MOVF   x05,W
5148:  SUBLW  39
514A:  BNC   518A
....................             result = 10*result + (c - '0'); 
514C:  CLRF   x4B
514E:  MOVLW  0A
5150:  MOVWF  x4A
5152:  MOVFF  301,34D
5156:  MOVFF  300,34C
515A:  MOVLB  0
515C:  CALL   447E
5160:  MOVLW  30
5162:  MOVLB  3
5164:  SUBWF  x05,W
5166:  ADDWF  01,W
5168:  MOVWF  x00
516A:  MOVLW  00
516C:  ADDWFC 02,W
516E:  MOVWF  x01
....................             c = s[index++]; 
5170:  MOVF   x04,W
5172:  INCF   x04,F
5174:  CLRF   03
5176:  MOVLB  2
5178:  ADDWF  xFE,W
517A:  MOVWF  FE9
517C:  MOVF   xFF,W
517E:  ADDWFC 03,W
5180:  MOVWF  FEA
5182:  MOVFF  FEF,305
5186:  MOVLB  3
....................          } 
5188:  BRA    5140
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
518A:  BRA    5252
518C:  MOVF   x03,W
518E:  SUBLW  10
5190:  BNZ   5252
....................       { 
....................          c = toupper(c); 
5192:  MOVF   x05,W
5194:  SUBLW  60
5196:  BC    51A4
5198:  MOVF   x05,W
519A:  SUBLW  7A
519C:  BNC   51A4
519E:  MOVF   x05,W
51A0:  ANDLW  DF
51A2:  BRA    51A6
51A4:  MOVF   x05,W
51A6:  MOVWF  x05
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
51A8:  MOVF   x05,W
51AA:  SUBLW  2F
51AC:  BC    51B4
51AE:  MOVF   x05,W
51B0:  SUBLW  39
51B2:  BC    51C0
51B4:  MOVF   x05,W
51B6:  SUBLW  40
51B8:  BC    5252
51BA:  MOVF   x05,W
51BC:  SUBLW  46
51BE:  BNC   5252
....................             if (c >= '0' && c <= '9') 
51C0:  MOVF   x05,W
51C2:  SUBLW  2F
51C4:  BC    51F8
51C6:  MOVF   x05,W
51C8:  SUBLW  39
51CA:  BNC   51F8
....................                result = (result << 4) + (c - '0'); 
51CC:  RLCF   x00,W
51CE:  MOVWF  x06
51D0:  RLCF   x01,W
51D2:  MOVWF  x07
51D4:  RLCF   x06,F
51D6:  RLCF   x07,F
51D8:  RLCF   x06,F
51DA:  RLCF   x07,F
51DC:  RLCF   x06,F
51DE:  RLCF   x07,F
51E0:  MOVLW  F0
51E2:  ANDWF  x06,F
51E4:  MOVLW  30
51E6:  SUBWF  x05,W
51E8:  ADDWF  x06,W
51EA:  MOVWF  01
51EC:  MOVLW  00
51EE:  ADDWFC x07,W
51F0:  MOVFF  01,300
51F4:  MOVWF  x01
....................             else 
51F6:  BRA    5224
....................                result = (result << 4) + (c - 'A' + 10); 
51F8:  RLCF   x00,W
51FA:  MOVWF  x06
51FC:  RLCF   x01,W
51FE:  MOVWF  x07
5200:  RLCF   x06,F
5202:  RLCF   x07,F
5204:  RLCF   x06,F
5206:  RLCF   x07,F
5208:  RLCF   x06,F
520A:  RLCF   x07,F
520C:  MOVLW  F0
520E:  ANDWF  x06,F
5210:  MOVLW  41
5212:  SUBWF  x05,W
5214:  ADDLW  0A
5216:  ADDWF  x06,W
5218:  MOVWF  01
521A:  MOVLW  00
521C:  ADDWFC x07,W
521E:  MOVFF  01,300
5222:  MOVWF  x01
....................  
....................             c = s[index++];c = toupper(c); 
5224:  MOVF   x04,W
5226:  INCF   x04,F
5228:  CLRF   03
522A:  MOVLB  2
522C:  ADDWF  xFE,W
522E:  MOVWF  FE9
5230:  MOVF   xFF,W
5232:  ADDWFC 03,W
5234:  MOVWF  FEA
5236:  MOVF   FEF,W
5238:  MOVLB  3
523A:  MOVWF  x05
523C:  SUBLW  60
523E:  BC    524C
5240:  MOVF   x05,W
5242:  SUBLW  7A
5244:  BNC   524C
5246:  MOVF   x05,W
5248:  ANDLW  DF
524A:  BRA    524E
524C:  MOVF   x05,W
524E:  MOVWF  x05
....................          } 
5250:  BRA    51A8
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
5252:  MOVF   x03,W
5254:  SUBLW  0A
5256:  BNZ   5266
5258:  DECFSZ x02,W
525A:  BRA    5266
....................       result = -result; 
525C:  COMF   x00,F
525E:  COMF   x01,F
5260:  INCF   x00,F
5262:  BTFSC  FD8.2
5264:  INCF   x01,F
....................  
....................    return(result); 
5266:  MOVFF  300,01
526A:  MOVFF  301,02
526E:  MOVLB  2
.................... } 
5270:  MOVLB  0
5272:  GOTO   683C (RETURN)
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
*
44D2:  MOVLB  3
44D4:  CLRF   x22
44D6:  CLRF   x21
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
44D8:  MOVLW  30
44DA:  MOVWF  x24
44DC:  MOVLW  31
44DE:  MOVWF  x25
44E0:  MOVLW  32
44E2:  MOVWF  x26
44E4:  MOVLW  33
44E6:  MOVWF  x27
44E8:  MOVLW  34
44EA:  MOVWF  x28
44EC:  MOVLW  35
44EE:  MOVWF  x29
44F0:  MOVLW  36
44F2:  MOVWF  x2A
44F4:  MOVLW  37
44F6:  MOVWF  x2B
44F8:  MOVLW  38
44FA:  MOVWF  x2C
44FC:  MOVLW  39
44FE:  MOVWF  x2D
4500:  MOVLW  61
4502:  MOVWF  x2E
4504:  MOVLW  62
4506:  MOVWF  x2F
4508:  MOVLW  63
450A:  MOVWF  x30
450C:  MOVLW  64
450E:  MOVWF  x31
4510:  MOVLW  65
4512:  MOVWF  x32
4514:  MOVLW  66
4516:  MOVWF  x33
4518:  MOVLW  67
451A:  MOVWF  x34
451C:  MOVLW  68
451E:  MOVWF  x35
4520:  MOVLW  69
4522:  MOVWF  x36
4524:  MOVLW  6A
4526:  MOVWF  x37
4528:  MOVLW  6B
452A:  MOVWF  x38
452C:  MOVLW  6C
452E:  MOVWF  x39
4530:  MOVLW  6D
4532:  MOVWF  x3A
4534:  MOVLW  6E
4536:  MOVWF  x3B
4538:  MOVLW  6F
453A:  MOVWF  x3C
453C:  MOVLW  70
453E:  MOVWF  x3D
4540:  MOVLW  71
4542:  MOVWF  x3E
4544:  MOVLW  73
4546:  MOVWF  x3F
4548:  MOVLW  74
454A:  MOVWF  x40
454C:  MOVLW  75
454E:  MOVWF  x41
4550:  MOVLW  76
4552:  MOVWF  x42
4554:  MOVLW  77
4556:  MOVWF  x43
4558:  MOVLW  78
455A:  MOVWF  x44
455C:  MOVLW  79
455E:  MOVWF  x45
4560:  MOVLW  7A
4562:  MOVWF  x46
4564:  CLRF   x47
....................    for(sc=s;isspace(*sc);++sc); 
4566:  MOVFF  317,31C
456A:  MOVFF  316,31B
456E:  MOVFF  31C,03
4572:  MOVFF  31B,FE9
4576:  MOVFF  31C,FEA
457A:  MOVF   FEF,W
457C:  SUBLW  20
457E:  BNZ   4588
4580:  INCF   x1B,F
4582:  BTFSC  FD8.2
4584:  INCF   x1C,F
4586:  BRA    456E
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
4588:  MOVFF  31C,03
458C:  MOVFF  31B,FE9
4590:  MOVFF  31C,FEA
4594:  MOVF   FEF,W
4596:  SUBLW  2D
4598:  BZ    45AC
459A:  MOVFF  31C,03
459E:  MOVFF  31B,FE9
45A2:  MOVFF  31C,FEA
45A6:  MOVF   FEF,W
45A8:  SUBLW  2B
45AA:  BNZ   45C2
45AC:  MOVFF  31C,03
45B0:  MOVF   x1B,W
45B2:  INCF   x1B,F
45B4:  BTFSC  FD8.2
45B6:  INCF   x1C,F
45B8:  MOVWF  FE9
45BA:  MOVFF  03,FEA
45BE:  MOVF   FEF,W
45C0:  BRA    45C4
45C2:  MOVLW  2B
45C4:  MOVWF  x23
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
45C6:  MOVF   x23,W
45C8:  SUBLW  2D
45CA:  BZ    45E0
45CC:  BTFSC  x1A.7
45CE:  BRA    45E0
45D0:  DECFSZ x1A,W
45D2:  BRA    45D6
45D4:  BRA    45E0
45D6:  BTFSC  x1A.7
45D8:  BRA    45E4
45DA:  MOVF   x1A,W
45DC:  SUBLW  24
45DE:  BC    45E4
....................    goto StrtoulGO; 
45E0:  BRA    47F8
....................  
....................    else if (base) 
45E2:  BRA    46EC
45E4:  MOVF   x1A,F
45E6:  BZ    4680
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
45E8:  MOVF   x1A,W
45EA:  SUBLW  10
45EC:  BNZ   462C
45EE:  MOVFF  31C,03
45F2:  MOVFF  31B,FE9
45F6:  MOVFF  31C,FEA
45FA:  MOVF   FEF,W
45FC:  SUBLW  30
45FE:  BNZ   462C
4600:  MOVLW  01
4602:  ADDWF  x1B,W
4604:  MOVWF  FE9
4606:  MOVLW  00
4608:  ADDWFC x1C,W
460A:  MOVWF  FEA
460C:  MOVF   FEF,W
460E:  SUBLW  78
4610:  BZ    4624
4612:  MOVLW  01
4614:  ADDWF  x1B,W
4616:  MOVWF  FE9
4618:  MOVLW  00
461A:  ADDWFC x1C,W
461C:  MOVWF  FEA
461E:  MOVF   FEF,W
4620:  SUBLW  58
4622:  BNZ   462C
....................          sc+=2; 
4624:  MOVLW  02
4626:  ADDWF  x1B,F
4628:  MOVLW  00
462A:  ADDWFC x1C,F
....................       if(base==8 && *sc =='0') 
462C:  MOVF   x1A,W
462E:  SUBLW  08
4630:  BNZ   464C
4632:  MOVFF  31C,03
4636:  MOVFF  31B,FE9
463A:  MOVFF  31C,FEA
463E:  MOVF   FEF,W
4640:  SUBLW  30
4642:  BNZ   464C
....................          sc+=1; 
4644:  MOVLW  01
4646:  ADDWF  x1B,F
4648:  MOVLW  00
464A:  ADDWFC x1C,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
464C:  MOVF   x1A,W
464E:  SUBLW  02
4650:  BNZ   467E
4652:  MOVFF  31C,03
4656:  MOVFF  31B,FE9
465A:  MOVFF  31C,FEA
465E:  MOVF   FEF,W
4660:  SUBLW  30
4662:  BNZ   467E
4664:  MOVLW  01
4666:  ADDWF  x1B,W
4668:  MOVWF  FE9
466A:  MOVLW  00
466C:  ADDWFC x1C,W
466E:  MOVWF  FEA
4670:  MOVF   FEF,W
4672:  SUBLW  62
4674:  BNZ   467E
....................          sc+=2; 
4676:  MOVLW  02
4678:  ADDWF  x1B,F
467A:  MOVLW  00
467C:  ADDWFC x1C,F
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
467E:  BRA    46EC
4680:  MOVFF  31C,03
4684:  MOVFF  31B,FE9
4688:  MOVFF  31C,FEA
468C:  MOVF   FEF,W
468E:  SUBLW  30
4690:  BZ    4698
....................       base=10; 
4692:  MOVLW  0A
4694:  MOVWF  x1A
....................    else if (sc[1]=='x' || sc[1]=='X') 
4696:  BRA    46EC
4698:  MOVLW  01
469A:  ADDWF  x1B,W
469C:  MOVWF  FE9
469E:  MOVLW  00
46A0:  ADDWFC x1C,W
46A2:  MOVWF  FEA
46A4:  MOVF   FEF,W
46A6:  SUBLW  78
46A8:  BZ    46BC
46AA:  MOVLW  01
46AC:  ADDWF  x1B,W
46AE:  MOVWF  FE9
46B0:  MOVLW  00
46B2:  ADDWFC x1C,W
46B4:  MOVWF  FEA
46B6:  MOVF   FEF,W
46B8:  SUBLW  58
46BA:  BNZ   46CA
....................       base =16,sc+=2; 
46BC:  MOVLW  10
46BE:  MOVWF  x1A
46C0:  MOVLW  02
46C2:  ADDWF  x1B,F
46C4:  MOVLW  00
46C6:  ADDWFC x1C,F
....................    else if(sc[1]=='b') 
46C8:  BRA    46EC
46CA:  MOVLW  01
46CC:  ADDWF  x1B,W
46CE:  MOVWF  FE9
46D0:  MOVLW  00
46D2:  ADDWFC x1C,W
46D4:  MOVWF  FEA
46D6:  MOVF   FEF,W
46D8:  SUBLW  62
46DA:  BNZ   46E8
....................       base=2,sc+=2; 
46DC:  MOVLW  02
46DE:  MOVWF  x1A
46E0:  ADDWF  x1B,F
46E2:  MOVLW  00
46E4:  ADDWFC x1C,F
....................    else 
46E6:  BRA    46EC
....................       base=8; 
46E8:  MOVLW  08
46EA:  MOVWF  x1A
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
46EC:  MOVFF  31C,31E
46F0:  MOVFF  31B,31D
46F4:  MOVFF  31C,03
46F8:  MOVFF  31B,FE9
46FC:  MOVFF  31C,FEA
4700:  MOVF   FEF,W
4702:  SUBLW  30
4704:  BNZ   470E
4706:  INCF   x1B,F
4708:  BTFSC  FD8.2
470A:  INCF   x1C,F
470C:  BRA    46F4
....................    sd=memchr(digits,tolower(*sc),base); 
470E:  MOVFF  31C,03
4712:  MOVFF  31B,FE9
4716:  MOVFF  31C,FEA
471A:  MOVFF  FEF,348
471E:  MOVF   x48,W
4720:  SUBLW  40
4722:  BC    4730
4724:  MOVF   x48,W
4726:  SUBLW  5A
4728:  BNC   4730
472A:  MOVF   x48,W
472C:  IORLW  20
472E:  BRA    4732
4730:  MOVF   x48,W
4732:  MOVWF  x48
4734:  MOVLW  03
4736:  MOVWF  x4A
4738:  MOVLW  24
473A:  MOVWF  x49
473C:  MOVFF  348,34B
4740:  MOVFF  31A,34C
4744:  MOVLB  0
4746:  RCALL  443A
4748:  MOVFF  02,320
474C:  MOVFF  01,31F
....................    for(; sd!=0; ) 
4750:  MOVLB  3
4752:  MOVF   x1F,F
4754:  BNZ   475A
4756:  MOVF   x20,F
4758:  BZ    47EC
....................    { 
....................       x=x*base+(int16)(sd-digits); 
475A:  CLRF   03
475C:  MOVF   x1A,W
475E:  MOVWF  00
4760:  BTFSC  FE8.7
4762:  DECF   03,F
4764:  MOVWF  x48
4766:  MOVFF  03,349
476A:  MOVFF  322,34B
476E:  MOVFF  321,34A
4772:  MOVFF  03,34D
4776:  MOVWF  x4C
4778:  MOVLB  0
477A:  RCALL  447E
477C:  MOVFF  01,348
4780:  MOVLW  24
4782:  MOVLB  3
4784:  SUBWF  x1F,W
4786:  MOVWF  00
4788:  MOVLW  03
478A:  SUBWFB x20,W
478C:  MOVWF  03
478E:  MOVF   00,W
4790:  ADDWF  01,W
4792:  MOVWF  01
4794:  MOVF   02,W
4796:  ADDWFC 03,F
4798:  MOVFF  01,321
479C:  MOVFF  03,322
....................       ++sc; 
47A0:  INCF   x1B,F
47A2:  BTFSC  FD8.2
47A4:  INCF   x1C,F
....................       sd=memchr(digits,tolower(*sc),base); 
47A6:  MOVFF  31C,03
47AA:  MOVFF  31B,FE9
47AE:  MOVFF  31C,FEA
47B2:  MOVFF  FEF,348
47B6:  MOVF   x48,W
47B8:  SUBLW  40
47BA:  BC    47C8
47BC:  MOVF   x48,W
47BE:  SUBLW  5A
47C0:  BNC   47C8
47C2:  MOVF   x48,W
47C4:  IORLW  20
47C6:  BRA    47CA
47C8:  MOVF   x48,W
47CA:  MOVWF  x48
47CC:  MOVLW  03
47CE:  MOVWF  x4A
47D0:  MOVLW  24
47D2:  MOVWF  x49
47D4:  MOVFF  348,34B
47D8:  MOVFF  31A,34C
47DC:  MOVLB  0
47DE:  RCALL  443A
47E0:  MOVFF  02,320
47E4:  MOVFF  01,31F
....................    } 
47E8:  BRA    4750
47EA:  MOVLB  3
....................    if(s1==sc) 
47EC:  MOVF   x1B,W
47EE:  SUBWF  x1D,W
47F0:  BNZ   4818
47F2:  MOVF   x1C,W
47F4:  SUBWF  x1E,W
47F6:  BNZ   4818
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
47F8:  MOVF   x18,W
47FA:  IORWF  x19,W
47FC:  BZ    4810
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
47FE:  MOVFF  318,FE9
4802:  MOVFF  319,FEA
4806:  MOVFF  317,FEC
480A:  MOVF   FED,F
480C:  MOVFF  316,FEF
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
4810:  MOVLW  00
4812:  MOVWF  01
4814:  MOVWF  02
4816:  BRA    4838
....................    } 
....................    if (endptr) 
4818:  MOVF   x18,W
481A:  IORWF  x19,W
481C:  BZ    4830
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
481E:  MOVFF  318,FE9
4822:  MOVFF  319,FEA
4826:  MOVFF  31C,FEC
482A:  MOVF   FED,F
482C:  MOVFF  31B,FEF
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
4830:  MOVFF  321,01
4834:  MOVFF  322,02
.................... } 
4838:  MOVLB  0
483A:  GOTO   49C2 (RETURN)
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
0E48:  MOVFF  4D,2F4
0E4C:  MOVFF  4C,2F3
0E50:  MOVFF  4B,2F2
0E54:  MOVFF  4A,2F1
0E58:  MOVLW  41
0E5A:  MOVLB  2
0E5C:  MOVWF  xF8
0E5E:  MOVLW  C6
0E60:  MOVWF  xF7
0E62:  MOVLW  4E
0E64:  MOVWF  xF6
0E66:  MOVLW  6D
0E68:  MOVWF  xF5
0E6A:  MOVLB  0
0E6C:  BRA    0DA2
0E6E:  MOVLW  39
0E70:  MOVLB  2
0E72:  ADDWF  00,W
0E74:  MOVWF  4A
0E76:  MOVLW  30
0E78:  ADDWFC 01,W
0E7A:  MOVWF  4B
0E7C:  MOVLW  00
0E7E:  ADDWFC 02,W
0E80:  MOVWF  4C
0E82:  MOVLW  00
0E84:  ADDWFC 03,W
0E86:  MOVWF  4D
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
0E88:  MOVFF  4C,00
0E8C:  MOVFF  4D,01
0E90:  CLRF   02
0E92:  CLRF   03
0E94:  MOVFF  4D,2F3
0E98:  MOVFF  4C,2F2
0E9C:  MOVFF  4D,2F5
0EA0:  MOVFF  4C,2F4
0EA4:  MOVLW  7F
0EA6:  MOVWF  xF7
0EA8:  MOVLW  FF
0EAA:  MOVWF  xF6
0EAC:  MOVLB  0
0EAE:  BRA    0E00
0EB0:  MOVFF  00,01
0EB4:  MOVFF  03,02
.................... } 
0EB8:  GOTO   0FCE (RETURN)
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
*
0D8E:  MOVFF  2F4,4D
0D92:  MOVFF  2F3,4C
0D96:  MOVFF  2F2,4B
0D9A:  MOVFF  2F1,4A
.................... } 
0D9E:  GOTO   0FCC (RETURN)
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Functions for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.C 
....................  * Dependencies:    compiler.h 
....................  *                  helpers.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     6/25/02  Rewritten CalcIPChecksum() to avoid 
....................  *                               multi-byte shift operation. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Howard Schlunder		2/9/05	Added hexatob(), btohexa_high(), and 
....................  *								btohexa_low() 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        BYTE hexatob(WORD_VAL AsciiChars) 
.................... * 
.................... * PreCondition:    None 
.................... * 
.................... * Input:           Two ascii bytes; each ranged '0'-'9', 'A'-'F', or 
.................... *						'a'-'f' 
.................... * 
.................... * Output:          The resulting packed byte: 0x00-0xFF 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:			None 
.................... ********************************************************************/ 
.................... BYTE hexatob(WORD_VAL AsciiChars) 
.................... { 
.................... 	// Convert lowercase to uppercase 
.................... 	if(AsciiChars.v[1] > 'F') 
.................... 		AsciiChars.v[1] -= 'a'-'A'; 
.................... 	if(AsciiChars.v[0] > 'F') 
.................... 		AsciiChars.v[0] -= 'a'-'A'; 
....................  
.................... 	// Convert 0-9, A-F to 0x0-0xF 
.................... 	if(AsciiChars.v[1] > '9') 
.................... 		AsciiChars.v[1] -= 'A' - 10; 
.................... 	else 
.................... 		AsciiChars.v[1] -= '0'; 
....................  
.................... 	if(AsciiChars.v[0] > '9') 
.................... 		AsciiChars.v[0] -= 'A' - 10; 
.................... 	else 
.................... 		AsciiChars.v[0] -= '0'; 
....................  
.................... 	// Concatenate 
.................... 	return (AsciiChars.v[1]<<4) |  AsciiChars.v[0]; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_high(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *					or 'A'-'F' that corresponds to the upper 4 bits of 
....................  *					the input byte. 
....................  *					ex: b = 0xAE, btohexa_high() returns 'A' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:			None 
....................  ********************************************************************/ 
.................... BYTE btohexa_high(BYTE b) 
.................... { 
.................... 	b >>= 4; 
.................... 	return (b>0x9) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_low(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *					or 'A'-'F' that corresponds to the lower 4 bits of 
....................  *					the input byte. 
....................  *					ex: b = 0xAE, btohexa_low() returns 'E' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:			None 
....................  ********************************************************************/ 
.................... BYTE btohexa_low(BYTE b) 
.................... { 
.................... 	b &= 0x0F; 
.................... 	return (b>9) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... WORD swaps(WORD_VAL v) 
.................... { 
....................     WORD_VAL new; 
....................  
....................     new.v[0]=v.v[1]; 
*
1326:  MOVFF  39D,39E
....................     new.v[1]=v.v[0]; 
132A:  MOVFF  39C,39F
....................  
....................     return(new.Val); 
132E:  MOVLB  3
1330:  MOVFF  39E,01
1334:  MOVFF  39F,02
.................... } 
1338:  MOVLB  0
133A:  RETLW  00
....................  
.................... DWORD swapl(DWORD_VAL v) 
.................... { 
....................     DWORD_VAL new; 
....................  
....................     new.v[0]=v.v[3]; 
*
21DA:  MOVFF  388,389
....................     new.v[1]=v.v[2]; 
21DE:  MOVFF  387,38A
....................     new.v[2]=v.v[1]; 
21E2:  MOVFF  386,38B
....................     new.v[3]=v.v[0]; 
21E6:  MOVFF  385,38C
....................  
....................     return(new.Val); 
21EA:  MOVFF  389,00
21EE:  MOVFF  38A,01
21F2:  MOVFF  38B,02
21F6:  MOVFF  38C,03
.................... } 
21FA:  RETLW  00
....................  
.................... WORD CalcIPChecksum(BYTE* buffer, WORD count) 
.................... { 
.................... 	WORD i; 
.................... 	WORD *val; 
....................  
.................... 	union 
.................... 	{ 
.................... 		DWORD Val; 
.................... 		struct 
.................... 		{ 
.................... 			WORD_VAL LSB; 
.................... 			WORD_VAL MSB; 
.................... 		} words; 
.................... 	} tempSum, sum; 
....................  
.................... 	sum.Val = 0; 
*
1F5E:  MOVLB  3
1F60:  CLRF   x8E
1F62:  CLRF   x8D
1F64:  CLRF   x8C
1F66:  CLRF   x8B
....................  
.................... 	i = count >> 1; 
1F68:  BCF    FD8.0
1F6A:  RRCF   x82,W
1F6C:  MOVWF  x84
1F6E:  RRCF   x81,W
1F70:  MOVWF  x83
.................... 	val = (WORD *)buffer; 
1F72:  MOVFF  380,386
1F76:  MOVFF  37F,385
....................  
.................... 	while( i-- ) 
.................... 		sum.Val += *val++; 
1F7A:  MOVFF  384,03
1F7E:  MOVF   x83,W
1F80:  BTFSC  FD8.2
1F82:  DECF   x84,F
1F84:  DECF   x83,F
1F86:  IORWF  03,W
1F88:  BZ    1FB8
1F8A:  MOVFF  386,03
1F8E:  MOVFF  385,00
1F92:  MOVLW  02
1F94:  ADDWF  x85,F
1F96:  BTFSC  FD8.0
1F98:  INCF   x86,F
1F9A:  MOVFF  00,FE9
1F9E:  MOVFF  03,FEA
1FA2:  MOVFF  FEC,03
1FA6:  MOVF   FED,F
1FA8:  MOVF   FEF,W
1FAA:  ADDWF  x8B,F
1FAC:  MOVF   03,W
1FAE:  ADDWFC x8C,F
1FB0:  MOVLW  00
1FB2:  ADDWFC x8D,F
1FB4:  ADDWFC x8E,F
1FB6:  BRA    1F7A
....................  
.................... 	if ( count & 1 ) 
1FB8:  MOVF   x81,W
1FBA:  ANDLW  01
1FBC:  MOVWF  00
1FBE:  CLRF   03
1FC0:  MOVF   00,W
1FC2:  IORWF  03,W
1FC4:  BZ    1FDA
.................... 		sum.Val += *(BYTE *)val; 
1FC6:  MOVFF  385,FE9
1FCA:  MOVFF  386,FEA
1FCE:  MOVF   FEF,W
1FD0:  ADDWF  x8B,F
1FD2:  MOVLW  00
1FD4:  ADDWFC x8C,F
1FD6:  ADDWFC x8D,F
1FD8:  ADDWFC x8E,F
....................  
.................... 	tempSum.Val = sum.Val; 
1FDA:  MOVFF  38E,38A
1FDE:  MOVFF  38D,389
1FE2:  MOVFF  38C,388
1FE6:  MOVFF  38B,387
....................  
.................... 	while( (i = tempSum.words.MSB.Val) != 0u ) 
.................... 	{ 
1FEA:  MOVFF  38A,384
1FEE:  MOVFF  389,383
1FF2:  MOVF   x83,F
1FF4:  BNZ   1FFA
1FF6:  MOVF   x84,F
1FF8:  BZ    2038
.................... 		sum.words.MSB.Val = 0; 
1FFA:  CLRF   x8E
1FFC:  CLRF   x8D
.................... 		sum.Val = (DWORD)sum.words.LSB.Val + (DWORD)i; 
1FFE:  CLRF   x92
2000:  CLRF   x91
2002:  MOVFF  38C,390
2006:  MOVFF  38B,38F
200A:  CLRF   02
200C:  CLRF   03
200E:  MOVF   x83,W
2010:  ADDWF  x8B,W
2012:  MOVWF  x8B
2014:  MOVF   x84,W
2016:  ADDWFC x8C,W
2018:  MOVWF  x8C
201A:  MOVF   02,W
201C:  ADDWFC x91,W
201E:  MOVWF  x8D
2020:  MOVF   03,W
2022:  ADDWFC x92,W
2024:  MOVWF  x8E
.................... 		tempSum.Val = sum.Val; 
2026:  MOVFF  38E,38A
202A:  MOVFF  38D,389
202E:  MOVFF  38C,388
2032:  MOVFF  38B,387
.................... 	} 
2036:  BRA    1FEA
....................  
.................... 	return (~sum.words.LSB.Val); 
2038:  MOVFF  38C,03
203C:  COMF   03,F
203E:  MOVF   x8B,W
2040:  XORLW  FF
2042:  MOVWF  01
2044:  MOVFF  03,02
.................... } 
2048:  MOVLB  0
204A:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  MAC buffer pointer set to starting of buffer 
....................  * 
....................  * Input:           len     - Total number of bytes to calculate 
....................  *                          checksum for. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs checksum calculation in 
....................  *                  MAC buffer itself. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #if !defined(MCHP_MAC) 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................     BOOL lbMSB; 
....................     WORD_VAL checkSum; 
....................     BYTE Checkbyte; 
....................  
....................     lbMSB = TRUE; 
....................     checkSum.Val = 0; 
....................  
....................     while( len-- ) 
....................     { 
....................         Checkbyte = MACGet(); 
....................  
....................         if ( !lbMSB ) 
....................         { 
....................             if ( (checkSum.v[0] = Checkbyte+checkSum.v[0]) < Checkbyte) 
....................             { 
....................                 if ( ++checkSum.v[1] == 0 ) 
....................                     checkSum.v[0]++; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             if ( (checkSum.v[1] = Checkbyte+checkSum.v[1]) < Checkbyte) 
....................             { 
....................                 if ( ++checkSum.v[0] == 0 ) 
....................                     checkSum.v[1]++; 
....................             } 
....................         } 
....................  
....................         lbMSB = !lbMSB; 
....................     } 
....................  
....................     checkSum.v[1] = ~checkSum.v[1]; 
....................     checkSum.v[0] = ~checkSum.v[0]; 
....................     return checkSum.Val; 
.................... } 
.................... #endif 
....................  
....................  
.................... char *strupr (char *s) 
.................... { 
....................     char c; 
....................     char *t; 
....................  
....................     t = s; 
....................     while( (c = *t) ) 
....................     { 
....................         if ( (c >= 'a' && c <= 'z') ) 
....................             *t -= ('a' - 'A'); 
....................     t++; 
....................     } 
....................     return s; 
.................... } 
....................  
.................... void delay_s(int8 s) { 
....................    while(s) { 
....................       restart_wdt(); 
....................       delay_ms(1000); 
....................       s--; 
....................    } 
.................... } 
....................  
.................... #include "tcpip/tick.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.c 
....................  * Dependencies:    stackTSK.h 
....................  *                  Tick.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    01/16/04 Intermediate counter vars added 
....................  * R. Shelquist (CCS)   09/23/04 TickGet() temporarily disables Timer0 interrupt 
....................  ********************************************************************/ 
....................  
.................... #define TICK_INCLUDE 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               10 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... TICKTYPE TickCount = 0;  //increment every 100ms 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void) 
.................... { 
....................     setup_timer_0(RTCC_INTERNAL | RTCC_DIV_16); 
*
08CE:  MOVLW  83
08D0:  MOVWF  FD5
....................     set_timer0(TICK_COUNTER); 
08D2:  MOVLW  85
08D4:  MOVWF  FD7
08D6:  MOVLW  ED
08D8:  MOVWF  FD6
....................  
....................     enable_interrupts(INT_TIMER0); 
08DA:  BSF    FF2.5
....................     enable_interrupts(GLOBAL); 
08DC:  MOVLW  C0
08DE:  IORWF  FF2,F
.................... } 
08E0:  GOTO   1172 (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void) 
.................... { 
....................     int16 ret; 
....................     disable_interrupts(INT_TIMER0); 
*
2600:  BCF    FF2.5
....................     ret=TickCount; 
2602:  MOVFF  50,341
2606:  MOVFF  4F,340
....................     enable_interrupts(INT_TIMER0); 
260A:  BSF    FF2.5
....................     return ret; 
260C:  MOVLB  3
260E:  MOVFF  340,01
2612:  MOVFF  341,02
.................... } 
2616:  MOVLB  0
2618:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int8 second_counter=0;  //increment this every 1s 
.................... int8 second_counter_intermediate=0; 
....................  
.................... #if STACK_USE_PPP 
....................  int8 ppp_second_counter=0; 
....................  int8 ppp_second_counter_intermediate=0; 
.................... #endif 
....................  
.................... #int_timer0 
.................... void Tick_Isr(void) 
.................... { 
....................         TickCount++;    //increment this every 100ms 
*
00B4:  INCF   4F,F
00B6:  BTFSC  FD8.2
00B8:  INCF   50,F
....................  
....................         second_counter_intermediate++; 
00BA:  INCF   52,F
....................         if (second_counter_intermediate >= TICKS_PER_SECOND) { 
00BC:  MOVF   52,W
00BE:  SUBLW  09
00C0:  BC    00C6
....................             second_counter++; //increment this ever 1s 
00C2:  INCF   51,F
....................             second_counter_intermediate=0; 
00C4:  CLRF   52
....................         } 
....................  
....................  
....................        #if STACK_USE_PPP 
....................         ppp_second_counter_intermediate++; 
....................         if (ppp_second_counter_intermediate >= TICKS_PER_SECOND) { 
....................             ppp_second_counter_intermediate=0; 
....................             ppp_second_counter++; 
....................         } 
....................        #endif 
....................  
....................  
....................     set_timer0(TICK_COUNTER); //set timer0 to properly interrupt every 100ms 
00C6:  MOVLW  85
00C8:  MOVWF  FD7
00CA:  MOVLW  ED
00CC:  MOVWF  FD6
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //#define debug_stack  debug_printf 
.................... #define debug_stack 
....................  
.................... #if STACK_USE_MAC 
....................    #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................    #if STACK_USE_MCPENC 
....................     #include "tcpip/enc28j60.c" 
.................... /********************************************************************* 
....................  * 
....................  *     MAC Module (Microchip ENC28J60) for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.c 
....................  * Dependencies:    ENC28J60.h 
....................  *                    MAC.h 
....................  *                    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                    Delay.h 
....................  * Processor:       PIC18 
....................  * Complier:        MCC18 v3.00 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder      6/28/04   Original 
....................  * Howard Schlunder      10/8/04   Cleanup 
....................  * Howard Schlunder      10/19/04 Small optimizations and more cleanup 
....................  * Howard Schlunder      11/29/04 Added Set/GetCLKOUT 
....................  * Howard Schlunder      12/23/05 Added B1 silicon errata workarounds 
....................  * Howard Schlunder      1/09/06   Added comments and minor mods 
....................  * Howard Schlunder      1/18/06 Added more silicon errata workarounds 
....................  * Howard Schlunder      2/20/06 Fixed TXSTART, RXSTOP 
....................  * Darren Rook          7/11/06  CCS Port 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
.................... ********************************************************************/ 
.................... #define THIS_IS_MAC_LAYER 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/Helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/MAC.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #if STACK_USE_SLIP 
.................... #error Unexpected module is detected. 
.................... #error This file must be linked when SLIP module is not in use. 
.................... #endif 
....................  
.................... #define debug_mac 
.................... //#define debug_mac debug_printf 
....................  
....................    #ifndef PIN_ENC_MAC_SO 
....................       #define PIN_ENC_MAC_SO  PIN_D7   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_D6   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_D5 
....................       #define PIN_ENC_MAC_CS  PIN_D4 
....................       #define PIN_ENC_MAC_RST PIN_D3 
....................       #define PIN_ENC_MAC_INT PIN_D2 
....................       #define PIN_ENC_MAC_WOL PIN_D1 
....................       #define ENC_MAC_USE_SPI FALSE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       //#define mac_enc_spi_tris_init()  *0xF93=(*0xF93 | 0b11); *0xF94 = (*0xF94 & 0b11010111) | 0x10; *0xF95=*0xF95 & 0xFC 
....................       #define mac_enc_spi_tris_init()  *0xF95= (0b10000110); 
....................      #endif 
....................  
.................... #define SPISelectEthernet()      output_low(PIN_ENC_MAC_CS) //changed by ccs 
.................... #define SPIUnselectEthernet()   output_high(PIN_ENC_MAC_CS)   //changed by ccs 
....................  
.................... /** D E F I N I T I O N S ****************************************************/ 
.................... /* Hardware interface to NIC. */ 
.................... //#define MCP_RESET_TRIS   (TRISB_RB5)   //CCS wont use these 
.................... //#define MCP_RESET_IO   (LATB5)          //CCS wont use these 
.................... //#define MCP_CS_TRIS      (TRISB_RB3)   //CCS wont use these 
.................... //#define MCP_CS_IO      (LATB3)          //CCS wont use these 
.................... // The following SPI pins are used but are not configurable 
.................... //   RC3 is used for the SCK pin and is an output 
.................... //   RC4 is used for the SDI pin and is an input 
.................... //   RC5 is used for the SDO pin and is an output 
.................... // IMPORTANT SPI NOTE: The code in this file expects that the SPI interrupt 
.................... //      flag (PIR1_SSPIF) be clear at all times.  If the SPI is shared with 
.................... //      other hardware, the other code should clear the PIR1_SSPIF when it is 
.................... //      done using the SPI. 
....................  
.................... // Since the ENC28J60 doesn't support auto-negotiation, full-duplex mode is 
.................... // not compatible with most switches/routers.  If a dedicated network is used 
.................... // where the duplex of the remote node can be manually configured, you may 
.................... // change this configuration.  Otherwise, half duplex should always be used. 
.................... #define HALF_DUPLEX 
.................... //#define FULL_DUPLEX 
.................... //#define LEDB_DUPLEX 
....................  
.................... // Pseudo Functions 
.................... #define LOW(a)                (a & 0xFF) 
.................... #define HIGH(a)             ((a>>8) & 0xFF) 
....................  
.................... // NIC RAM definitions 
.................... #define RAMSIZE   8192ul 
.................... #define TXSTART (RAMSIZE-(MAC_TX_BUFFER_COUNT * (MAC_TX_BUFFER_SIZE + 8ul))) 
.................... #define RXSTART   (0ul)                  // Should be an even memory address 
.................... #define   RXSTOP   ((TXSTART-2ul) | 0x0001ul)   // Odd for errata workaround 
.................... #define RXSIZE   (RXSTOP-RXSTART+1ul) 
....................  
.................... // ENC28J60 Opcodes (to be ORed with a 5 bit address) 
.................... #define   WCR (0b010<<5)         // Write Control Register command 
.................... #define BFS (0b100<<5)         // Bit Field Set command 
.................... #define   BFC (0b101<<5)         // Bit Field Clear command 
.................... #define   RCR (0b000<<5)         // Read Control Register command 
.................... #define RBM ((0b001<<5) | 0x1A)   // Read Buffer Memory command 
.................... #define   WBM ((0b011<<5) | 0x1A) // Write Buffer Memory command 
.................... #define   SR  ((0b111<<5) | 0x1F)   // System Reset command does not use an address. 
....................                         //   It requires 0x1F, however. 
....................  
.................... #define ETHER_IP   (0x00u) 
.................... #define ETHER_ARP   (0x06u) 
....................  
.................... #define MAXFRAMEC   (1500u+sizeof(ETHER_HEADER)+4u) 
....................  
.................... // A generic structure representing the Ethernet header starting all Ethernet 
.................... // frames 
00CE:  BCF    FF2.2
00D0:  GOTO   0054
.................... typedef struct _ETHER_HEADER 
.................... { 
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ETHER_HEADER; 
....................  
.................... // A header appended at the start of all RX frames by the hardware 
.................... typedef struct _ENC_PREAMBLE 
.................... { 
....................     int16         NextPacketPointer; 
....................     RXSTATUS      StatusVector; 
....................  
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ENC_PREAMBLE; 
....................  
.................... typedef struct _DATA_BUFFER 
.................... { 
....................    WORD_VAL StartAddress; 
....................    WORD_VAL EndAddress; 
....................    struct 
....................    { 
....................       unsigned char bFree : 1; 
....................       unsigned char bTransmitted : 1; 
....................    } Flags; 
.................... } DATA_BUFFER; 
....................  
.................... void MACSetDuplex(DUPLEX DuplexState); 
....................  
.................... // Prototypes of functions intended for MAC layer use only. 
.................... static void BankSel(WORD Register); 
.................... static REG ReadETHReg(BYTE Address); 
.................... static REG ReadMACReg(BYTE Address); 
.................... static void WriteReg(BYTE Address, BYTE Data); 
.................... static void BFCReg(BYTE Address, BYTE Data); 
.................... static void BFSReg(BYTE Address, BYTE Data); 
.................... static void SendSystemReset(void); 
.................... //static void GetRegs(void); 
.................... #ifdef MAC_POWER_ON_TEST 
.................... static BOOL TestMemory(void); 
.................... #endif 
....................  
.................... /* Internal and externally used MAC level variables */ 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... #endif 
....................  
.................... // Internal and externally used MAC level variables. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... BUFFER LastTXedBuffer; 
.................... #endif 
....................  
....................  
.................... // Internal MAC level variables and flags. 
.................... WORD_VAL NextPacketLocation; 
.................... WORD_VAL CurrentPacketLocation; 
.................... BOOL WasDiscarded; 
.................... BYTE ENCRevID; 
....................  
.................... //ENCSPIInit() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... void ENCSPIInit(void) 
.................... { 
....................  
....................    #ifdef mac_enc_spi_tris_init 
....................    mac_enc_spi_tris_init();  //MCP_RESET_TRIS = 0; 
....................    #endif 
....................  
....................  #if ENC_MAC_USE_SPI 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4); 
*
08E4:  BCF    FC6.5
08E6:  BCF    F94.7
08E8:  BSF    F93.0
08EA:  BCF    F93.1
08EC:  MOVLW  20
08EE:  MOVWF  FC6
08F0:  MOVLW  40
08F2:  MOVWF  FC7
....................  #else 
....................     
....................    output_low(PIN_ENC_MAC_CLK); 
....................    output_float(PIN_ENC_MAC_SO); 
....................  #endif 
....................    // 
....................    // Set up the SPI module on the PIC for communications with the ENC28J60 
....................    // 
....................    SPIUnselectEthernet(); 
08F4:  BCF    F93.2
08F6:  BSF    F8A.2
....................  
....................    // Deassert the nRESET pin on the ENC28J60.  The internal 
....................    // weak pull on the nRESET pin will get the job done anyway, 
....................    // so this isn't necessary, but it may provide extra noise immunity, 
....................    // should someone put their finger on the pin or otherwise cause a leakage 
....................    // path to ground on this pin. 
....................    output_high(PIN_ENC_MAC_RST);            //MCP_RESET_IO = 1; 
08F8:  BCF    F93.3
08FA:  BSF    F8A.3
.................... } 
08FC:  GOTO   0BA2 (RETURN)
....................  
.................... //ENCSPIXfer() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... char ENCSPIXfer(char c) 
.................... { 
....................  #if ENC_MAC_USE_SPI 
....................    return(spi_read(c)); 
0900:  MOVF   FC9,W
0902:  MOVFF  3A7,FC9
0906:  RRCF   FC7,W
0908:  BNC   0906
090A:  MOVFF  FC9,01
....................  #else 
....................    int8 i, in; 
....................    for (i=0;i<8;i++) { 
....................       output_bit(PIN_ENC_MAC_SI, shift_left(&c, 1, 0)); 
....................       output_high(PIN_ENC_MAC_CLK); 
....................       shift_left(&in, 1, input(PIN_ENC_MAC_SO)); 
....................       output_low(PIN_ENC_MAC_CLK); 
....................    } 
....................    return(in); 
....................  #endif 
.................... } 
090E:  RETLW  00
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACInit sets up the PIC's SPI module and all the 
....................  *               registers in the ENC28J60 so that normal operation can 
....................  *               begin. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACInit(void) 
.................... { 
....................    BYTE i; 
....................  
....................    ENCSPIInit(); 
*
0BA0:  BRA    08E4
....................  
....................    // Wait for CLKRDY to become set. 
....................    // Bit 3 in ESTAT is an unimplemented bit.  If it reads out as '1' that 
....................    // means the part is in RESET or otherwise our SPI pin is being driven 
....................    // incorrectly.  Make sure it is working before proceeding. 
....................    do 
....................    { 
....................       i = ReadETHReg(ESTAT).Val; 
0BA2:  MOVLW  1D
0BA4:  MOVLB  3
0BA6:  MOVWF  x9C
0BA8:  MOVLB  0
0BAA:  RCALL  0910
0BAC:  MOVFF  01,2EE
....................    } while((i & 0x08) || (~i & ESTAT_CLKRDY)); 
0BB0:  MOVLB  2
0BB2:  BTFSS  xEE.3
0BB4:  BRA    0BBA
0BB6:  MOVLB  0
0BB8:  BRA    0BA2
0BBA:  MOVF   xEE,W
0BBC:  XORLW  FF
0BBE:  ANDLW  01
0BC0:  BTFSC  FD8.2
0BC2:  BRA    0BC8
0BC4:  MOVLB  0
0BC6:  BRA    0BA2
....................  
....................  
.................... #ifdef MAC_POWER_ON_TEST 
....................    // Do the memory test and enter a while always trap if a hardware error 
....................    // occured.  The LEDA and LEDB pins will be configured to blink 
....................    // periodically in an abnormal manner to indicate to the user that the 
....................    // error occured. 
....................    if( !TestMemory() ) 
....................    { 
....................       SetLEDConfig(0x0AA2);      // Set LEDs to blink periodically 
....................       while(1); 
....................    } 
.................... #endif 
....................  
....................    // RESET the entire ENC28J60, clearing all registers 
....................    SendSystemReset(); 
0BC8:  MOVLB  0
0BCA:  BRA    093A
....................     delay_ms(1); 
0BCC:  MOVLW  01
0BCE:  MOVLB  3
0BD0:  MOVWF  x22
0BD2:  MOVLB  0
0BD4:  RCALL  05DC
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................     // On Init, all transmit buffers are free. 
....................     for (i = 0; i < MAC_TX_BUFFER_COUNT; i++ ) 
....................     { 
....................         TxBuffers[i].StartAddress.Val = TXSTART + ((WORD)i * (MAC_TX_BUFFER_SIZE+8)); 
....................         TxBuffers[i].Flags.bFree = TRUE; 
....................     } 
.................... #endif 
....................     CurrentTxBuffer = 0; 
0BD6:  CLRF   4E
....................  
....................    // Start up in Bank 0 and configure the receive buffer boundary pointers 
....................    // and the buffer write protect pointer (receive buffer read pointer) 
....................    WasDiscarded = TRUE; 
0BD8:  BSF    57.0
....................    NextPacketLocation.Val = RXSTART; 
0BDA:  CLRF   54
0BDC:  CLRF   53
....................    WriteReg(ERXSTL, LOW(RXSTART)); 
0BDE:  MOVLW  08
0BE0:  MOVLB  3
0BE2:  MOVWF  xA2
0BE4:  CLRF   xA3
0BE6:  MOVLB  0
0BE8:  RCALL  0950
....................    WriteReg(ERXSTH, HIGH(RXSTART)); 
0BEA:  MOVLW  09
0BEC:  MOVLB  3
0BEE:  MOVWF  xA2
0BF0:  CLRF   xA3
0BF2:  MOVLB  0
0BF4:  RCALL  0950
....................    WriteReg(ERXRDPTL, LOW(RXSTOP));   // Write low byte first 
0BF6:  MOVLW  0C
0BF8:  MOVLB  3
0BFA:  MOVWF  xA2
0BFC:  MOVLW  F7
0BFE:  MOVWF  xA3
0C00:  MOVLB  0
0C02:  RCALL  0950
....................    WriteReg(ERXRDPTH, HIGH(RXSTOP));   // Write high byte last 
0C04:  MOVLW  0D
0C06:  MOVLB  3
0C08:  MOVWF  xA2
0C0A:  MOVLW  1B
0C0C:  MOVWF  xA3
0C0E:  MOVLB  0
0C10:  RCALL  0950
.................... #if RXSTOP != 0x1FFF   // The RESET default ERXND is 0x1FFF 
....................    WriteReg(ERXNDL, LOW(RXSTOP)); 
0C12:  MOVLW  0A
0C14:  MOVLB  3
0C16:  MOVWF  xA2
0C18:  MOVLW  F7
0C1A:  MOVWF  xA3
0C1C:  MOVLB  0
0C1E:  RCALL  0950
....................    WriteReg(ERXNDH, HIGH(RXSTOP)); 
0C20:  MOVLW  0B
0C22:  MOVLB  3
0C24:  MOVWF  xA2
0C26:  MOVLW  1B
0C28:  MOVWF  xA3
0C2A:  MOVLB  0
0C2C:  RCALL  0950
.................... #endif 
.................... #if TXSTART != 0      // The RESET default ETXST is 0 
....................    WriteReg(ETXSTL, LOW(TXSTART)); 
0C2E:  MOVLW  04
0C30:  MOVLB  3
0C32:  MOVWF  xA2
0C34:  MOVLW  F8
0C36:  MOVWF  xA3
0C38:  MOVLB  0
0C3A:  RCALL  0950
....................    WriteReg(ETXSTH, HIGH(TXSTART)); 
0C3C:  MOVLW  05
0C3E:  MOVLB  3
0C40:  MOVWF  xA2
0C42:  MOVLW  1B
0C44:  MOVWF  xA3
0C46:  MOVLB  0
0C48:  RCALL  0950
.................... #endif 
....................  
....................    // Enter Bank 1 and configure Receive Filters 
....................    // (No need to reconfigure - Unicast OR Broadcast with CRC checking is 
....................    // acceptable) 
....................    // Write ERXFCON_CRCEN only to ERXFCON to enter promiscuous mode 
....................    //BankSel(ERXFCON); 
....................    //WriteReg((BYTE)ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN | ERXFCON_HTEN); 
....................  
....................    // Enter Bank 2 and configure the MAC 
....................    BankSel(MACON1); 
0C4A:  MOVLW  02
0C4C:  MOVLB  3
0C4E:  MOVWF  xA0
0C50:  CLRF   x9F
0C52:  MOVLB  0
0C54:  RCALL  09AA
....................  
....................    // Enable the receive portion of the MAC 
....................    WriteReg((BYTE)MACON1, MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN); 
0C56:  MOVLB  3
0C58:  CLRF   xA2
0C5A:  MOVLW  0D
0C5C:  MOVWF  xA3
0C5E:  MOVLB  0
0C60:  RCALL  0950
....................  
....................    // Pad packets to 60 bytes, add CRC, and check Type/Length field. 
....................    WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN); 
0C62:  MOVLW  02
0C64:  MOVLB  3
0C66:  MOVWF  xA2
0C68:  MOVLW  32
0C6A:  MOVWF  xA3
0C6C:  MOVLB  0
0C6E:  RCALL  0950
....................  
....................     // Allow infinite deferals if the medium is continuously busy 
....................     // (do not time out a transmission if the half duplex medium is 
....................     // completely saturated with other people's data) 
....................     WriteReg((BYTE)MACON4, MACON4_DEFER); 
0C70:  MOVLW  03
0C72:  MOVLB  3
0C74:  MOVWF  xA2
0C76:  MOVLW  40
0C78:  MOVWF  xA3
0C7A:  MOVLB  0
0C7C:  RCALL  0950
....................  
....................    // Late collisions occur beyond 63+8 bytes (8 bytes for preamble/start of frame delimiter) 
....................    // 55 is all that is needed for IEEE 802.3, but ENC28J60 B5 errata for improper link pulse 
....................    // collisions will occur less often with a larger number. 
....................     WriteReg((BYTE)MACLCON2, 63); 
0C7E:  MOVLW  09
0C80:  MOVLB  3
0C82:  MOVWF  xA2
0C84:  MOVLW  3F
0C86:  MOVWF  xA3
0C88:  MOVLB  0
0C8A:  RCALL  0950
....................  
....................    // Set non-back-to-back inter-packet gap to 9.6us.  The back-to-back 
....................    // inter-packet gap (MABBIPG) is set by MACSetDuplex() which is called 
....................    // later. 
....................    WriteReg((BYTE)MAIPGL, 0x12); 
0C8C:  MOVLW  06
0C8E:  MOVLB  3
0C90:  MOVWF  xA2
0C92:  MOVLW  12
0C94:  MOVWF  xA3
0C96:  MOVLB  0
0C98:  RCALL  0950
....................    WriteReg((BYTE)MAIPGH, 0x0C); 
0C9A:  MOVLW  07
0C9C:  MOVLB  3
0C9E:  MOVWF  xA2
0CA0:  MOVLW  0C
0CA2:  MOVWF  xA3
0CA4:  MOVLB  0
0CA6:  RCALL  0950
....................  
....................    // Set the maximum packet size which the controller will accept 
....................    WriteReg((BYTE)MAMXFLL, LOW(MAXFRAMEC)); 
0CA8:  MOVLW  0A
0CAA:  MOVLB  3
0CAC:  MOVWF  xA2
0CAE:  MOVLW  EE
0CB0:  MOVWF  xA3
0CB2:  MOVLB  0
0CB4:  RCALL  0950
....................    WriteReg((BYTE)MAMXFLH, HIGH(MAXFRAMEC)); 
0CB6:  MOVLW  0B
0CB8:  MOVLB  3
0CBA:  MOVWF  xA2
0CBC:  MOVLW  05
0CBE:  MOVWF  xA3
0CC0:  MOVLB  0
0CC2:  RCALL  0950
....................  
....................     // Enter Bank 3 and initialize physical MAC address registers 
....................    BankSel(MAADR1); 
0CC4:  MOVLW  03
0CC6:  MOVLB  3
0CC8:  MOVWF  xA0
0CCA:  MOVLW  04
0CCC:  MOVWF  x9F
0CCE:  MOVLB  0
0CD0:  RCALL  09AA
....................     WriteReg((BYTE)MAADR1, AppConfig.MyMACAddr.v[0]); 
0CD2:  MOVLW  04
0CD4:  MOVLB  3
0CD6:  MOVWF  xA2
0CD8:  MOVFF  1B,3A3
0CDC:  MOVLB  0
0CDE:  RCALL  0950
....................     WriteReg((BYTE)MAADR2, AppConfig.MyMACAddr.v[1]); 
0CE0:  MOVLW  05
0CE2:  MOVLB  3
0CE4:  MOVWF  xA2
0CE6:  MOVFF  1C,3A3
0CEA:  MOVLB  0
0CEC:  RCALL  0950
....................     WriteReg((BYTE)MAADR3, AppConfig.MyMACAddr.v[2]); 
0CEE:  MOVLW  02
0CF0:  MOVLB  3
0CF2:  MOVWF  xA2
0CF4:  MOVFF  1D,3A3
0CF8:  MOVLB  0
0CFA:  RCALL  0950
....................     WriteReg((BYTE)MAADR4, AppConfig.MyMACAddr.v[3]); 
0CFC:  MOVLW  03
0CFE:  MOVLB  3
0D00:  MOVWF  xA2
0D02:  MOVFF  1E,3A3
0D06:  MOVLB  0
0D08:  RCALL  0950
....................     WriteReg((BYTE)MAADR5, AppConfig.MyMACAddr.v[4]); 
0D0A:  MOVLB  3
0D0C:  CLRF   xA2
0D0E:  MOVFF  1F,3A3
0D12:  MOVLB  0
0D14:  RCALL  0950
....................     WriteReg((BYTE)MAADR6, AppConfig.MyMACAddr.v[5]); 
0D16:  MOVLW  01
0D18:  MOVLB  3
0D1A:  MOVWF  xA2
0D1C:  MOVFF  20,3A3
0D20:  MOVLB  0
0D22:  RCALL  0950
....................  
....................    // Get the Rev ID so that we can implement the correct errata workarounds 
....................    ENCRevID = ReadETHReg((BYTE)EREVID).Val; 
0D24:  MOVLW  12
0D26:  MOVLB  3
0D28:  MOVWF  x9C
0D2A:  MOVLB  0
0D2C:  RCALL  0910
0D2E:  MOVFF  01,58
....................  
....................    // Disable half duplex loopback in PHY.  Bank bits changed to Bank 2 as a 
....................    // side effect. 
....................    WritePHYReg(PHCON2, PHCON2_HDLDIS); 
0D32:  MOVLW  10
0D34:  MOVLB  2
0D36:  MOVWF  xF3
0D38:  MOVLW  01
0D3A:  MOVWF  xF5
0D3C:  CLRF   xF4
0D3E:  MOVLB  0
0D40:  RCALL  0A06
....................  
....................    // Configure LEDA to display LINK status, LEDB to display TX/RX activity 
....................    SetLEDConfig(0x0472); 
0D42:  MOVLW  14
0D44:  MOVLB  2
0D46:  MOVWF  xF3
0D48:  MOVLW  04
0D4A:  MOVWF  xF5
0D4C:  MOVLW  72
0D4E:  MOVWF  xF4
0D50:  MOVLB  0
0D52:  RCALL  0A06
....................  
....................    // Set the MAC and PHY into the proper duplex state 
.................... #if defined(FULL_DUPLEX) 
....................    MACSetDuplex(FULL);      // Function exits with Bank 2 selected 
.................... #elif defined(HALF_DUPLEX) 
....................    MACSetDuplex(HALF);      // Function exits with Bank 2 selected 
0D54:  MOVLB  2
0D56:  CLRF   xEF
0D58:  MOVLB  0
0D5A:  BRA    0B00
.................... #else 
....................    // Use the external LEDB polarity to determine weather full or half duplex 
....................    // communication mode should be set. 
....................    MACSetDuplex(USE_PHY);   // Function exits with Bank 2 selected 
.................... #endif 
....................  
....................    // Enable packet reception 
....................    BFSReg(ECON1, ECON1_RXEN); 
0D5C:  MOVLW  1F
0D5E:  MOVLB  3
0D60:  MOVWF  xA4
0D62:  MOVLW  04
0D64:  MOVWF  xA5
0D66:  MOVLB  0
0D68:  RCALL  098C
.................... }//end MACInit 
0D6A:  GOTO   1174 (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsLinked(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: If the PHY reports that a link partner is present 
....................  *                    and the link has been up continuously since the last 
....................  *                    call to MACIsLinked() 
....................  *               FALSE: If the PHY reports no link partner, or the link went 
....................  *                     down momentarily since the last call to MACIsLinked() 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the PHSTAT1.LLSTAT bit. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsLinked(void) 
.................... { 
....................    // LLSTAT is a latching low link status bit.  Therefore, if the link 
....................    // goes down and comes back up before a higher level stack program calls 
....................    // MACIsLinked(), MACIsLinked() will still return FALSE.  The next 
....................    // call to MACIsLinked() will return TRUE (unless the link goes down 
....................    // again). 
....................    return ReadPHYReg(PHSTAT1).PHSTAT1bits.LLSTAT; 
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           HighPriority: TRUE: Check the hardware ECON1.TXRTS bit 
....................  *                          FALSE: Check if a TX buffer is free 
....................  * 
....................  * Output:          TRUE: If no Ethernet transmission is in progress 
....................  *               FALSE: If a previous transmission was started, and it has 
....................  *                     not completed yet.  While FALSE, the data in the 
....................  *                     transmit buffer and the TXST/TXND pointers must not 
....................  *                     be changed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the ECON1.TXRTS bit 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsTxReady(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    BUFFER i; 
....................  
....................    if(HighPriority) 
.................... #endif 
....................    { 
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
*
271E:  MOVLW  1F
2720:  MOVLB  3
2722:  MOVWF  x9C
2724:  MOVLB  0
2726:  CALL   0910
272A:  MOVLW  00
272C:  BTFSS  01.3
272E:  MOVLW  01
2730:  MOVWF  01
2732:  BRA    2734
....................    } 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................  
....................    // Check if the current buffer can be modified.  It cannot be modified if 
....................    // the TX hardware is currently transmitting it. 
....................    if(CurrentTxBuffer == LastTXedBuffer) 
....................    { 
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
....................    } 
....................  
....................    // Check if a buffer is available for a new packet 
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
....................    { 
....................       if(TxBuffers[i].Flags.bFree) 
....................       { 
....................          return TRUE; 
....................       } 
....................    } 
....................  
....................    return FALSE; 
.................... #endif 
.................... } 
2734:  RETLW  00
....................  
.................... BUFFER MACGetTxBuffer(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    BUFFER i; 
....................  
....................    if(HighPriority) 
.................... #endif 
....................    { 
....................       return !ReadETHReg(ECON1).ECON1bits.TXRTS ? 0 : INVALID_BUFFER; 
*
162C:  MOVLW  1F
162E:  MOVLB  3
1630:  MOVWF  x9C
1632:  MOVLB  0
1634:  CALL   0910
1638:  BTFSC  01.3
163A:  BRA    1640
163C:  MOVLW  00
163E:  BRA    1642
1640:  MOVLW  FF
1642:  MOVWF  01
1644:  BRA    1646
....................    } 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    // Find a free buffer.  Do not use buffer 0, it is reserved for 
....................    // high priority messages that don't need to be acknowledged 
....................    // before being discarded (TCP control packets, all ICMP 
....................    // packets, all UDP packets, etc.) 
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
....................    { 
....................       // If this buffer is free, then mark it as used and return with it 
....................       if(TxBuffers[i].Flags.bFree) 
....................       { 
....................          TxBuffers[i].Flags.bFree = FALSE; 
....................          TxBuffers[i].Flags.bTransmitted = FALSE; 
....................          return i; 
....................       } 
....................    } 
....................  
....................    return INVALID_BUFFER; 
.................... #endif 
.................... } 
1646:  RETLW  00
....................  
....................  
.................... void MACDiscardTx(BUFFER buffer) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    if(buffer < sizeof(TxBuffers)/sizeof(TxBuffers[0])) 
....................    { 
....................        TxBuffers[buffer].Flags.bFree = TRUE; 
....................        CurrentTxBuffer = buffer; 
....................    } 
.................... #endif 
.................... } 
*
0004:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDiscardRx(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Marks the last received packet (obtained using 
....................  *               MACGetHeader())as being processed and frees the buffer 
....................  *               memory associated with it 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDiscardRx(void) 
.................... { 
....................    WORD_VAL NewRXRDLocation; 
....................  
....................    // Make sure the current packet was not already discarded 
....................    if( WasDiscarded ) 
*
1256:  BTFSS  57.0
1258:  BRA    125C
....................       return; 
125A:  BRA    12C0
....................    WasDiscarded = TRUE; 
125C:  BSF    57.0
....................  
....................    // Decrement the next packet pointer before writing it into 
....................    // the ERXRDPT registers.  This is a silicon errata workaround. 
....................    // RX buffer wrapping must be taken into account if the 
....................    // NextPacketLocation is precisely RXSTART. 
....................    NewRXRDLocation.Val = NextPacketLocation.Val - 1; 
125E:  MOVLW  01
1260:  SUBWF  53,W
1262:  MOVLB  3
1264:  MOVWF  x40
1266:  MOVLW  00
1268:  SUBWFB 54,W
126A:  MOVWF  x41
.................... #if RXSTART == 0 
....................    if(NewRXRDLocation.Val > RXSTOP) 
126C:  MOVF   x41,W
126E:  SUBLW  1A
1270:  BC    1284
1272:  XORLW  FF
1274:  BNZ   127C
1276:  MOVF   x40,W
1278:  SUBLW  F7
127A:  BC    1284
.................... #else 
....................    if(NewRXRDLocation.Val < RXSTART || NewRXRDLocation.Val > RXSTOP) 
.................... #endif 
....................    { 
....................       NewRXRDLocation.Val = RXSTOP; 
127C:  MOVLW  1B
127E:  MOVWF  x41
1280:  MOVLW  F7
1282:  MOVWF  x40
....................    } 
....................  
....................    // Decrement the RX packet counter register, EPKTCNT 
....................    BFSReg(ECON2, ECON2_PKTDEC); 
1284:  MOVLW  1E
1286:  MOVWF  xA4
1288:  MOVLW  40
128A:  MOVWF  xA5
128C:  MOVLB  0
128E:  CALL   098C
....................  
....................    // Move the receive read pointer to unwrite-protect the memory used by the 
....................    // last packet.  The writing order is important: set the low byte first, 
....................    // high byte last. 
....................    BankSel(ERXRDPTL); 
1292:  MOVLB  3
1294:  CLRF   xA0
1296:  MOVLW  0C
1298:  MOVWF  x9F
129A:  MOVLB  0
129C:  CALL   09AA
....................    WriteReg(ERXRDPTL, NewRXRDLocation.v[0]); 
12A0:  MOVLW  0C
12A2:  MOVLB  3
12A4:  MOVWF  xA2
12A6:  MOVFF  340,3A3
12AA:  MOVLB  0
12AC:  CALL   0950
....................    WriteReg(ERXRDPTH, NewRXRDLocation.v[1]); 
12B0:  MOVLW  0D
12B2:  MOVLB  3
12B4:  MOVWF  xA2
12B6:  MOVFF  341,3A3
12BA:  MOVLB  0
12BC:  CALL   0950
.................... } 
12C0:  RETLW  00
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetFreeRxSize(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          A WORD estimate of how much RX buffer space is free at 
....................  *               the present time. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetFreeRxSize(void) 
.................... { 
....................    WORD_VAL ReadPT, WritePT; 
....................  
....................    // Read the Ethernet hardware buffer write pointer.  Because packets can be 
....................    // received at any time, it can change between reading the low and high 
....................    // bytes.  A loop is necessary to make certain a proper low/high byte pair 
....................    // is read. 
....................    BankSel(EPKTCNT); 
*
2736:  MOVLW  01
2738:  MOVLB  3
273A:  MOVWF  xA0
273C:  MOVLW  19
273E:  MOVWF  x9F
2740:  MOVLB  0
2742:  CALL   09AA
....................    do { 
....................       // Save EPKTCNT in a temporary location 
....................       ReadPT.v[0] = ReadETHReg((BYTE)EPKTCNT).Val; 
2746:  MOVLW  19
2748:  MOVLB  3
274A:  MOVWF  x9C
274C:  MOVLB  0
274E:  CALL   0910
2752:  MOVFF  01,37D
....................  
....................       BankSel(ERXWRPTL); 
2756:  MOVLB  3
2758:  CLRF   xA0
275A:  MOVLW  0E
275C:  MOVWF  x9F
275E:  MOVLB  0
2760:  CALL   09AA
....................       WritePT.v[0] = ReadETHReg(ERXWRPTL).Val; 
2764:  MOVLW  0E
2766:  MOVLB  3
2768:  MOVWF  x9C
276A:  MOVLB  0
276C:  CALL   0910
2770:  MOVFF  01,37F
....................       WritePT.v[1] = ReadETHReg(ERXWRPTH).Val; 
2774:  MOVLW  0F
2776:  MOVLB  3
2778:  MOVWF  x9C
277A:  MOVLB  0
277C:  CALL   0910
2780:  MOVFF  01,380
....................  
....................       BankSel(EPKTCNT); 
2784:  MOVLW  01
2786:  MOVLB  3
2788:  MOVWF  xA0
278A:  MOVLW  19
278C:  MOVWF  x9F
278E:  MOVLB  0
2790:  CALL   09AA
....................    } while(ReadETHReg((BYTE)EPKTCNT).Val != ReadPT.v[0]); 
2794:  MOVLW  19
2796:  MOVLB  3
2798:  MOVWF  x9C
279A:  MOVLB  0
279C:  CALL   0910
27A0:  MOVLB  3
27A2:  MOVF   x7D,W
27A4:  SUBWF  01,W
27A6:  BTFSC  FD8.2
27A8:  BRA    27AE
27AA:  MOVLB  0
27AC:  BRA    2746
....................  
....................    // Determine where the write protection pointer is 
....................    BankSel(ERXRDPTL); 
27AE:  CLRF   xA0
27B0:  MOVLW  0C
27B2:  MOVWF  x9F
27B4:  MOVLB  0
27B6:  CALL   09AA
....................    ReadPT.v[0] = ReadETHReg(ERXRDPTL).Val; 
27BA:  MOVLW  0C
27BC:  MOVLB  3
27BE:  MOVWF  x9C
27C0:  MOVLB  0
27C2:  CALL   0910
27C6:  MOVFF  01,37D
....................    ReadPT.v[1] = ReadETHReg(ERXRDPTH).Val; 
27CA:  MOVLW  0D
27CC:  MOVLB  3
27CE:  MOVWF  x9C
27D0:  MOVLB  0
27D2:  CALL   0910
27D6:  MOVFF  01,37E
....................  
....................    // Calculate the difference between the pointers, taking care to account 
....................    // for buffer wrapping conditions 
....................    if ( WritePT.Val > ReadPT.Val ) 
27DA:  MOVLB  3
27DC:  MOVF   x7E,W
27DE:  SUBWF  x80,W
27E0:  BNC   280E
27E2:  BNZ   27EA
27E4:  MOVF   x7F,W
27E6:  SUBWF  x7D,W
27E8:  BC    280E
....................    { 
....................       return (RXSTOP - RXSTART) - (WritePT.Val - ReadPT.Val); 
27EA:  MOVF   x7D,W
27EC:  SUBWF  x7F,W
27EE:  MOVWF  00
27F0:  MOVF   x7E,W
27F2:  SUBWFB x80,W
27F4:  MOVWF  03
27F6:  MOVF   00,W
27F8:  XORLW  FF
27FA:  ADDLW  F8
27FC:  MOVWF  00
27FE:  MOVLW  1B
2800:  SUBFWB 03,F
2802:  MOVFF  00,01
2806:  MOVFF  03,02
280A:  BRA    2846
....................    } 
....................    else if ( WritePT.Val == ReadPT.Val ) 
280C:  BRA    2846
280E:  MOVF   x7D,W
2810:  SUBWF  x7F,W
2812:  BNZ   2826
2814:  MOVF   x7E,W
2816:  SUBWF  x80,W
2818:  BNZ   2826
....................    { 
....................       return RXSIZE - 1; 
281A:  MOVLW  F7
281C:  MOVWF  01
281E:  MOVLW  1B
2820:  MOVWF  02
2822:  BRA    2846
....................    } 
....................    else 
2824:  BRA    2846
....................     { 
....................       return ReadPT.Val - WritePT.Val - 1; 
2826:  MOVF   x7F,W
2828:  SUBWF  x7D,W
282A:  MOVWF  x81
282C:  MOVF   x80,W
282E:  SUBWFB x7E,W
2830:  MOVWF  x82
2832:  MOVLW  01
2834:  SUBWF  x81,W
2836:  MOVWF  00
2838:  MOVLW  00
283A:  SUBWFB x82,W
283C:  MOVWF  03
283E:  MOVFF  00,01
2842:  MOVWF  02
2844:  BRA    2846
....................    } 
.................... } 
2846:  MOVLB  0
2848:  GOTO   2AC0 (RETURN)
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           *remote: Location to store the Source MAC address of the 
....................  *                      received frame. 
....................  *               *type: Location of a BYTE to store the constant 
....................  *                     MAC_UNKNOWN, ETHER_IP, or ETHER_ARP, representing 
....................  *                     the contents of the Ethernet type field. 
....................  * 
....................  * Output:          TRUE: If a packet was waiting in the RX buffer.  The 
....................  *                    remote, and type values are updated. 
....................  *               FALSE: If a packet was not pending.  remote and type are 
....................  *                     not changed. 
....................  * 
....................  * Side Effects:    Last packet is discarded if MACDiscardRx() hasn't already 
....................  *               been called. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
.................... { 
....................    ENC_PREAMBLE header; 
....................  
....................    // Test if at least one packet has been received and is waiting 
....................    BankSel(EPKTCNT); 
*
133C:  MOVLW  01
133E:  MOVLB  3
1340:  MOVWF  xA0
1342:  MOVLW  19
1344:  MOVWF  x9F
1346:  MOVLB  0
1348:  CALL   09AA
....................    if(ReadETHReg((BYTE)EPKTCNT).Val == 0) 
134C:  MOVLW  19
134E:  MOVLB  3
1350:  MOVWF  x9C
1352:  MOVLB  0
1354:  CALL   0910
1358:  MOVF   01,F
135A:  BNZ   1362
....................       return FALSE; 
135C:  MOVLW  00
135E:  MOVWF  01
1360:  BRA    146E
....................  
....................    // Make absolutely certain that any previous packet was discarded 
....................    if(WasDiscarded == FALSE) 
1362:  BTFSC  57.0
1364:  BRA    136E
....................    { 
....................       MACDiscardRx(); 
1366:  RCALL  1256
....................       return FALSE; 
1368:  MOVLW  00
136A:  MOVWF  01
136C:  BRA    146E
....................    } 
....................  
....................    // Save the location of this packet 
....................    CurrentPacketLocation.Val = NextPacketLocation.Val; 
136E:  MOVFF  54,56
1372:  MOVFF  53,55
....................  
....................    // Set the SPI read pointer to the beginning of the next unprocessed packet 
....................    BankSel(ERDPTL); 
1376:  MOVLB  3
1378:  CLRF   xA0
137A:  CLRF   x9F
137C:  MOVLB  0
137E:  CALL   09AA
....................    WriteReg(ERDPTL, NextPacketLocation.v[0]); 
1382:  MOVLB  3
1384:  CLRF   xA2
1386:  MOVFF  53,3A3
138A:  MOVLB  0
138C:  CALL   0950
....................    WriteReg(ERDPTH, NextPacketLocation.v[1]); 
1390:  MOVLW  01
1392:  MOVLB  3
1394:  MOVWF  xA2
1396:  MOVFF  54,3A3
139A:  MOVLB  0
139C:  CALL   0950
....................  
....................    // Obtain the MAC header from the Ethernet buffer 
....................    MACGetArray((BYTE*)&header, sizeof(header)); 
13A0:  MOVLW  02
13A2:  MOVLB  3
13A4:  MOVWF  x0D
13A6:  MOVLW  F8
13A8:  MOVFF  30D,38C
13AC:  MOVWF  x8B
13AE:  CLRF   x8E
13B0:  MOVLW  14
13B2:  MOVWF  x8D
13B4:  MOVLB  0
13B6:  RCALL  12C2
....................  
....................    // The EtherType field, like most items transmitted on the Ethernet medium 
....................    // are in big endian. 
....................     header.Type.Val = swaps(header.Type.Val); 
13B8:  MOVFF  30B,39D
13BC:  MOVFF  30A,39C
13C0:  RCALL  1326
13C2:  MOVFF  02,30B
13C6:  MOVFF  01,30A
....................  
....................    // Validate the data returned from the ENC28J60.  Random data corruption, 
....................    // such as if a single SPI bit error occurs while communicating or a 
....................    // momentary power glitch could cause this to occur in rare circumstances. 
....................    if(header.NextPacketPointer > RXSTOP || ((BYTE_VAL*)(&header.NextPacketPointer))->bits.b0 || 
....................       header.StatusVector.bits.Zero || 
....................       header.StatusVector.bits.CRCError || 
....................       header.StatusVector.bits.ByteCount > 1518 || 
....................       !header.StatusVector.bits.ReceiveOk) 
13CA:  MOVLB  2
13CC:  MOVF   xF9,W
13CE:  SUBLW  1A
13D0:  BC    13DC
13D2:  XORLW  FF
13D4:  BNZ   1404
13D6:  MOVF   xF8,W
13D8:  SUBLW  F7
13DA:  BNC   1404
13DC:  MOVLW  02
13DE:  MOVWF  FEA
13E0:  MOVLW  F8
13E2:  MOVWF  FE9
13E4:  BTFSC  FEF.0
13E6:  BRA    1404
13E8:  BTFSC  xFD.7
13EA:  BRA    1404
13EC:  BTFSC  xFC.4
13EE:  BRA    1404
13F0:  MOVF   xFB,W
13F2:  SUBLW  04
13F4:  BC    1400
13F6:  XORLW  FF
13F8:  BNZ   1404
13FA:  MOVF   xFA,W
13FC:  SUBLW  EE
13FE:  BNC   1404
1400:  BTFSC  xFC.7
1402:  BRA    1406
....................    { 
....................       //Reset(); 
....................       reset_cpu(); 
1404:  RESET
....................    } 
....................  
....................    // Save the location where the hardware will write the next packet to 
....................    NextPacketLocation.Val = header.NextPacketPointer; 
1406:  MOVFF  2F9,54
140A:  MOVFF  2F8,53
....................  
....................    // Return the Ethernet frame's Source MAC address field to the caller 
....................    // This parameter is useful for replying to requests without requiring an 
....................    // ARP cycle. 
....................     memcpy((void*)remote->v, (void*)header.SourceMACAddr.v, sizeof(*remote)); 
140E:  MOVFF  2F4,30C
1412:  MOVFF  2F5,30D
1416:  MOVLB  3
1418:  MOVFF  2F5,FEA
141C:  MOVFF  2F4,FE9
1420:  MOVLW  03
1422:  MOVWF  FE2
1424:  MOVLW  04
1426:  MOVWF  FE1
1428:  MOVLW  06
142A:  MOVWF  01
142C:  MOVFF  FE6,FEE
1430:  DECFSZ 01,F
1432:  BRA    142C
....................  
....................    // Return a simplified version of the EtherType field to the caller 
....................     *type = MAC_UNKNOWN; 
1434:  MOVFF  2F7,03
1438:  MOVLB  2
143A:  MOVFF  2F6,FE9
143E:  MOVFF  03,FEA
1442:  MOVLW  FF
1444:  MOVWF  FEF
....................     if( (header.Type.v[1] == 0x08u) && 
....................        ((header.Type.v[0] == ETHER_IP) || (header.Type.v[0] == ETHER_ARP)) ) 
1446:  MOVLB  3
1448:  MOVF   x0B,W
144A:  SUBLW  08
144C:  BNZ   1468
144E:  MOVF   x0A,F
1450:  BZ    1458
1452:  MOVF   x0A,W
1454:  SUBLW  06
1456:  BNZ   1468
....................     { 
....................        *type = header.Type.v[0]; 
1458:  MOVLB  2
145A:  MOVFF  2F6,FE9
145E:  MOVFF  2F7,FEA
1462:  MOVFF  30A,FEF
1466:  MOVLB  3
....................     } 
....................  
....................     // Mark this packet as discardable 
....................     WasDiscarded = FALSE; 
1468:  BCF    57.0
....................    return TRUE; 
146A:  MOVLW  01
146C:  MOVWF  01
146E:  MOVLB  0
.................... } 
1470:  GOTO   7000 (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void    MACPutHeader(MAC_ADDR *remote, 
....................  *                                    BYTE type, 
....................  *                                   WORD dataLen) 
....................  * 
....................  * PreCondition:    MACIsTxReady() must return TRUE. 
....................  * 
....................  * Input:           *remote: Pointer to memory which contains the destination 
....................  *                       MAC address (6 bytes) 
....................  *               type: The constant ETHER_ARP or ETHER_IP, defining which 
....................  *                    value to write into the Ethernet header's type field. 
....................  *               dataLen: Length of the Ethernet data payload 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Because of the dataLen parameter, it is probably 
....................  *               advantagous to call this function immediately before 
....................  *               transmitting a packet rather than initially when the 
....................  *               packet is first created.  The order in which the packet 
....................  *               is constructed (header first or data first) is not 
....................  *               important. 
....................  *****************************************************************************/ 
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen) 
.................... { 
....................  
....................    BankSel(EWRPTL); 
*
173E:  MOVLB  3
1740:  CLRF   xA0
1742:  MOVLW  02
1744:  MOVWF  x9F
1746:  MOVLB  0
1748:  CALL   09AA
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    // Set the SPI write pointer to the beginning of the transmit buffer 
....................    WriteReg(EWRPTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
....................    WriteReg(EWRPTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
....................  
....................    // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TxBuffers[CurrentTxBuffer].StartAddress.Val; 
....................    TxBuffers[CurrentTxBuffer].EndAddress.Val = dataLen; 
.................... #else 
....................    // Set the SPI write pointer to the beginning of the transmit buffer 
....................    WriteReg(EWRPTL, LOW(TXSTART)); 
174C:  MOVLW  02
174E:  MOVLB  3
1750:  MOVWF  xA2
1752:  MOVLW  F8
1754:  MOVWF  xA3
1756:  MOVLB  0
1758:  CALL   0950
....................    WriteReg(EWRPTH, HIGH(TXSTART)); 
175C:  MOVLW  03
175E:  MOVLB  3
1760:  MOVWF  xA2
1762:  MOVLW  1B
1764:  MOVWF  xA3
1766:  MOVLB  0
1768:  CALL   0950
....................  
....................    // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TXSTART; 
176C:  MOVLW  06
176E:  MOVLB  3
1770:  ADDWF  x9D,F
1772:  MOVLW  1C
1774:  ADDWFC x9E,F
....................  
....................    // Write the TXND pointer into the registers, given the dataLen given 
....................    WriteReg(ETXNDL, ((WORD_VAL*)&dataLen)->v[0]); 
1776:  MOVLW  03
1778:  MOVWF  FEA
177A:  MOVLW  9D
177C:  MOVWF  FE9
177E:  MOVFF  FEF,3A1
1782:  MOVLW  06
1784:  MOVWF  xA2
1786:  MOVFF  3A1,3A3
178A:  MOVLB  0
178C:  CALL   0950
....................    WriteReg(ETXNDH, ((WORD_VAL*)&dataLen)->v[1]); 
1790:  MOVLW  03
1792:  MOVWF  FEA
1794:  MOVLW  9E
1796:  MOVWF  FE9
1798:  MOVFF  FEF,3A1
179C:  MOVLW  07
179E:  MOVLB  3
17A0:  MOVWF  xA2
17A2:  MOVFF  3A1,3A3
17A6:  MOVLB  0
17A8:  CALL   0950
.................... #endif 
....................  
....................  
....................    // Set the per-packet control byte and write the Ethernet destination 
....................    // address 
....................    MACPut(0x00);   // Use default control configuration 
17AC:  MOVLB  3
17AE:  CLRF   xA0
17B0:  MOVLB  0
17B2:  RCALL  16D2
....................     MACPutArray((BYTE*)remote, sizeof(*remote)); 
17B4:  MOVFF  39B,3A2
17B8:  MOVFF  39A,3A1
17BC:  MOVLB  3
17BE:  CLRF   xA4
17C0:  MOVLW  06
17C2:  MOVWF  xA3
17C4:  MOVLB  0
17C6:  RCALL  16F0
....................  
....................    // Write our MAC address in the Ethernet source field 
....................    MACPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr)); 
17C8:  MOVLB  3
17CA:  CLRF   xA0
17CC:  MOVLW  1B
17CE:  MOVFF  3A0,3A2
17D2:  MOVWF  xA1
17D4:  CLRF   xA4
17D6:  MOVLW  06
17D8:  MOVWF  xA3
17DA:  MOVLB  0
17DC:  RCALL  16F0
....................  
....................    // Write the appropriate Ethernet Type WORD for the protocol being used 
....................     MACPut(0x08); 
17DE:  MOVLW  08
17E0:  MOVLB  3
17E2:  MOVWF  xA0
17E4:  MOVLB  0
17E6:  RCALL  16D2
....................     MACPut((type == MAC_IP) ? ETHER_IP : ETHER_ARP); 
17E8:  MOVLB  3
17EA:  MOVF   x9C,F
17EC:  BNZ   17F2
17EE:  MOVLW  00
17F0:  BRA    17F4
17F2:  MOVLW  06
17F4:  MOVWF  xA0
17F6:  MOVLB  0
17F8:  RCALL  16D2
.................... } 
17FA:  RETLW  00
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACFlush(void) 
....................  * 
....................  * PreCondition:    A packet has been created by calling MACPut() and 
....................  *               MACPutHeader(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACFlush causes the current TX packet to be sent out on 
....................  *               the Ethernet medium.  The hardware MAC will take control 
....................  *               and handle CRC generation, collision retransmission and 
....................  *               other details. 
....................  * 
....................  * Note:         After transmission completes (MACIsTxReady() returns TRUE), 
....................  *               the packet can be modified and transmitted again by calling 
....................  *               MACFlush() again.  Until MACPutHeader() or MACPut() is 
....................  *               called (in the TX data area), the data in the TX buffer 
....................  *               will not be corrupted. 
....................  *****************************************************************************/ 
.................... void MACFlush(void) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    // Set the packet start and end address pointers 
....................    BankSel(ETXSTL); 
....................    WriteReg(ETXSTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
....................    WriteReg(ETXSTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
....................    WriteReg(ETXNDL, TxBuffers[CurrentTxBuffer].EndAddress.v[0]); 
....................    WriteReg(ETXNDH, TxBuffers[CurrentTxBuffer].EndAddress.v[1]); 
....................    LastTXedBuffer = CurrentTxBuffer; 
....................    TxBuffers[CurrentTxBuffer].Flags.bTransmitted = TRUE; 
.................... #endif 
....................  
....................    // Reset transmit logic if a TX Error has previously occured 
....................    // This is a silicon errata workaround 
....................    if(ReadETHReg(EIR).EIRbits.TXERIF) 
17FC:  MOVLW  1C
17FE:  MOVLB  3
1800:  MOVWF  x9C
1802:  MOVLB  0
1804:  CALL   0910
1808:  BTFSS  01.1
180A:  BRA    182C
....................    { 
....................       BFSReg(ECON1, ECON1_TXRST); 
180C:  MOVLW  1F
180E:  MOVLB  3
1810:  MOVWF  xA4
1812:  MOVLW  80
1814:  MOVWF  xA5
1816:  MOVLB  0
1818:  CALL   098C
....................       BFCReg(ECON1, ECON1_TXRST); 
181C:  MOVLW  1F
181E:  MOVLB  3
1820:  MOVWF  xA1
1822:  MOVLW  80
1824:  MOVWF  xA2
1826:  MOVLB  0
1828:  CALL   096E
....................    } 
....................    BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
182C:  MOVLW  1C
182E:  MOVLB  3
1830:  MOVWF  xA1
1832:  MOVLW  0A
1834:  MOVWF  xA2
1836:  MOVLB  0
1838:  CALL   096E
....................  
....................    // Start the transmission 
....................    // After transmission completes (MACIsTxReady() returns TRUE), the packet 
....................    // can be modified and transmitted again by calling MACFlush() again. 
....................    // Until MACPutHeader() is called, the data in the TX buffer will not be 
....................    // corrupted. 
....................    BFSReg(ECON1, ECON1_TXRTS); 
183C:  MOVLW  1F
183E:  MOVLB  3
1840:  MOVWF  xA4
1842:  MOVLW  08
1844:  MOVWF  xA5
1846:  MOVLB  0
1848:  CALL   098C
....................  
....................    // Revision B5 silicon errata workaround 
....................    if(ENCRevID == 0x05) 
184C:  MOVF   58,W
184E:  SUBLW  05
1850:  BTFSS  FD8.2
1852:  BRA    19EE
....................    { 
....................       while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
1854:  MOVLW  1C
1856:  MOVLB  3
1858:  MOVWF  x9C
185A:  MOVLB  0
185C:  CALL   0910
1860:  MOVF   01,W
1862:  ANDLW  0A
1864:  BZ    1854
....................       if(ReadETHReg(EIR).EIRbits.TXERIF) 
1866:  MOVLW  1C
1868:  MOVLB  3
186A:  MOVWF  x9C
186C:  MOVLB  0
186E:  CALL   0910
1872:  BTFSS  01.1
1874:  BRA    19EE
....................       { 
....................          WORD_VAL ReadPtrSave; 
....................          WORD_VAL TXEnd; 
....................          TXSTATUS TXStatus; 
....................          BYTE i; 
....................  
....................          // Cancel the previous transmission if it has become stuck set 
....................          BFCReg(ECON1, ECON1_TXRTS); 
1876:  MOVLW  1F
1878:  MOVLB  3
187A:  MOVWF  xA1
187C:  MOVLW  08
187E:  MOVWF  xA2
1880:  MOVLB  0
1882:  CALL   096E
....................  
....................          // Save the current read pointer (controlled by application) 
....................          BankSel(ERDPTL); 
1886:  MOVLB  3
1888:  CLRF   xA0
188A:  CLRF   x9F
188C:  MOVLB  0
188E:  CALL   09AA
....................          ReadPtrSave.v[0] = ReadETHReg(ERDPTL).Val; 
1892:  MOVLB  3
1894:  CLRF   x9C
1896:  MOVLB  0
1898:  CALL   0910
189C:  MOVFF  01,37D
....................          ReadPtrSave.v[1] = ReadETHReg(ERDPTH).Val; 
18A0:  MOVLW  01
18A2:  MOVLB  3
18A4:  MOVWF  x9C
18A6:  MOVLB  0
18A8:  CALL   0910
18AC:  MOVFF  01,37E
....................  
....................          // Get the location of the transmit status vector 
....................          TXEnd.v[0] = ReadETHReg(ETXNDL).Val; 
18B0:  MOVLW  06
18B2:  MOVLB  3
18B4:  MOVWF  x9C
18B6:  MOVLB  0
18B8:  CALL   0910
18BC:  MOVFF  01,37F
....................          TXEnd.v[1] = ReadETHReg(ETXNDH).Val; 
18C0:  MOVLW  07
18C2:  MOVLB  3
18C4:  MOVWF  x9C
18C6:  MOVLB  0
18C8:  CALL   0910
18CC:  MOVFF  01,380
....................          TXEnd.Val++; 
18D0:  MOVLB  3
18D2:  INCF   x7F,F
18D4:  BTFSC  FD8.2
18D6:  INCF   x80,F
....................  
....................          // Read the transmit status vector 
....................          WriteReg(ERDPTL, TXEnd.v[0]); 
18D8:  CLRF   xA2
18DA:  MOVFF  37F,3A3
18DE:  MOVLB  0
18E0:  CALL   0950
....................          WriteReg(ERDPTH, TXEnd.v[1]); 
18E4:  MOVLW  01
18E6:  MOVLB  3
18E8:  MOVWF  xA2
18EA:  MOVFF  380,3A3
18EE:  MOVLB  0
18F0:  CALL   0950
....................          MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
18F4:  MOVLW  03
18F6:  MOVLB  3
18F8:  MOVWF  x8A
18FA:  MOVLW  81
18FC:  MOVFF  38A,38C
1900:  MOVWF  x8B
1902:  CLRF   x8E
1904:  MOVLW  07
1906:  MOVWF  x8D
1908:  MOVLB  0
190A:  RCALL  12C2
....................  
....................          // Implement retransmission if a late collision occured (this can 
....................          // happen on B5 when certain link pulses arrive at the same time 
....................          // as the transmission) 
....................          for(i = 0; i < 16; i++) 
190C:  MOVLB  3
190E:  CLRF   x88
1910:  MOVF   x88,W
1912:  SUBLW  0F
1914:  BNC   19D2
....................          { 
....................             if(ReadETHReg(EIR).EIRbits.TXERIF && TXStatus.bits.LateCollision) 
1916:  MOVLW  1C
1918:  MOVWF  x9C
191A:  MOVLB  0
191C:  CALL   0910
1920:  BTFSS  01.1
1922:  BRA    19C6
1924:  MOVLB  3
1926:  BTFSC  x84.5
1928:  BRA    192E
192A:  MOVLB  0
192C:  BRA    19C6
....................             { 
....................                // Reset the TX logic 
....................                BFSReg(ECON1, ECON1_TXRST); 
192E:  MOVLW  1F
1930:  MOVWF  xA4
1932:  MOVLW  80
1934:  MOVWF  xA5
1936:  MOVLB  0
1938:  CALL   098C
....................                BFCReg(ECON1, ECON1_TXRST); 
193C:  MOVLW  1F
193E:  MOVLB  3
1940:  MOVWF  xA1
1942:  MOVLW  80
1944:  MOVWF  xA2
1946:  MOVLB  0
1948:  CALL   096E
....................                BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
194C:  MOVLW  1C
194E:  MOVLB  3
1950:  MOVWF  xA1
1952:  MOVLW  0A
1954:  MOVWF  xA2
1956:  MOVLB  0
1958:  CALL   096E
....................  
....................                // Transmit the packet again 
....................                BFSReg(ECON1, ECON1_TXRTS); 
195C:  MOVLW  1F
195E:  MOVLB  3
1960:  MOVWF  xA4
1962:  MOVLW  08
1964:  MOVWF  xA5
1966:  MOVLB  0
1968:  CALL   098C
....................                while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
196C:  MOVLW  1C
196E:  MOVLB  3
1970:  MOVWF  x9C
1972:  MOVLB  0
1974:  CALL   0910
1978:  MOVF   01,W
197A:  ANDLW  0A
197C:  BZ    196C
....................  
....................                // Cancel the previous transmission if it has become stuck set 
....................                BFCReg(ECON1, ECON1_TXRTS); 
197E:  MOVLW  1F
1980:  MOVLB  3
1982:  MOVWF  xA1
1984:  MOVLW  08
1986:  MOVWF  xA2
1988:  MOVLB  0
198A:  CALL   096E
....................  
....................                // Read transmit status vector 
....................                WriteReg(ERDPTL, TXEnd.v[0]); 
198E:  MOVLB  3
1990:  CLRF   xA2
1992:  MOVFF  37F,3A3
1996:  MOVLB  0
1998:  CALL   0950
....................                WriteReg(ERDPTH, TXEnd.v[1]); 
199C:  MOVLW  01
199E:  MOVLB  3
19A0:  MOVWF  xA2
19A2:  MOVFF  380,3A3
19A6:  MOVLB  0
19A8:  CALL   0950
....................                MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
19AC:  MOVLW  03
19AE:  MOVLB  3
19B0:  MOVWF  x8A
19B2:  MOVLW  81
19B4:  MOVFF  38A,38C
19B8:  MOVWF  x8B
19BA:  CLRF   x8E
19BC:  MOVLW  07
19BE:  MOVWF  x8D
19C0:  MOVLB  0
19C2:  RCALL  12C2
....................             } 
....................             else 
19C4:  BRA    19CC
....................             { 
....................                break; 
19C6:  MOVLB  3
19C8:  BRA    19D2
19CA:  MOVLB  0
....................             } 
....................          } 
19CC:  MOVLB  3
19CE:  INCF   x88,F
19D0:  BRA    1910
....................  
....................          // Restore the current read pointer 
....................          WriteReg(ERDPTL, ReadPtrSave.v[0]); 
19D2:  CLRF   xA2
19D4:  MOVFF  37D,3A3
19D8:  MOVLB  0
19DA:  CALL   0950
....................          WriteReg(ERDPTH, ReadPtrSave.v[1]); 
19DE:  MOVLW  01
19E0:  MOVLB  3
19E2:  MOVWF  xA2
19E4:  MOVFF  37E,3A3
19E8:  MOVLB  0
19EA:  CALL   0950
....................       } 
....................    } 
.................... } 
19EE:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetRxBuffer(WORD offset) 
....................  * 
....................  * PreCondition:    A packet has been obtained by calling MACGetHeader() and 
....................  *               getting a TRUE result. 
....................  * 
....................  * Input:           offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                     header's type field to relocate the SPI read and 
....................  *                     write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *               and various other functions will use these new values. 
....................  * 
....................  * Note:         RXSTOP must be statically defined as being > RXSTART for 
....................  *               this function to work correctly.  In other words, do not 
....................  *               define an RX buffer which spans the 0x1FFF->0x0000 memory 
....................  *               boundary. 
....................  *****************************************************************************/ 
.................... void MACSetRxBuffer(WORD offset) 
.................... { 
....................    WORD_VAL ReadPT; 
....................  
....................    // Determine the address of the beginning of the entire packet 
....................    // and adjust the address to the desired location 
....................    ReadPT.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
1D1A:  MOVLW  14
1D1C:  ADDWF  55,W
1D1E:  MOVLB  3
1D20:  MOVWF  x29
1D22:  MOVLW  00
1D24:  ADDWFC 56,W
1D26:  MOVWF  x2A
1D28:  MOVF   x25,W
1D2A:  ADDWF  x29,W
1D2C:  MOVWF  x27
1D2E:  MOVF   x26,W
1D30:  ADDWFC x2A,W
1D32:  MOVWF  x28
....................  
....................    // Since the receive buffer is circular, adjust if a wraparound is needed 
....................    if ( ReadPT.Val > RXSTOP ) 
1D34:  MOVF   x28,W
1D36:  SUBLW  1A
1D38:  BC    1D4C
1D3A:  XORLW  FF
1D3C:  BNZ   1D44
1D3E:  MOVF   x27,W
1D40:  SUBLW  F7
1D42:  BC    1D4C
....................       ReadPT.Val -= RXSIZE; 
1D44:  MOVLW  F8
1D46:  SUBWF  x27,F
1D48:  MOVLW  1B
1D4A:  SUBWFB x28,F
....................  
....................    // Set the SPI read and write pointers to the new calculated value 
....................    BankSel(ERDPTL); 
1D4C:  CLRF   xA0
1D4E:  CLRF   x9F
1D50:  MOVLB  0
1D52:  CALL   09AA
....................    WriteReg(ERDPTL, ReadPT.v[0]); 
1D56:  MOVLB  3
1D58:  CLRF   xA2
1D5A:  MOVFF  327,3A3
1D5E:  MOVLB  0
1D60:  CALL   0950
....................    WriteReg(ERDPTH, ReadPT.v[1]); 
1D64:  MOVLW  01
1D66:  MOVLB  3
1D68:  MOVWF  xA2
1D6A:  MOVFF  328,3A3
1D6E:  MOVLB  0
1D70:  CALL   0950
....................    WriteReg(EWRPTL, ReadPT.v[0]); 
1D74:  MOVLW  02
1D76:  MOVLB  3
1D78:  MOVWF  xA2
1D7A:  MOVFF  327,3A3
1D7E:  MOVLB  0
1D80:  CALL   0950
....................    WriteReg(EWRPTH, ReadPT.v[1]); 
1D84:  MOVLW  03
1D86:  MOVLB  3
1D88:  MOVWF  xA2
1D8A:  MOVFF  328,3A3
1D8E:  MOVLB  0
1D90:  CALL   0950
.................... } 
1D94:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetTxBuffer(BUFFER buffer, WORD offset) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           buffer: BYTE specifying which transmit buffer to seek 
....................  *                     within.  If MAC_TX_BUFFER_COUNT <= 1, this 
....................  *                     parameter is not used. 
....................  *               offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                     header's type field to relocate the SPI read and 
....................  *                     write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *               and various other functions will use these new values. 
....................  * 
....................  * Note:         None 
....................  *****************************************************************************/ 
.................... void MACSetTxBuffer(BUFFER buffer, WORD offset) 
.................... { 
....................     CurrentTxBuffer = buffer; 
*
1648:  MOVFF  396,4E
....................  
....................    // Calculate the proper address.  Since the TX memory area is not circular, 
....................    // no wrapparound checks are necessary. +1 adjustment is needed because of 
....................    // the per packet control byte which preceeds the packet in the TX memory 
....................    // area. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    offset += TxBuffers[buffer].StartAddress.Val + 1 + sizeof(ETHER_HEADER); 
.................... #else 
....................    offset += TXSTART + 1 + sizeof(ETHER_HEADER); 
164C:  MOVLW  07
164E:  MOVLB  3
1650:  ADDWF  x97,F
1652:  MOVLW  1C
1654:  ADDWFC x98,F
.................... #endif 
....................  
....................    // Set the SPI read and write pointers to the new calculated value 
....................    BankSel(EWRPTL); 
1656:  CLRF   xA0
1658:  MOVLW  02
165A:  MOVWF  x9F
165C:  MOVLB  0
165E:  CALL   09AA
....................    WriteReg(ERDPTL, ((WORD_VAL*)&offset)->v[0]); 
1662:  MOVLW  03
1664:  MOVWF  FEA
1666:  MOVLW  97
1668:  MOVWF  FE9
166A:  MOVFF  FEF,39B
166E:  MOVLB  3
1670:  CLRF   xA2
1672:  MOVFF  39B,3A3
1676:  MOVLB  0
1678:  CALL   0950
....................    WriteReg(ERDPTH, ((WORD_VAL*)&offset)->v[1]); 
167C:  MOVLW  03
167E:  MOVWF  FEA
1680:  MOVLW  98
1682:  MOVWF  FE9
1684:  MOVFF  FEF,39B
1688:  MOVLW  01
168A:  MOVLB  3
168C:  MOVWF  xA2
168E:  MOVFF  39B,3A3
1692:  MOVLB  0
1694:  CALL   0950
....................    WriteReg(EWRPTL, ((WORD_VAL*)&offset)->v[0]); 
1698:  MOVLW  03
169A:  MOVWF  FEA
169C:  MOVLW  97
169E:  MOVWF  FE9
16A0:  MOVFF  FEF,39B
16A4:  MOVLW  02
16A6:  MOVLB  3
16A8:  MOVWF  xA2
16AA:  MOVFF  39B,3A3
16AE:  MOVLB  0
16B0:  CALL   0950
....................    WriteReg(EWRPTH, ((WORD_VAL*)&offset)->v[1]); 
16B4:  MOVLW  03
16B6:  MOVWF  FEA
16B8:  MOVLW  98
16BA:  MOVWF  FE9
16BC:  MOVFF  FEF,39B
16C0:  MOVLW  03
16C2:  MOVLB  3
16C4:  MOVWF  xA2
16C6:  MOVFF  39B,3A3
16CA:  MOVLB  0
16CC:  CALL   0950
.................... } 
16D0:  RETLW  00
....................  
....................  
.................... #if defined(MCHP_MAC) 
.................... // MACCalcRxChecksum() and MACCalcTxChecksum() use the DMA module to calculate 
.................... // checksums.  These two functions have been tested. 
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcRxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset   - Number of bytes beyond the beginning of the 
....................  *                     Ethernet data (first byte after the type field) 
....................  *                     where the checksum should begin 
....................  *               len      - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcRxChecksum(WORD offset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Add the offset requested by firmware plus the Ethernet header 
....................    temp.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
1C22:  MOVLW  14
1C24:  ADDWF  55,W
1C26:  MOVLB  3
1C28:  MOVWF  x53
1C2A:  MOVLW  00
1C2C:  ADDWFC 56,W
1C2E:  MOVWF  x54
1C30:  MOVF   x4D,W
1C32:  ADDWF  x53,W
1C34:  MOVWF  x51
1C36:  MOVF   x4E,W
1C38:  ADDWFC x54,W
1C3A:  MOVWF  x52
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
1C3C:  MOVF   x52,W
1C3E:  SUBLW  1A
1C40:  BC    1C54
1C42:  XORLW  FF
1C44:  BNZ   1C4C
1C46:  MOVF   x51,W
1C48:  SUBLW  F7
1C4A:  BC    1C54
....................    { 
....................       temp.Val -= RXSIZE; 
1C4C:  MOVLW  F8
1C4E:  SUBWF  x51,F
1C50:  MOVLW  1B
1C52:  SUBWFB x52,F
....................    } 
....................  
....................    // Program the start address of the DMA 
....................    BankSel(EDMASTL); 
1C54:  CLRF   xA0
1C56:  MOVLW  10
1C58:  MOVWF  x9F
1C5A:  MOVLB  0
1C5C:  CALL   09AA
....................    WriteReg(EDMASTL, temp.v[0]); 
1C60:  MOVLW  10
1C62:  MOVLB  3
1C64:  MOVWF  xA2
1C66:  MOVFF  351,3A3
1C6A:  MOVLB  0
1C6C:  CALL   0950
....................    WriteReg(EDMASTH, temp.v[1]); 
1C70:  MOVLW  11
1C72:  MOVLB  3
1C74:  MOVWF  xA2
1C76:  MOVFF  352,3A3
1C7A:  MOVLB  0
1C7C:  CALL   0950
....................  
....................    // Calculate the end address, given the start address and len 
....................    temp.Val += len-1; 
1C80:  MOVLW  01
1C82:  MOVLB  3
1C84:  SUBWF  x4F,W
1C86:  MOVWF  00
1C88:  MOVLW  00
1C8A:  SUBWFB x50,W
1C8C:  MOVWF  03
1C8E:  MOVF   00,W
1C90:  ADDWF  x51,F
1C92:  MOVF   03,W
1C94:  ADDWFC x52,F
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
1C96:  MOVF   x52,W
1C98:  SUBLW  1A
1C9A:  BC    1CAE
1C9C:  XORLW  FF
1C9E:  BNZ   1CA6
1CA0:  MOVF   x51,W
1CA2:  SUBLW  F7
1CA4:  BC    1CAE
....................    { 
....................       temp.Val -= RXSIZE; 
1CA6:  MOVLW  F8
1CA8:  SUBWF  x51,F
1CAA:  MOVLW  1B
1CAC:  SUBWFB x52,F
....................    } 
....................  
....................    // Program the end address of the DMA 
....................    WriteReg(EDMANDL, temp.v[0]); 
1CAE:  MOVLW  12
1CB0:  MOVWF  xA2
1CB2:  MOVFF  351,3A3
1CB6:  MOVLB  0
1CB8:  CALL   0950
....................    WriteReg(EDMANDH, temp.v[1]); 
1CBC:  MOVLW  13
1CBE:  MOVLB  3
1CC0:  MOVWF  xA2
1CC2:  MOVFF  352,3A3
1CC6:  MOVLB  0
1CC8:  CALL   0950
....................  
....................    // Do the checksum calculation 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
1CCC:  MOVLW  1F
1CCE:  MOVLB  3
1CD0:  MOVWF  xA4
1CD2:  MOVLW  30
1CD4:  MOVWF  xA5
1CD6:  MOVLB  0
1CD8:  CALL   098C
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
1CDC:  MOVLW  1F
1CDE:  MOVLB  3
1CE0:  MOVWF  x9C
1CE2:  MOVLB  0
1CE4:  CALL   0910
1CE8:  BTFSC  01.5
1CEA:  BRA    1CDC
....................  
....................    // Swap endianness and return 
....................    temp.v[1] = ReadETHReg(EDMACSL).Val; 
1CEC:  MOVLW  16
1CEE:  MOVLB  3
1CF0:  MOVWF  x9C
1CF2:  MOVLB  0
1CF4:  CALL   0910
1CF8:  MOVFF  01,352
....................    temp.v[0] = ReadETHReg(EDMACSH).Val; 
1CFC:  MOVLW  17
1CFE:  MOVLB  3
1D00:  MOVWF  x9C
1D02:  MOVLB  0
1D04:  CALL   0910
1D08:  MOVFF  01,351
....................    return temp.Val; 
1D0C:  MOVLB  3
1D0E:  MOVFF  351,01
1D12:  MOVFF  352,02
.................... } 
1D16:  MOVLB  0
1D18:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcTxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset   - Number of bytes beyond the beginning of the 
....................  *                     Ethernet data (first byte after the type field) 
....................  *                     where the checksum should begin 
....................  *               len      - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcTxChecksum(WORD offset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Program the start address of the DMA, after adjusting for the Ethernet 
....................    // header 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    temp.Val = TxBuffers[CurrentTxBuffer].StartAddress.Val + sizeof(ETHER_HEADER) 
....................             + offset + 1;   // +1 needed to account for per packet control byte 
.................... #else 
....................    temp.Val = TXSTART + sizeof(ETHER_HEADER) 
....................             + offset + 1;   // +1 needed to account for per packet control byte 
*
284C:  MOVLW  06
284E:  MOVLB  3
2850:  ADDWF  x96,W
2852:  MOVWF  x9C
2854:  MOVLW  1C
2856:  ADDWFC x97,W
2858:  MOVWF  x9D
285A:  MOVLW  01
285C:  ADDWF  x9C,W
285E:  MOVWF  x9A
2860:  MOVLW  00
2862:  ADDWFC x9D,W
2864:  MOVWF  x9B
.................... #endif 
....................    BankSel(EDMASTL); 
2866:  CLRF   xA0
2868:  MOVLW  10
286A:  MOVWF  x9F
286C:  MOVLB  0
286E:  CALL   09AA
....................    WriteReg(EDMASTL, temp.v[0]); 
2872:  MOVLW  10
2874:  MOVLB  3
2876:  MOVWF  xA2
2878:  MOVFF  39A,3A3
287C:  MOVLB  0
287E:  CALL   0950
....................    WriteReg(EDMASTH, temp.v[1]); 
2882:  MOVLW  11
2884:  MOVLB  3
2886:  MOVWF  xA2
2888:  MOVFF  39B,3A3
288C:  MOVLB  0
288E:  CALL   0950
....................  
....................    // Program the end address of the DMA. 
....................    temp.Val += len-1; 
2892:  MOVLW  01
2894:  MOVLB  3
2896:  SUBWF  x98,W
2898:  MOVWF  00
289A:  MOVLW  00
289C:  SUBWFB x99,W
289E:  MOVWF  03
28A0:  MOVF   00,W
28A2:  ADDWF  x9A,F
28A4:  MOVF   03,W
28A6:  ADDWFC x9B,F
....................    WriteReg(EDMANDL, temp.v[0]); 
28A8:  MOVLW  12
28AA:  MOVWF  xA2
28AC:  MOVFF  39A,3A3
28B0:  MOVLB  0
28B2:  CALL   0950
....................    WriteReg(EDMANDH, temp.v[1]); 
28B6:  MOVLW  13
28B8:  MOVLB  3
28BA:  MOVWF  xA2
28BC:  MOVFF  39B,3A3
28C0:  MOVLB  0
28C2:  CALL   0950
....................  
....................    // Do the checksum calculation 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
28C6:  MOVLW  1F
28C8:  MOVLB  3
28CA:  MOVWF  xA4
28CC:  MOVLW  30
28CE:  MOVWF  xA5
28D0:  MOVLB  0
28D2:  CALL   098C
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
28D6:  MOVLW  1F
28D8:  MOVLB  3
28DA:  MOVWF  x9C
28DC:  MOVLB  0
28DE:  CALL   0910
28E2:  BTFSC  01.5
28E4:  BRA    28D6
....................  
....................    // Swap endianness and return 
....................    temp.v[1] = ReadETHReg(EDMACSL).Val; 
28E6:  MOVLW  16
28E8:  MOVLB  3
28EA:  MOVWF  x9C
28EC:  MOVLB  0
28EE:  CALL   0910
28F2:  MOVFF  01,39B
....................    temp.v[0] = ReadETHReg(EDMACSH).Val; 
28F6:  MOVLW  17
28F8:  MOVLB  3
28FA:  MOVWF  x9C
28FC:  MOVLB  0
28FE:  CALL   0910
2902:  MOVFF  01,39A
....................    return temp.Val; 
2906:  MOVLB  3
2908:  MOVFF  39A,01
290C:  MOVFF  39B,02
.................... } 
2910:  MOVLB  0
2912:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    Read buffer pointer set to starting of checksum data 
....................  * 
....................  * Input:           len: Total number of bytes to calculate the checksum over. 
....................  *                   The first byte included in the checksum is the byte 
....................  *                   pointed to by ERDPT, which is updated by calls to 
....................  *                   MACGet(), MACSetRxBuffer(), MACSetTxBuffer(), etc. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself.  The ENC28J60 has a hardware DMA module 
....................  *               which can calculate the checksum faster than software, so 
....................  *               this function replaces the CaclIPBufferChecksum() function 
....................  *               defined in the helpers.c file.  Through the use of 
....................  *               preprocessor defines, this replacement is automatic. 
....................  * 
....................  * Note:            This function works either in the RX buffer area or the TX 
....................  *               buffer area.  No validation is done on the len parameter. 
....................  *****************************************************************************/ 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Take care of special cases which the DMA cannot be used for 
....................    if(len == 0u) 
*
2078:  MOVLB  3
207A:  MOVF   x7D,F
207C:  BNZ   208C
207E:  MOVF   x7E,F
2080:  BNZ   208C
....................    { 
....................       return 0xFFFF; 
2082:  MOVLW  FF
2084:  MOVWF  01
2086:  MOVWF  02
2088:  BRA    21BC
....................    } 
....................    else if(len == 1u) 
208A:  BRA    20BA
208C:  DECFSZ x7D,W
208E:  BRA    20BA
2090:  MOVF   x7E,F
2092:  BNZ   20BA
....................    { 
....................       return ~(((WORD)MACGet())<<8); 
2094:  MOVLB  0
2096:  RCALL  204C
2098:  MOVLB  3
209A:  CLRF   x82
209C:  MOVFF  01,381
20A0:  MOVFF  01,03
20A4:  MOVLW  00
20A6:  CLRF   00
20A8:  DECF   00,F
20AA:  XORWF  00,F
20AC:  MOVLW  FF
20AE:  XORWF  03,F
20B0:  MOVFF  00,01
20B4:  MOVFF  03,02
20B8:  BRA    21BC
....................    } 
....................  
....................  
....................    // Set the DMA starting address to the SPI read pointer value 
....................    BankSel(ERDPTL); 
20BA:  CLRF   xA0
20BC:  CLRF   x9F
20BE:  MOVLB  0
20C0:  CALL   09AA
....................    temp.v[0] = ReadETHReg(ERDPTL).Val; 
20C4:  MOVLB  3
20C6:  CLRF   x9C
20C8:  MOVLB  0
20CA:  CALL   0910
20CE:  MOVFF  01,37F
....................    temp.v[1] = ReadETHReg(ERDPTH).Val; 
20D2:  MOVLW  01
20D4:  MOVLB  3
20D6:  MOVWF  x9C
20D8:  MOVLB  0
20DA:  CALL   0910
20DE:  MOVFF  01,380
....................    WriteReg(EDMASTL, temp.v[0]); 
20E2:  MOVLW  10
20E4:  MOVLB  3
20E6:  MOVWF  xA2
20E8:  MOVFF  37F,3A3
20EC:  MOVLB  0
20EE:  CALL   0950
....................    WriteReg(EDMASTH, temp.v[1]); 
20F2:  MOVLW  11
20F4:  MOVLB  3
20F6:  MOVWF  xA2
20F8:  MOVFF  380,3A3
20FC:  MOVLB  0
20FE:  CALL   0950
....................  
....................    // See if we are calculating a checksum within the RX buffer (where 
....................    // wrapping rules apply) or TX/unused area (where wrapping rules are 
....................    // not applied) 
.................... #if RXSTART == 0 
....................    if(temp.Val <= RXSTOP) 
2102:  MOVLB  3
2104:  MOVF   x80,W
2106:  SUBLW  1B
2108:  BNC   2140
210A:  BNZ   2112
210C:  MOVF   x7F,W
210E:  SUBLW  F7
2110:  BNC   2140
.................... #else 
....................    if(temp.Val >= RXSTART && temp.Val <= RXSTOP) 
.................... #endif 
....................    { 
....................       // Calculate the DMA ending address given the starting address and len 
....................       // parameter.  The DMA will follow the receive buffer wrapping boundary. 
....................       temp.Val += len-1; 
2112:  MOVLW  01
2114:  SUBWF  x7D,W
2116:  MOVWF  00
2118:  MOVLW  00
211A:  SUBWFB x7E,W
211C:  MOVWF  03
211E:  MOVF   00,W
2120:  ADDWF  x7F,F
2122:  MOVF   03,W
2124:  ADDWFC x80,F
....................       if(temp.Val > RXSTOP) 
2126:  MOVF   x80,W
2128:  SUBLW  1A
212A:  BC    213E
212C:  XORLW  FF
212E:  BNZ   2136
2130:  MOVF   x7F,W
2132:  SUBLW  F7
2134:  BC    213E
....................       { 
....................          temp.Val -= RXSIZE; 
2136:  MOVLW  F8
2138:  SUBWF  x7F,F
213A:  MOVLW  1B
213C:  SUBWFB x80,F
....................       } 
....................    } 
....................    else 
213E:  BRA    2154
....................    { 
....................       temp.Val += len-1; 
2140:  MOVLW  01
2142:  SUBWF  x7D,W
2144:  MOVWF  00
2146:  MOVLW  00
2148:  SUBWFB x7E,W
214A:  MOVWF  03
214C:  MOVF   00,W
214E:  ADDWF  x7F,F
2150:  MOVF   03,W
2152:  ADDWFC x80,F
....................    } 
....................  
....................    // Write the DMA end address 
....................    WriteReg(EDMANDL, temp.v[0]); 
2154:  MOVLW  12
2156:  MOVWF  xA2
2158:  MOVFF  37F,3A3
215C:  MOVLB  0
215E:  CALL   0950
....................    WriteReg(EDMANDH, temp.v[1]); 
2162:  MOVLW  13
2164:  MOVLB  3
2166:  MOVWF  xA2
2168:  MOVFF  380,3A3
216C:  MOVLB  0
216E:  CALL   0950
....................  
....................    // Begin the DMA checksum calculation and wait until it is finished 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
2172:  MOVLW  1F
2174:  MOVLB  3
2176:  MOVWF  xA4
2178:  MOVLW  30
217A:  MOVWF  xA5
217C:  MOVLB  0
217E:  CALL   098C
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
2182:  MOVLW  1F
2184:  MOVLB  3
2186:  MOVWF  x9C
2188:  MOVLB  0
218A:  CALL   0910
218E:  BTFSC  01.5
2190:  BRA    2182
....................  
....................    // Return the resulting good stuff 
....................    temp.v[0] = ReadETHReg(EDMACSL).Val; 
2192:  MOVLW  16
2194:  MOVLB  3
2196:  MOVWF  x9C
2198:  MOVLB  0
219A:  CALL   0910
219E:  MOVFF  01,37F
....................    temp.v[1] = ReadETHReg(EDMACSH).Val; 
21A2:  MOVLW  17
21A4:  MOVLB  3
21A6:  MOVWF  x9C
21A8:  MOVLB  0
21AA:  CALL   0910
21AE:  MOVFF  01,380
....................    return temp.Val; 
21B2:  MOVLB  3
21B4:  MOVFF  37F,01
21B8:  MOVFF  380,02
.................... } 
21BC:  MOVLB  0
21BE:  RETLW  00
.................... #endif   // End of MCHP_MAC specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           RxOffset: Offset in the RX buffer (0=first byte of 
....................  *                        destination MAC address) to copy from. 
....................  *               TxOffset: Offset in the TX buffer (0=first byte of 
....................  *                       destination MAC address) to copy to. 
....................  *               len:     Number of bytes to copy 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        If the TX logic is transmitting a packet (ECON1.TXRTS is 
....................  *               set), the hardware will wait until it is finished.  Then, 
....................  *               the DMA module will copy the data from the receive buffer 
....................  *               to the transmit buffer. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... // Remove this line if your application needs to use this 
.................... // function.  This code has NOT been tested. 
.................... #if 0 
.................... void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    temp.Val = CurrentPacketLocation.Val + RxOffset + sizeof(ENC_PREAMBLE); 
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
....................       temp.Val -= RXSIZE; 
....................  
....................    BankSel(EDMASTL); 
....................    WriteReg(EDMASTL, temp.v[0]); 
....................    WriteReg(EDMASTH, temp.v[1]); 
....................  
....................    temp.Val += len-1; 
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
....................       temp.Val -= RXSIZE; 
....................  
....................    WriteReg(EDMANDL, temp.v[0]); 
....................    WriteReg(EDMANDH, temp.v[1]); 
....................  
....................    TxOffset += TXSTART+1; 
....................    WriteReg(EDMADSTL, ((WORD_VAL*)&TxOffset)->v[0]); 
....................    WriteReg(EDMADSTH, ((WORD_VAL*)&TxOffset)->v[1]); 
....................  
....................    // Do the DMA Copy.  The DMA module will wait for TXRTS to become clear 
....................    // before starting the copy. 
....................    BFCReg(ECON1, ECON1_CSUMEN); 
....................    BFSReg(ECON1, ECON1_DMAST); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
.................... } 
.................... #endif 
....................  
....................  
.................... #if defined(MAC_FILTER_BROADCASTS) 
.................... // NOTE: This code has NOT been tested.  See StackTsk.h's explanation 
.................... // of MAC_FILTER_BROADCASTS. 
.................... /****************************************************************************** 
....................  * Function:        void MACSetPMFilter(BYTE *Pattern, 
....................  *                              BYTE *PatternMask, 
....................  *                              WORD PatternOffset) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                MACIsTxReady() must return TRUE 
....................  * 
....................  * Input:           *Pattern: Pointer to an intial pattern to compare against 
....................  *               *PatternMask: Pointer to an 8 byte pattern mask which 
....................  *                          defines which bytes of the pattern are 
....................  *                          important.  At least one bit must be set. 
....................  *               PatternOffset: Offset from the beginning of the Ethernet 
....................  *                           frame (1st byte of destination address), to 
....................  *                           begin comparing with the given pattern. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Contents of the TX buffer space are overwritten 
....................  * 
....................  * Overview:        MACSetPMFilter sets the hardware receive filters for: 
....................  *               CRC AND (Unicast OR Pattern Match).  As a result, only a 
....................  *               subset of the broadcast packets which are normally 
....................  *               received will be received. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACSetPMFilter(BYTE *Pattern, 
....................                BYTE *PatternMask, 
....................                WORD PatternOffset) 
.................... { 
....................    WORD_VAL i; 
....................    BYTE *MaskPtr; 
....................    BYTE UnmaskedPatternLen; 
....................  
....................    // Set the SPI write pointer and DMA startting address to the beginning of 
....................    // the transmit buffer 
....................    BankSel(EWRPTL); 
....................    WriteReg(EWRPTL, LOW(TXSTART)); 
....................    WriteReg(EWRPTH, HIGH(TXSTART)); 
....................    WriteReg(EDMASTL, LOW(TXSTART)); 
....................    WriteReg(EDMASTH, HIGH(TXSTART)); 
....................  
....................    // Fill the transmit buffer with the pattern to match against.  Only the 
....................    // bytes which have a mask bit of 1 are written into the buffer and will 
....................    // subsequently be used for checksum computation. 
....................    MaskPtr = PatternMask; 
....................    for(i.Val = 0x0100; i.v[0] < 64; i.v[0]++) 
....................    { 
....................       if( *MaskPtr & i.v[1] ) 
....................       { 
....................          MACPut(*Pattern); 
....................          UnmaskedPatternLen++; 
....................       } 
....................       Pattern++; 
....................  
....................       i.v[1] <<= 1; 
....................       if( i.v[1] == 0u ) 
....................       { 
....................          i.v[1] = 0x01; 
....................          MaskPtr++; 
....................       } 
....................    } 
....................  
....................    // Calculate and set the DMA end address 
....................    i.Val = TXSTART + (WORD)UnmaskedPatternLen - 1; 
....................    WriteReg(EDMANDL, i.v[0]); 
....................    WriteReg(EDMANDH, i.v[1]); 
....................  
....................    // Calculate the checksum on the given pattern using the DMA module 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Make certain that the PM filter isn't enabled while it is 
....................    // being reconfigured. 
....................    BankSel(ERXFCON); 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
....................  
....................    // Get the calculated DMA checksum and store it in the PM 
....................    // checksum registers 
....................    i.v[0] == ReadETHReg(EDMACSL).Val; 
....................    i.v[1] == ReadETHReg(EDMACSH).Val; 
....................    WriteReg(EPMCSL, i.v[0]); 
....................    WriteReg(EPMCSH, i.v[0]); 
....................  
....................    // Set the Pattern Match offset and 8 byte mask 
....................    WriteReg(EPMOL, ((WORD_VAL*)&PatternOffset)->v[0]); 
....................    WriteReg(EPMOH, ((WORD_VAL*)&PatternOffset)->v[1]); 
....................    for(i.Val = EPMM0; i.Val <= EPMM7 ; i.Val++) 
....................    { 
....................       WriteReg(i.Val, *PatternMask++); 
....................    } 
....................  
....................    // Begin using the new Pattern Match filter instead of the 
....................    // broadcast filter 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_PMEN); 
.................... }//end MACSetPMFilter 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDisablePMFilter(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACDisablePMFilter disables the Pattern Match receive 
....................  *               filter (if enabled) and returns to the default filter 
....................  *               configuration of: CRC AND (Unicast OR Broadcast). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDisablePMFilter(void) 
.................... { 
....................    BankSel(ERXFCON); 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
....................    return; 
.................... }//end MACDisablePMFilter 
.................... #endif // end of MAC_FILTER_BROADCASTS specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE MACGet() 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Byte read from the ENC28J60's RAM 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACGet returns the byte pointed to by ERDPT and 
....................  *               increments ERDPT so MACGet() can be called again.  The 
....................  *               increment will follow the receive buffer wrapping boundary. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE MACGet() 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = RBM; 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = 0;            // Send a dummy byte to receive the register 
....................                      //   contents. 
....................    while(!PIR1_SSPIF);      // Wait until register is received. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
....................  
....................    return SSPBUF; 
.................... */ 
....................    char c; 
....................  
....................    SPISelectEthernet(); 
*
204C:  BCF    F93.2
204E:  BCF    F8A.2
....................    ENCSPIXfer(RBM); 
2050:  MOVLW  3A
2052:  MOVLB  3
2054:  MOVWF  xA7
2056:  MOVLB  0
2058:  CALL   0900
....................    c=ENCSPIXfer(0); 
205C:  MOVLB  3
205E:  CLRF   xA7
2060:  MOVLB  0
2062:  CALL   0900
2066:  MOVFF  01,381
....................    SPIUnselectEthernet(); 
206A:  BCF    F93.2
206C:  BSF    F8A.2
....................    return(c); 
206E:  MOVLB  3
2070:  MOVFF  381,01
.................... }//end MACGet 
2074:  MOVLB  0
2076:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           *val: Pointer to storage location 
....................  *               len:  Number of bytes to read from the data buffer. 
....................  * 
....................  * Output:          Byte(s) of data read from the data buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Burst reads several sequential bytes from the data buffer 
....................  *               and places them into local memory.  With SPI burst support, 
....................  *               it performs much faster than multiple MACGet() calls. 
....................  *               ERDPT is incremented after each byte, following the same 
....................  *               rules as MACGet(). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetArray(BYTE *val, WORD len) 
.................... { 
*
12C2:  MOVLB  3
12C4:  CLRF   x90
12C6:  CLRF   x8F
.................... /* 
....................    int16 i; 
....................  
....................    // Start the burst operation 
....................    SPISelectEthernet(); 
....................    SSPBUF = RBM;         // Send the Read Buffer Memory opcode. 
....................    i = 0; 
....................    val--; 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    // Read the data 
....................    while(i<len) 
....................    { 
....................       SSPBUF = 0;         // Send a dummy byte to receive a byte 
....................       i++; 
....................       val++; 
....................       while(!PIR1_SSPIF);   // Wait until byte is received. 
....................       PIR1_SSPIF = 0; 
....................       *val = SSPBUF; 
....................    }; 
....................  
....................    // Terminate the burst operation 
....................    SPIUnselectEthernet(); 
....................  
....................    return i; 
.................... */ 
....................  
....................    int16 i=0; 
....................  
....................    SPISelectEthernet(); 
12C8:  BCF    F93.2
12CA:  BCF    F8A.2
....................    ENCSPIXfer(RBM); 
12CC:  MOVLW  3A
12CE:  MOVWF  xA7
12D0:  MOVLB  0
12D2:  CALL   0900
....................    while(i<len) 
....................    { 
12D6:  MOVLB  3
12D8:  MOVF   x90,W
12DA:  SUBWF  x8E,W
12DC:  BNC   1316
12DE:  BNZ   12E6
12E0:  MOVF   x8D,W
12E2:  SUBWF  x8F,W
12E4:  BC    1316
....................       *val=ENCSPIXfer(0); 
12E6:  MOVFF  38C,03
12EA:  MOVFF  38B,391
12EE:  MOVFF  38C,392
12F2:  CLRF   xA7
12F4:  MOVLB  0
12F6:  CALL   0900
12FA:  MOVFF  392,FEA
12FE:  MOVFF  391,FE9
1302:  MOVFF  01,FEF
....................       val++; 
1306:  MOVLB  3
1308:  INCF   x8B,F
130A:  BTFSC  FD8.2
130C:  INCF   x8C,F
....................       i++; 
130E:  INCF   x8F,F
1310:  BTFSC  FD8.2
1312:  INCF   x90,F
....................    } 
1314:  BRA    12D8
....................    SPIUnselectEthernet(); 
1316:  BCF    F93.2
1318:  BSF    F8A.2
....................  
....................    return(i); 
131A:  MOVFF  38F,01
131E:  MOVFF  390,02
.................... }//end MACGetArray 
1322:  MOVLB  0
1324:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPut(BYTE val) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           Byte to write into the ENC28J60 buffer memory 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPut outputs the Write Buffer Memory opcode/constant 
....................  *               (8 bits) and data to write (8 bits) over the SPI. 
....................  *               EWRPT is incremented after the write. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPut(BYTE val) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = WBM;         // Send the opcode and constant. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = val;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until byte is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
16D2:  BCF    F93.2
16D4:  BCF    F8A.2
....................    ENCSPIXfer(WBM); 
16D6:  MOVLW  7A
16D8:  MOVLB  3
16DA:  MOVWF  xA7
16DC:  MOVLB  0
16DE:  CALL   0900
....................    ENCSPIXfer(val); 
16E2:  MOVFF  3A0,3A7
16E6:  CALL   0900
....................    SPIUnselectEthernet(); 
16EA:  BCF    F93.2
16EC:  BSF    F8A.2
.................... }//end MACPut 
16EE:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPutArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           *val: Pointer to source of bytes to copy. 
....................  *               len:  Number of bytes to write to the data buffer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPutArray writes several sequential bytes to the 
....................  *               ENC28J60 RAM.  It performs faster than multiple MACPut() 
....................  *               calls.  EWRPT is incremented by len. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPutArray(BYTE *val, WORD len) 
.................... { 
.................... /* 
....................    // Select the chip and send the proper opcode 
....................    SPISelectEthernet(); 
....................    SSPBUF = WBM;         // Send the Write Buffer Memory opcode 
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    // Send the data 
....................    while(len) 
....................    { 
....................       SSPBUF = *val;      // Start sending the byte 
....................       val++;            // Increment after writing to SSPBUF to increase speed 
....................       len--;            // Decrement after writing to SSPBUF to increase speed 
....................       while(!PIR1_SSPIF);   // Wait until byte is transmitted 
....................       PIR1_SSPIF = 0; 
....................    }; 
....................  
....................    // Terminate the burst operation 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
16F0:  BCF    F93.2
16F2:  BCF    F8A.2
....................    ENCSPIXfer(WBM); 
16F4:  MOVLW  7A
16F6:  MOVLB  3
16F8:  MOVWF  xA7
16FA:  MOVLB  0
16FC:  CALL   0900
....................    while(len--) 
....................    { 
1700:  MOVLB  3
1702:  MOVFF  3A4,03
1706:  MOVF   xA3,W
1708:  BTFSC  FD8.2
170A:  DECF   xA4,F
170C:  DECF   xA3,F
170E:  IORWF  03,W
1710:  BZ    1736
....................       ENCSPIXfer(*val); 
1712:  MOVFF  3A2,03
1716:  MOVFF  3A1,FE9
171A:  MOVFF  3A2,FEA
171E:  MOVFF  FEF,3A5
1722:  MOVFF  3A5,3A7
1726:  MOVLB  0
1728:  CALL   0900
....................       val++; 
172C:  MOVLB  3
172E:  INCF   xA1,F
1730:  BTFSC  FD8.2
1732:  INCF   xA2,F
....................    } 
1734:  BRA    1702
....................    SPIUnselectEthernet(); 
1736:  BCF    F93.2
1738:  BSF    F8A.2
.................... }//end MACPutArray 
173A:  MOVLB  0
173C:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static void SendSystemReset(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SendSystemReset sends the System Reset SPI command to 
....................  *               the Ethernet controller.  It resets all register contents 
....................  *               (except for ECOCON) and returns the device to the power 
....................  *               on default state. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void SendSystemReset(void) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = SR; 
....................    while(!PIR1_SSPIF);      // Wait until the command is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
093A:  BCF    F93.2
093C:  BCF    F8A.2
....................    ENCSPIXfer(SR); 
093E:  MOVLW  FF
0940:  MOVLB  3
0942:  MOVWF  xA7
0944:  MOVLB  0
0946:  RCALL  0900
....................    SPIUnselectEthernet(); 
0948:  BCF    F93.2
094A:  BSF    F8A.2
.................... }//end SendSystemReset 
094C:  GOTO   0BCC (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadETHReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                to read from. 
....................  * 
....................  * Input:           5 bit address of the ETH control register to read from. 
....................  *                 The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's ETH register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadETHReg sends the 8 bit RCR opcode/Address byte over 
....................  *               the SPI and then retrives the register contents in the 
....................  *               next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access MAC/MII or PHY 
....................  *               registers.  Use ReadMACReg() or ReadPHYReg() for that 
....................  *               purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadETHReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
....................    // Select the chip and send the Read Control Register opcode/address 
....................    SPISelectEthernet(); 
....................    SSPBUF = RCR | Address; 
....................  
....................    while(!PIR1_SSPIF);      // Wait until the opcode/address is transmitted 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = 0;            // Send a dummy byte to receive the register 
....................                      //   contents 
....................    while(!PIR1_SSPIF);      // Wait until the register is received 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
....................  
....................    return *((REG*)&SSPBUF); 
....................    */ 
....................  
....................    SPISelectEthernet(); 
*
0910:  BCF    F93.2
0912:  BCF    F8A.2
....................    ENCSPIXfer(RCR | Address); 
0914:  MOVFF  39C,39E
0918:  MOVFF  39C,3A7
091C:  MOVLB  0
091E:  RCALL  0900
....................    c=ENCSPIXfer(0); 
0920:  MOVLB  3
0922:  CLRF   xA7
0924:  MOVLB  0
0926:  RCALL  0900
0928:  MOVFF  01,39D
....................    SPIUnselectEthernet(); 
092C:  BCF    F93.2
092E:  BSF    F8A.2
....................    return(c); 
0930:  MOVLB  3
0932:  MOVFF  39D,01
.................... }//end ReadETHReg 
0936:  MOVLB  0
0938:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadMACReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                to read from. 
....................  * 
....................  * Input:           5 bit address of the MAC or MII register to read from. 
....................  *                 The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's MAC/MII register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadMACReg sends the 8 bit RCR opcode/Address byte as well 
....................  *               as a dummy byte over the SPI and then retrives the 
....................  *               register contents in the last 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access ETH or PHY 
....................  *               registers.  Use ReadETHReg() or ReadPHYReg() for that 
....................  *               purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadMACReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
....................    SPISelectEthernet(); 
....................  
....................    SSPBUF = RCR | Address;   // Send the Read Control Register opcode and 
....................                      //   address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    SSPBUF = 0;            // Send a dummy byte 
....................    while(!PIR1_SSPIF);      // Wait for the dummy byte to be transmitted 
....................    PIR1_SSPIF = 0; 
....................  
....................    SSPBUF = 0;            // Send another dummy byte to receive the register 
....................                      //   contents. 
....................    while(!PIR1_SSPIF);      // Wait until register is received. 
....................    PIR1_SSPIF = 0; 
....................  
....................    SPIUnselectEthernet(); 
....................  
....................    return *((REG*)&SSPBUF); 
.................... */ 
....................    SPISelectEthernet(); 
*
09D4:  BCF    F93.2
09D6:  BCF    F8A.2
....................  
....................    ENCSPIXfer(RCR | Address); 
09D8:  MOVFF  2F6,2F8
09DC:  MOVFF  2F6,3A7
09E0:  MOVLB  0
09E2:  RCALL  0900
....................    ENCSPIXfer(0); 
09E4:  MOVLB  3
09E6:  CLRF   xA7
09E8:  MOVLB  0
09EA:  RCALL  0900
....................    c=ENCSPIXfer(0); 
09EC:  MOVLB  3
09EE:  CLRF   xA7
09F0:  MOVLB  0
09F2:  RCALL  0900
09F4:  MOVFF  01,2F7
....................  
....................    SPIUnselectEthernet(); 
09F8:  BCF    F93.2
09FA:  BSF    F8A.2
....................  
....................    return(c); 
09FC:  MOVLB  2
09FE:  MOVFF  2F7,01
.................... }//end ReadMACReg 
0A02:  MOVLB  0
0A04:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        ReadPHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to read from. 
....................  * 
....................  * Output:          16 bits of data read from the PHY register. 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 2 
....................  * 
....................  * Overview:        ReadPHYReg performs an MII read operation.  While in 
....................  *               progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PHYREG ReadPHYReg(BYTE Register) 
.................... { 
....................    PHYREG Result; 
....................  
....................    // Set the right address and start the register read operation 
....................    BankSel(MIREGADR); 
*
0A74:  MOVLW  02
0A76:  MOVLB  3
0A78:  MOVWF  xA0
0A7A:  MOVLW  14
0A7C:  MOVWF  x9F
0A7E:  MOVLB  0
0A80:  RCALL  09AA
....................    WriteReg(MIREGADR, Register); 
0A82:  MOVLW  14
0A84:  MOVLB  3
0A86:  MOVWF  xA2
0A88:  MOVFF  2F3,3A3
0A8C:  MOVLB  0
0A8E:  RCALL  0950
....................    WriteReg(MICMD, MICMD_MIIRD); 
0A90:  MOVLW  12
0A92:  MOVLB  3
0A94:  MOVWF  xA2
0A96:  MOVLW  01
0A98:  MOVWF  xA3
0A9A:  MOVLB  0
0A9C:  RCALL  0950
....................  
....................    // Loop to wait until the PHY register has been read through the MII 
....................    // This requires 10.24us 
....................    BankSel(MISTAT); 
0A9E:  MOVLW  03
0AA0:  MOVLB  3
0AA2:  MOVWF  xA0
0AA4:  MOVLW  0A
0AA6:  MOVWF  x9F
0AA8:  MOVLB  0
0AAA:  RCALL  09AA
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
0AAC:  MOVLW  0A
0AAE:  MOVLB  2
0AB0:  MOVWF  xF6
0AB2:  MOVLB  0
0AB4:  RCALL  09D4
0AB6:  BTFSC  01.0
0AB8:  BRA    0AAC
....................  
....................    // Stop reading 
....................    BankSel(MIREGADR); 
0ABA:  MOVLW  02
0ABC:  MOVLB  3
0ABE:  MOVWF  xA0
0AC0:  MOVLW  14
0AC2:  MOVWF  x9F
0AC4:  MOVLB  0
0AC6:  RCALL  09AA
....................    WriteReg(MICMD, 0x00); 
0AC8:  MOVLW  12
0ACA:  MOVLB  3
0ACC:  MOVWF  xA2
0ACE:  CLRF   xA3
0AD0:  MOVLB  0
0AD2:  RCALL  0950
....................  
....................    // Obtain results and return 
....................    Result.VAL.v[0] = ReadMACReg(MIRDL).Val; 
0AD4:  MOVLW  18
0AD6:  MOVLB  2
0AD8:  MOVWF  xF6
0ADA:  MOVLB  0
0ADC:  RCALL  09D4
0ADE:  MOVFF  01,2F4
....................    Result.VAL.v[1] = ReadMACReg(MIRDH).Val; 
0AE2:  MOVLW  19
0AE4:  MOVLB  2
0AE6:  MOVWF  xF6
0AE8:  MOVLB  0
0AEA:  RCALL  09D4
0AEC:  MOVFF  01,2F5
....................    return Result; 
0AF0:  MOVLB  2
0AF2:  MOVFF  2F4,01
0AF6:  MOVFF  2F5,02
.................... }//end ReadPHYReg 
0AFA:  MOVLB  0
0AFC:  GOTO   0B16 (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void WriteReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *               to modify. 
....................  * 
....................  * Input:           5 bit address of the ETH, MAC, or MII register to modify. 
....................  *                 The top 3 bits must be 0. 
....................  *               Byte to be written into the register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        WriteReg sends the 8 bit WCR opcode/Address byte over the 
....................  *               SPI and then sends the data to write in the next 8 SPI 
....................  *               clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the BFCReg() and 
....................  *               BFSReg() functions.  It is seperate to maximize speed. 
....................  *               Unlike the ReadETHReg/ReadMACReg functions, WriteReg() 
....................  *               can write to any ETH or MAC register.  Writing to PHY 
....................  *               registers must be accomplished with WritePHYReg(). 
....................  *****************************************************************************/ 
.................... static void WriteReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = WCR | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
0950:  BCF    F93.2
0952:  BCF    F8A.2
....................    ENCSPIXfer(WCR | Address); 
0954:  MOVLB  3
0956:  MOVF   xA2,W
0958:  IORLW  40
095A:  MOVWF  xA4
095C:  MOVWF  xA7
095E:  MOVLB  0
0960:  RCALL  0900
....................    ENCSPIXfer(Data); 
0962:  MOVFF  3A3,3A7
0966:  RCALL  0900
....................    SPIUnselectEthernet(); 
0968:  BCF    F93.2
096A:  BSF    F8A.2
.................... }//end WriteReg 
096C:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFCReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                 to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                 must be 0. 
....................  *               Byte to be used with the Bit Field Clear operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFCReg sends the 8 bit BFC opcode/Address byte over the 
....................  *               SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *               BFSReg() functions.  It is separate to maximize speed. 
....................  *               BFCReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFCReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = BFC | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
096E:  BCF    F93.2
0970:  BCF    F8A.2
....................    ENCSPIXfer(BFC | Address); 
0972:  MOVLB  3
0974:  MOVF   xA1,W
0976:  IORLW  A0
0978:  MOVWF  xA3
097A:  MOVWF  xA7
097C:  MOVLB  0
097E:  RCALL  0900
....................    ENCSPIXfer(Data); 
0980:  MOVFF  3A2,3A7
0984:  RCALL  0900
....................    SPIUnselectEthernet(); 
0986:  BCF    F93.2
0988:  BSF    F8A.2
.................... }//end BFCReg 
098A:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFSReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *               to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                 must be 0. 
....................  *               Byte to be used with the Bit Field Set operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFSReg sends the 8 bit BFC opcode/Address byte over the 
....................  *               SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *               BFCReg() functions.  It is separate to maximize speed. 
....................  *               BFSReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFSReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = BFS | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
098C:  BCF    F93.2
098E:  BCF    F8A.2
....................    ENCSPIXfer(BFS | Address); 
0990:  MOVLB  3
0992:  MOVF   xA4,W
0994:  IORLW  80
0996:  MOVWF  xA6
0998:  MOVWF  xA7
099A:  MOVLB  0
099C:  RCALL  0900
....................    ENCSPIXfer(Data); 
099E:  MOVFF  3A5,3A7
09A2:  RCALL  0900
....................    SPIUnselectEthernet(); 
09A4:  BCF    F93.2
09A6:  BSF    F8A.2
.................... }//end BFSReg 
09A8:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WritePHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to write to. 
....................  *               16 bits of data to write to PHY register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 3 
....................  * 
....................  * Overview:        WritePHYReg performs an MII write operation.  While in 
....................  *               progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void WritePHYReg(BYTE Register, WORD Data) 
.................... { 
....................    // Write the register address 
....................    BankSel(MIREGADR); 
*
0A06:  MOVLW  02
0A08:  MOVLB  3
0A0A:  MOVWF  xA0
0A0C:  MOVLW  14
0A0E:  MOVWF  x9F
0A10:  MOVLB  0
0A12:  RCALL  09AA
....................    WriteReg(MIREGADR, Register); 
0A14:  MOVLW  14
0A16:  MOVLB  3
0A18:  MOVWF  xA2
0A1A:  MOVFF  2F3,3A3
0A1E:  MOVLB  0
0A20:  RCALL  0950
....................  
....................    // Write the data 
....................    // Order is important: write low byte first, high byte last 
....................    WriteReg(MIWRL, ((WORD_VAL*)&Data)->v[0]); 
0A22:  MOVLW  02
0A24:  MOVWF  FEA
0A26:  MOVLW  F4
0A28:  MOVWF  FE9
0A2A:  MOVFF  FEF,2F8
0A2E:  MOVLW  16
0A30:  MOVLB  3
0A32:  MOVWF  xA2
0A34:  MOVFF  2F8,3A3
0A38:  MOVLB  0
0A3A:  RCALL  0950
....................    WriteReg(MIWRH, ((WORD_VAL*)&Data)->v[1]); 
0A3C:  MOVLW  02
0A3E:  MOVWF  FEA
0A40:  MOVLW  F5
0A42:  MOVWF  FE9
0A44:  MOVFF  FEF,2F8
0A48:  MOVLW  17
0A4A:  MOVLB  3
0A4C:  MOVWF  xA2
0A4E:  MOVFF  2F8,3A3
0A52:  MOVLB  0
0A54:  RCALL  0950
....................  
....................    // Wait until the PHY register has been written 
....................    BankSel(MISTAT); 
0A56:  MOVLW  03
0A58:  MOVLB  3
0A5A:  MOVWF  xA0
0A5C:  MOVLW  0A
0A5E:  MOVWF  x9F
0A60:  MOVLB  0
0A62:  RCALL  09AA
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
0A64:  MOVLW  0A
0A66:  MOVLB  2
0A68:  MOVWF  xF6
0A6A:  MOVLB  0
0A6C:  RCALL  09D4
0A6E:  BTFSC  01.0
0A70:  BRA    0A64
.................... }//end WritePHYReg 
0A72:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BankSel 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Register address with the high byte containing the 2 bank 
....................  *                 select 2 bits. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BankSel takes the high byte of a register address and 
....................  *               changes the bank select bits in ETHCON1 to match. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void BankSel(WORD Register) 
.................... { 
....................    BFCReg(ECON1, ECON1_BSEL1 | ECON1_BSEL0); 
*
09AA:  MOVLW  1F
09AC:  MOVLB  3
09AE:  MOVWF  xA1
09B0:  MOVLW  03
09B2:  MOVWF  xA2
09B4:  MOVLB  0
09B6:  RCALL  096E
....................    BFSReg(ECON1, ((WORD_VAL*)&Register)->v[1]); 
09B8:  MOVLW  03
09BA:  MOVWF  FEA
09BC:  MOVLW  A0
09BE:  MOVWF  FE9
09C0:  MOVFF  FEF,3A3
09C4:  MOVLW  1F
09C6:  MOVLB  3
09C8:  MOVWF  xA4
09CA:  MOVFF  3A3,3A5
09CE:  MOVLB  0
09D0:  RCALL  098C
.................... }//end BankSel 
09D2:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static BOOL TestMemory(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if the memory tests have passed 
....................  *               FALSE if the BIST has detected a hardware fault 
....................  * 
....................  * Side Effects:    Alters the state of numerous control registers and all 
....................  *               RAM bytes. 
....................  * 
....................  * Overview:        The internal BIST and DMA modules are used to fill the 
....................  *               entire dual port memory and calculate a checksum of the 
....................  *               data stored within.  Address and Random fill modes are 
....................  *               used. 
....................  * 
....................  * Note:            For the Random Fill mode, the random number generator is 
....................  *               seeded by the contents of the TMR0L PIC SFR.  If the timer 
....................  *               is running, additional confidence that the memory is 
....................  *               working can be obtained by calling TestMemory multiple 
....................  *               times. 
....................  *****************************************************************************/ 
.................... #if defined(MAC_POWER_ON_TEST) 
.................... static BOOL TestMemory(void) 
.................... { 
....................    #define RANDOM_FILL      0b0000 
....................    #define ADDRESS_FILL   0b0100 
....................    #define PATTERN_SHIFT   0b1000 
....................  
....................    WORD_VAL DMAChecksum, BISTChecksum; 
....................  
....................  
....................    // Select Bank 0 and disable anything that could have been in progress 
....................    WriteReg(ECON1, 0x00); 
....................  
....................    // Set up necessary pointers for the DMA to calculate over the entire 
....................    // memory 
....................    WriteReg(EDMASTL, 0x00); 
....................    WriteReg(EDMASTH, 0x00); 
....................    WriteReg(EDMANDL, LOW(RAMSIZE-1u)); 
....................    WriteReg(EDMANDH, HIGH(RAMSIZE-1u)); 
....................    WriteReg(ERXNDL, LOW(RAMSIZE-1u)); 
....................    WriteReg(ERXNDH, HIGH(RAMSIZE-1u)); 
....................  
....................    // Enable Test Mode and do an Address Fill 
....................    BankSel(EBSTCON); 
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
....................                    EBSTCON_BISTST | 
....................                    ADDRESS_FILL); 
....................  
....................  
....................    // Wait for the BIST to complete and disable test mode before 
....................    // starting any DMA operations. 
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
....................    // Begin reading the memory and calculating a checksum over it 
....................    // Block until the checksum is generated 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    BankSel(EDMACSL); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Obtain the resulting DMA checksum and the expected BIST checksum 
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
....................    BankSel(EBSTCSL); 
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................    // Compare the results 
....................    // 0xF807 should always be generated in Address fill mode 
....................    if( (DMAChecksum.Val != BISTChecksum.Val) || (DMAChecksum.Val != 0xF807) ) 
....................       return FALSE; 
....................  
....................    // Seed the random number generator and begin another Random Fill test 
....................    // with the DMA and BIST memory access ports swapped. 
.................... #ifdef __C30__ 
....................    WriteReg((BYTE)EBSTSD, TMR1); 
.................... #else 
....................    WriteReg((BYTE)EBSTSD, TMR0L); 
.................... #endif 
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
....................                  EBSTCON_PSEL | 
....................                  EBSTCON_BISTST | 
....................                  RANDOM_FILL); 
....................  
....................  
....................    // Wait for the BIST to complete and disable test mode since 
....................    // we won't be needing it anymore 
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
....................    // Begin reading the memory and calculating a checksum over it 
....................    // Block until the checksum is generated 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    BankSel(EDMACSL); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Obtain the resulting DMA checksum and the expected BIST checksum 
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
....................    BankSel(EBSTCSL); 
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
....................  
....................    return (DMAChecksum.Val == BISTChecksum.Val); 
.................... }//end TestMemory 
.................... #endif 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetDuplex(DUPLEX DuplexState) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Member of DUPLEX enum: 
....................  *                  FULL: Set full duplex mode 
....................  *                  HALF: Set half duplex mode 
....................  *                  USE_PHY: Set the MAC to match the PHYDPLXMODE bit in 
....................  *                         PHYCON.  This is controlled by LEDB on RESET. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Changes bank bits to Bank 2. 
....................  * 
....................  * Overview:        Disables RX, TX logic, sets MAC up for full duplex 
....................  *               operation, sets PHY up for full duplex operation, and 
....................  *               reenables RX logic.  The back-to-back inter-packet gap 
....................  *               register (MACBBIPG) is updated to maintain a 9.6us gap. 
....................  * 
....................  * Note:            If a packet is being transmitted or received while this 
....................  *               function is called, it will be aborted. 
....................  *****************************************************************************/ 
.................... void MACSetDuplex(DUPLEX DuplexState) 
.................... { 
....................    REG Register; 
....................    PHYREG PhyReg; 
....................  
....................    // Disable receive logic and abort any packets currently being transmitted 
....................    BFCReg(ECON1, ECON1_TXRTS | ECON1_RXEN); 
*
0B00:  MOVLW  1F
0B02:  MOVLB  3
0B04:  MOVWF  xA1
0B06:  MOVLW  0C
0B08:  MOVWF  xA2
0B0A:  MOVLB  0
0B0C:  RCALL  096E
....................  
....................    // Set the PHY to the proper duplex mode 
....................    PhyReg = ReadPHYReg(PHCON1); 
0B0E:  MOVLB  2
0B10:  CLRF   xF3
0B12:  MOVLB  0
0B14:  BRA    0A74
0B16:  MOVFF  02,2F2
0B1A:  MOVFF  01,2F1
....................    if(DuplexState == USE_PHY) 
0B1E:  MOVLB  2
0B20:  MOVF   xEF,W
0B22:  SUBLW  02
0B24:  BNZ   0B2E
....................    { 
....................       DuplexState = PhyReg.PHCON1bits.PDPXMD; 
0B26:  CLRF   xEF
0B28:  BTFSC  xF2.0
0B2A:  INCF   xEF,F
....................    } 
....................    else 
0B2C:  BRA    0B42
....................    { 
....................       PhyReg.PHCON1bits.PDPXMD = DuplexState; 
0B2E:  BCF    xF2.0
0B30:  BTFSC  xEF.0
0B32:  BSF    xF2.0
....................       WritePHYReg(PHCON1, PhyReg.Val); 
0B34:  CLRF   xF3
0B36:  MOVFF  2F2,2F5
0B3A:  MOVFF  2F1,2F4
0B3E:  MOVLB  0
0B40:  RCALL  0A06
....................    } 
....................  
....................    // Set the MAC to the proper duplex mode 
....................    BankSel(MACON3); 
0B42:  MOVLW  02
0B44:  MOVLB  3
0B46:  MOVWF  xA0
0B48:  MOVWF  x9F
0B4A:  MOVLB  0
0B4C:  RCALL  09AA
....................    Register = ReadMACReg(MACON3); 
0B4E:  MOVLW  02
0B50:  MOVLB  2
0B52:  MOVWF  xF6
0B54:  MOVLB  0
0B56:  RCALL  09D4
0B58:  MOVFF  01,2F0
....................    Register.MACON3bits.FULDPX = DuplexState; 
0B5C:  MOVLB  2
0B5E:  BCF    xF0.0
0B60:  BTFSC  xEF.0
0B62:  BSF    xF0.0
....................    WriteReg(MACON3, Register.Val); 
0B64:  MOVLW  02
0B66:  MOVLB  3
0B68:  MOVWF  xA2
0B6A:  MOVFF  2F0,3A3
0B6E:  MOVLB  0
0B70:  RCALL  0950
....................  
....................    // Set the back-to-back inter-packet gap time to IEEE specified 
....................    // requirements.  The meaning of the MABBIPG value changes with the duplex 
....................    // state, so it must be updated in this function. 
....................    // In full duplex, 0x15 represents 9.6us; 0x12 is 9.6us in half duplex 
....................    WriteReg(MABBIPG, DuplexState ? 0x15 : 0x12); 
0B72:  MOVLB  2
0B74:  MOVF   xEF,F
0B76:  BZ    0B7C
0B78:  MOVLW  15
0B7A:  BRA    0B7E
0B7C:  MOVLW  12
0B7E:  MOVWF  xF3
0B80:  MOVLW  04
0B82:  MOVLB  3
0B84:  MOVWF  xA2
0B86:  MOVFF  2F3,3A3
0B8A:  MOVLB  0
0B8C:  RCALL  0950
....................  
....................    // Reenable receive logic 
....................    BFSReg(ECON1, ECON1_RXEN); 
0B8E:  MOVLW  1F
0B90:  MOVLB  3
0B92:  MOVWF  xA4
0B94:  MOVLW  04
0B96:  MOVWF  xA5
0B98:  MOVLB  0
0B9A:  RCALL  098C
.................... }//end MACSetDuplex 
0B9C:  GOTO   0D5C (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerDown(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerDown puts the ENC28J60 in low power sleep mode. In 
....................  *               sleep mode, no packets can be transmitted or received. 
....................  *               All MAC and PHY registers should not be accessed. 
....................  * 
....................  * Note:            If a packet is being transmitted while this function is 
....................  *                called, this function will block until it is it complete. 
....................  *               If anything is being received, it will be completed. 
....................  *****************************************************************************/ 
.................... void MACPowerDown(void) 
.................... { 
....................    // Disable packet reception 
....................    BFCReg(ECON1, ECON1_RXEN); 
....................  
....................    // Make sure any last packet which was in-progress when RXEN was cleared 
....................    // is completed 
....................    while(ReadETHReg(ESTAT).ESTATbits.RXBUSY); 
....................  
....................    // If a packet is being transmitted, wait for it to finish 
....................    while(ReadETHReg(ECON1).ECON1bits.TXRTS); 
....................  
....................    // Enter sleep mode 
....................    BFSReg(ECON2, ECON2_PWRSV); 
.................... }//end MACPowerDown 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerUp(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerUp returns the ENC28J60 back to normal operation 
....................  *               after a previous call to MACPowerDown().  Calling this 
....................  *               function when already powered up will have no effect. 
....................  * 
....................  * Note:            The first packet transmitted may get lost at the RX end if 
....................  *               you don't wait for the link to go up first.  MACIsLinked() 
....................  *               can be called to determine if a link is established. 
....................  *****************************************************************************/ 
.................... void MACPowerUp(void) 
.................... { 
....................    // Leave power down mode 
....................    BFCReg(ECON2, ECON2_PWRSV); 
....................  
....................    // Wait for the 300us Oscillator Startup Timer (OST) to time out.  This 
....................    // delay is required for the PHY module to return to an operational state. 
....................    while(!ReadETHReg(ESTAT).ESTATbits.CLKRDY); 
....................  
....................    // Enable packet reception 
....................    BFSReg(ECON1, ECON1_RXEN); 
.................... }//end MACPowerUp 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void SetCLKOUT(BYTE NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - 0x00: CLKOUT disabled (pin driven low) 
....................  *                        0x01: Divide by 1 (25 MHz) 
....................  *                        0x02: Divide by 2 (12.5 MHz) 
....................  *                        0x03: Divide by 3 (8.333333 MHz) 
....................  *                        0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                        0x05: Divide by 8 (3.125 MHz) 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the ECOCON register. 
....................  *               The CLKOUT pin will beginning outputting the new frequency 
....................  *               immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... void SetCLKOUT(BYTE NewConfig) 
.................... { 
....................    BankSel(ECOCON); 
....................    WriteReg(ECOCON, NewConfig); 
.................... }//end SetCLKOUT 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE GetCLKOUT(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          BYTE - 0x00: CLKOUT disabled (pin driven low) 
....................  *                     0x01: Divide by 1 (25 MHz) 
....................  *                     0x02: Divide by 2 (12.5 MHz) 
....................  *                     0x03: Divide by 3 (8.333333 MHz) 
....................  *                     0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                     0x05: Divide by 8 (3.125 MHz) 
....................  *                     0x06: Reserved 
....................  *                     0x07: Reserved 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the ECOCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE GetCLKOUT(void) 
.................... { 
....................    BankSel(ECOCON); 
....................    return ReadETHReg(ECOCON).Val; 
.................... }//end GetCLKOUT 
....................  
....................    #elif STACK_USE_MCPINC 
....................     #include "tcpip/eth97j60.c" 
....................    #else 
....................     #include "tcpip/rtl8019AS.c" 
....................    #endif 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    #include "tcpip/modem.c" 
....................    #include "tcpip/ppp.c" 
....................    #include "tcpip/pppwrap.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SLIP 
....................    #include "tcpip/slip.c" 
.................... #ENDIF 
....................  
.................... #if STACK_USE_UDP 
....................    #include "tcpip/udp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    #include "tcpip/dhcp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    #include "tcpip/smtp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    #include "tcpip/http.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                     /// 
.................... ///                              HTTP.H                                 /// 
.................... ///                                                                     /// 
.................... /// Simple webserver for the Microchip TCP/IP stack.                    /// 
.................... /// NOTE: THIS IS A DIFFERENT HTTP.H THAN WHAT MICROCHIP PROVIDES       /// 
.................... ///                                                                     /// 
.................... /// See HTTP.C for documenation                                         /// 
.................... ///                                                                     /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef HTTP_USE_CHUNKS 
.................... #define HTTP_USE_CHUNKS   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_DOUBLE_ESCAPE 
.................... #define HTTP_USE_DOUBLE_ESCAPE   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_CONTENT_TYPE 
.................... #define HTTP_USE_CONTENT_TYPE   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_PORT 
.................... #define HTTP_PORT             80 
.................... #endif 
....................  
.................... #ifndef HTTP_NUM_SOCKETS 
.................... #define HTTP_NUM_SOCKETS      1 
.................... #endif 
....................  
.................... #ifndef HTTP_GET_PARAM_MAX_SIZE 
.................... #define HTTP_GET_PARAM_MAX_SIZE  254 
.................... #endif 
....................  
.................... void HTTP_Init(void); 
.................... void HTTP_Task(void); 
....................  
.................... //**** CALLBACKS START ******/// 
....................  
.................... /// the following three functions are callbacks and 
.................... /// must be written in your main application!!!  see the documentation above 
.................... /// for more help. 
....................  
.................... #if HTTP_USE_CONTENT_TYPE 
....................  void http_get_page(char *file_str, int32 *retAddress, char *retStr); 
.................... #else 
....................  int32 http_get_page(char *file_str); 
.................... #endif 
....................  
.................... int8 http_format_char(int32 file, char id, char *str, int8 max_ret); 
.................... void http_exec_cgi(int32 file, char *key, char *val); 
....................  
.................... //**** CALLBACKS END ******/// 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    #include "tcpip/http2.h" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
....................    #include "tcpip/dns.h" 
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
....................    #include "tcpip/snmp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
....................    #include "tcpip/mpfs.h" 
.................... #endif 
....................  
.................... #include "tcpip/ip.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC IP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.C 
....................  * Dependencies:    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Howard Schlunder		8/31/04	Beta Rev 0.9 (See version.log for detail) 
....................  * Howard Schlunder		1/5/06	Improved DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... // This is left shifted by 4.  Actual value is 0x04. 
.................... #define IPv4                (0x40u) 
.................... #define IP_VERSION          IPv4 
....................  
.................... #define debug_ip 
.................... //#define debug_ip  debug_printf 
....................  
.................... // IHL (Internet Header Length) is # of DWORDs in a header. 
.................... // Since, we do not support options, our IP header length will be 
.................... // minimum i.e. 20 bytes : IHL = 20 / 4 = 5. 
.................... #define IP_IHL              (0x05) 
....................  
.................... #define IP_SERVICE_NW_CTRL  (0x07) 
.................... #define IP_SERVICE_IN_CTRL  (0x06) 
.................... #define IP_SERVICE_ECP      (0x05) 
.................... #define IP_SERVICE_OVR      (0x04) 
.................... #define IP_SERVICE_FLASH    (0x03) 
.................... #define IP_SERVICE_IMM      (0x02) 
.................... #define IP_SERVICE_PRIOR    (0x01) 
.................... #define IP_SERVICE_ROUTINE  (0x00) 
....................  
.................... #define IP_SERVICE_N_DELAY  (0x00) 
.................... #define IP_SERCICE_L_DELAY  (0x08) 
.................... #define IP_SERVICE_N_THRPT  (0x00) 
.................... #define IP_SERVICE_H_THRPT  (0x10) 
.................... #define IP_SERVICE_N_RELIB  (0x00) 
.................... #define IP_SERVICE_H_RELIB  (0x20) 
....................  
.................... #define IP_SERVICE          (IP_SERVICE_ROUTINE | IP_SERVICE_N_DELAY) 
....................  
.................... #define MY_IP_TTL           (100)   // Time-To-Live in Seconds 
....................  
....................  
....................  
....................  
.................... static WORD _Identifier = 0; 
.................... static BYTE IPHeaderLen; 
....................  
.................... static void SwapIPHeader(IP_HEADER* h); 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len) 
.................... { 
....................     WORD_VAL    CalcChecksum; 
....................     IP_HEADER   header; 
....................  
.................... #if !defined(MCHP_MAC) 
....................     WORD_VAL    ReceivedChecksum; 
....................     WORD        checksums[2]; 
....................     BYTE        optionsLen; 
.................... #define MAX_OPTIONS_LEN     (40)            // As per RFC 791. 
....................     BYTE        options[MAX_OPTIONS_LEN]; 
.................... #endif 
....................  
....................     // Read IP header. 
....................     MACGetArray((BYTE*)&header, sizeof(header)); 
*
1E76:  MOVLW  02
1E78:  MOVLB  3
1E7A:  MOVWF  x13
1E7C:  MOVLW  FE
1E7E:  MOVFF  313,38C
1E82:  MOVWF  x8B
1E84:  CLRF   x8E
1E86:  MOVLW  14
1E88:  MOVWF  x8D
1E8A:  MOVLB  0
1E8C:  CALL   12C2
....................  
....................     // Make sure that this is an IPv4 packet. 
....................     if ( (header.VersionIHL & 0xf0) != IP_VERSION ) 
1E90:  MOVLB  2
1E92:  MOVF   xFE,W
1E94:  ANDLW  F0
1E96:  SUBLW  40
1E98:  BZ    1EA0
....................     	return FALSE; 
1E9A:  MOVLW  00
1E9C:  MOVWF  01
1E9E:  BRA    1F58
....................  
.................... 	IPHeaderLen = (header.VersionIHL & 0x0f) << 2; 
1EA0:  MOVF   xFE,W
1EA2:  ANDLW  0F
1EA4:  MOVWF  00
1EA6:  RLCF   00,W
1EA8:  MOVWF  5B
1EAA:  RLCF   5B,F
1EAC:  MOVLW  FC
1EAE:  ANDWF  5B,F
....................  
.................... #if defined(MCHP_MAC) 
.................... 	// Validate the IP header.  If it is correct, the checksum 
.................... 	// will come out to 0x0000 (because the header contains a 
.................... 	// precomputed checksum).  A corrupt header will have a 
.................... 	// nonzero checksum. 
.................... 	CalcChecksum.Val = MACCalcRxChecksum(0, IPHeaderLen); 
1EB0:  MOVLB  3
1EB2:  CLRF   x4E
1EB4:  CLRF   x4D
1EB6:  CLRF   x50
1EB8:  MOVFF  5B,34F
1EBC:  MOVLB  0
1EBE:  RCALL  1C22
1EC0:  MOVFF  02,2FD
1EC4:  MOVFF  01,2FC
....................  
.................... 	// Seek to the end of the IP header 
.................... 	MACSetRxBuffer(IPHeaderLen); 
1EC8:  MOVLB  3
1ECA:  CLRF   x26
1ECC:  MOVFF  5B,325
1ED0:  MOVLB  0
1ED2:  RCALL  1D1A
....................  
....................     if(CalcChecksum.Val) 
1ED4:  MOVLB  2
1ED6:  MOVF   xFC,W
1ED8:  IORWF  xFD,W
1EDA:  BZ    1EE2
.................... #else 
....................  
....................     // Calculate options length in this header, if there is any. 
....................     // IHL is in terms of numbers of 32-bit DWORDs; i.e. actual 
....................     // length is 4 times IHL. 
....................     optionsLen = ((header.VersionIHL & 0x0f) << 2) - sizeof(header); 
....................  
....................     // If there is any option(s), read it so that we can include them 
....................     // in checksum calculation. 
....................     if ( optionsLen > MAX_OPTIONS_LEN ) 
....................         return FALSE; 
....................  
....................     if ( optionsLen > 0 ) 
....................         MACGetArray(options, optionsLen); 
....................  
....................     // Save header checksum; clear it and recalculate it ourselves. 
....................     ReceivedChecksum.Val = header.HeaderChecksum; 
....................     header.HeaderChecksum = 0; 
....................  
....................     // Calculate checksum of header including options bytes. 
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&header, sizeof(header)); 
....................  
....................     // Calculate Options checksum too, if they are present. 
....................     if ( optionsLen > 0 ) 
....................         checksums[1] = ~CalcIPChecksum((BYTE*)options, optionsLen); 
....................     else 
....................         checksums[1] = 0; 
....................  
....................     CalcChecksum.Val  = CalcIPChecksum((BYTE*)checksums, 
....................                                             2 * sizeof(WORD)); 
....................  
....................     // Make sure that checksum is correct 
....................     if ( ReceivedChecksum.Val != CalcChecksum.Val ) 
.................... #endif 
....................     { 
....................         // Bad packet. The function caller will be notified by means of the FALSE 
....................         // return value and it should discard the packet. 
....................         return FALSE; 
1EDC:  MOVLW  00
1EDE:  MOVWF  01
1EE0:  BRA    1F58
....................     } 
....................  
....................     // Network to host conversion. 
....................     SwapIPHeader(&header); 
1EE2:  MOVLW  02
1EE4:  MOVLB  3
1EE6:  MOVWF  x97
1EE8:  MOVLW  FE
1EEA:  MOVWF  x96
1EEC:  MOVLB  0
1EEE:  RCALL  1D96
....................  
....................     // If caller is intrested, return destination IP address 
....................     // as seen in this IP header. 
....................     if ( localIP ) 
1EF0:  MOVLB  2
1EF2:  MOVF   xF4,W
1EF4:  IORWF  xF5,W
1EF6:  BZ    1F10
....................         localIP->Val    = header.DestAddress.Val; 
1EF8:  MOVFF  2F4,FE9
1EFC:  MOVFF  2F5,FEA
1F00:  MOVFF  30E,FEF
1F04:  MOVFF  30F,FEC
1F08:  MOVFF  310,FEC
1F0C:  MOVFF  311,FEC
....................  
....................     remote->IPAddr.Val  = header.SourceAddress.Val; 
1F10:  MOVLW  06
1F12:  ADDWF  xF6,W
1F14:  MOVWF  FE9
1F16:  MOVLW  00
1F18:  ADDWFC xF7,W
1F1A:  MOVWF  FEA
1F1C:  MOVFF  30A,FEF
1F20:  MOVFF  30B,FEC
1F24:  MOVFF  30C,FEC
1F28:  MOVFF  30D,FEC
....................     *protocol           = header.Protocol; 
1F2C:  MOVFF  2F8,FE9
1F30:  MOVFF  2F9,FEA
1F34:  MOVFF  307,FEF
.................... #if defined(MCHP_MAC) 
....................     *len 				= header.TotalLength - IPHeaderLen; 
1F38:  MOVFF  2FA,FE9
1F3C:  MOVFF  2FB,FEA
1F40:  MOVF   5B,W
1F42:  MOVLB  3
1F44:  SUBWF  x00,W
1F46:  MOVWF  00
1F48:  MOVLW  00
1F4A:  SUBWFB x01,W
1F4C:  MOVFF  00,FEF
1F50:  MOVWF  FEC
.................... #else 
....................     *len                = header.TotalLength - optionsLen - 
....................                             sizeof(header); 
.................... #endif 
....................  
....................     return TRUE; 
1F52:  MOVLW  01
1F54:  MOVWF  01
1F56:  MOVLB  2
.................... } 
1F58:  MOVLB  0
1F5A:  GOTO   7064 (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function: WORD IPPutHeader(NODE_INFO *remote, 
....................  *           				  BYTE protocol, 
....................  *                			  WORD len) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           *remote     - Destination node address 
....................  *                  protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          (WORD)0 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  ********************************************************************/ 
.................... WORD IPPutHeader(NODE_INFO *remote, 
....................                 BYTE protocol, 
....................                 WORD    len) 
.................... { 
....................     IP_HEADER   header; 
....................  
....................     IPHeaderLen = sizeof(IP_HEADER); 
*
2914:  MOVLW  14
2916:  MOVWF  5B
....................  
....................     header.VersionIHL       = IP_VERSION | IP_IHL; 
2918:  MOVLW  45
291A:  MOVLB  3
291C:  MOVWF  x82
....................     header.TypeOfService    = IP_SERVICE; 
291E:  CLRF   x83
....................     header.TotalLength      = sizeof(header) + len; 
2920:  MOVLW  14
2922:  ADDWF  x80,W
2924:  MOVWF  x84
2926:  MOVLW  00
2928:  ADDWFC x81,W
292A:  MOVWF  x85
....................     header.Identification   = ++_Identifier; 
292C:  INCF   59,F
292E:  BTFSC  FD8.2
2930:  INCF   5A,F
2932:  MOVFF  5A,387
2936:  MOVFF  59,386
....................     header.FragmentInfo     = 0; 
293A:  CLRF   x89
293C:  CLRF   x88
....................     header.TimeToLive       = MY_IP_TTL; 
293E:  MOVLW  64
2940:  MOVWF  x8A
....................     header.Protocol         = protocol; 
2942:  MOVFF  37F,38B
....................     header.HeaderChecksum   = 0; 
2946:  CLRF   x8D
2948:  CLRF   x8C
.................... 	header.SourceAddress = AppConfig.MyIPAddr; 
294A:  MOVFF  1A,391
294E:  MOVFF  19,390
2952:  MOVFF  18,38F
2956:  MOVFF  17,38E
....................  
....................     header.DestAddress.Val = remote->IPAddr.Val; 
295A:  MOVLW  06
295C:  ADDWF  x7D,W
295E:  MOVWF  FE9
2960:  MOVLW  00
2962:  ADDWFC x7E,W
2964:  MOVWF  FEA
2966:  MOVFF  FEF,00
296A:  MOVFF  FEC,01
296E:  MOVFF  FEC,02
2972:  MOVFF  FEC,03
2976:  MOVFF  03,395
297A:  MOVFF  02,394
297E:  MOVFF  01,393
2982:  MOVFF  00,392
....................  
....................     SwapIPHeader(&header); 
2986:  MOVLW  03
2988:  MOVWF  x97
298A:  MOVLW  82
298C:  MOVWF  x96
298E:  MOVLB  0
2990:  CALL   1D96
....................  
.................... #if !defined(MCHP_MAC) 
....................     header.HeaderChecksum   = CalcIPChecksum((BYTE*)&header, 
....................                                                 sizeof(header)); 
.................... #endif 
....................  
....................     MACPutHeader(&remote->MACAddr, MAC_IP, (sizeof(header)+len)); 
2994:  MOVLB  3
2996:  MOVFF  37D,01
299A:  MOVFF  37E,03
299E:  MOVFF  37D,396
29A2:  MOVFF  37E,397
29A6:  MOVLW  14
29A8:  ADDWF  x80,W
29AA:  MOVWF  x98
29AC:  MOVLW  00
29AE:  ADDWFC x81,W
29B0:  MOVWF  x99
29B2:  MOVFF  37E,39B
29B6:  MOVFF  37D,39A
29BA:  CLRF   x9C
29BC:  MOVWF  x9E
29BE:  MOVFF  398,39D
29C2:  MOVLB  0
29C4:  CALL   173E
....................     MACPutArray((BYTE*)&header, sizeof(header)); 
29C8:  MOVLW  03
29CA:  MOVLB  3
29CC:  MOVWF  x97
29CE:  MOVLW  82
29D0:  MOVFF  397,3A2
29D4:  MOVWF  xA1
29D6:  CLRF   xA4
29D8:  MOVLW  14
29DA:  MOVWF  xA3
29DC:  MOVLB  0
29DE:  CALL   16F0
....................  
.................... #if defined(MCHP_MAC) 
.................... 	header.HeaderChecksum = MACCalcTxChecksum(0, sizeof(header)); 
29E2:  MOVLB  3
29E4:  CLRF   x97
29E6:  CLRF   x96
29E8:  CLRF   x99
29EA:  MOVLW  14
29EC:  MOVWF  x98
29EE:  MOVLB  0
29F0:  RCALL  284C
29F2:  MOVFF  02,38D
29F6:  MOVFF  01,38C
.................... 	MACSetTxBuffer(CurrentTxBuffer, 10);	// 10 is the offset in header to the HeaderChecksum member 
29FA:  MOVFF  4E,396
29FE:  MOVLB  3
2A00:  CLRF   x98
2A02:  MOVLW  0A
2A04:  MOVWF  x97
2A06:  MOVLB  0
2A08:  CALL   1648
.................... 	MACPutArray((BYTE*)&header.HeaderChecksum, 2); 
2A0C:  MOVLW  03
2A0E:  MOVLB  3
2A10:  MOVWF  x97
2A12:  MOVLW  8C
2A14:  MOVFF  397,3A2
2A18:  MOVWF  xA1
2A1A:  CLRF   xA4
2A1C:  MOVLW  02
2A1E:  MOVWF  xA3
2A20:  MOVLB  0
2A22:  CALL   16F0
.................... 	MACSetTxBuffer(CurrentTxBuffer, sizeof(header));	// Seek back to the end of the packet 
2A26:  MOVFF  4E,396
2A2A:  MOVLB  3
2A2C:  CLRF   x98
2A2E:  MOVLW  14
2A30:  MOVWF  x97
2A32:  MOVLB  0
2A34:  CALL   1648
.................... #endif 
....................  
....................     return 0x0; 
2A38:  MOVLW  00
2A3A:  MOVWF  01
2A3C:  MOVWF  02
.................... } 
2A3E:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset) 
.................... { 
.................... 	MACSetRxBuffer(Offset+IPHeaderLen); 
*
21C0:  MOVF   5B,W
21C2:  MOVLB  3
21C4:  ADDWF  x21,W
21C6:  MOVWF  x23
21C8:  MOVLW  00
21CA:  ADDWFC x22,W
21CC:  MOVWF  x24
21CE:  MOVWF  x26
21D0:  MOVFF  323,325
21D4:  MOVLB  0
21D6:  RCALL  1D1A
.................... } 
21D8:  RETLW  00
....................  
....................  
....................  
.................... static void SwapIPHeader(IP_HEADER* h) 
.................... { 
....................     h->TotalLength      = swaps(h->TotalLength); 
*
1D96:  MOVLW  02
1D98:  MOVLB  3
1D9A:  ADDWF  x96,W
1D9C:  MOVWF  01
1D9E:  MOVLW  00
1DA0:  ADDWFC x97,W
1DA2:  MOVWF  03
1DA4:  MOVFF  01,398
1DA8:  MOVWF  x99
1DAA:  MOVLW  02
1DAC:  ADDWF  x96,W
1DAE:  MOVWF  FE9
1DB0:  MOVLW  00
1DB2:  ADDWFC x97,W
1DB4:  MOVWF  FEA
1DB6:  MOVFF  FEC,39B
1DBA:  MOVF   FED,F
1DBC:  MOVFF  FEF,39A
1DC0:  MOVFF  39B,39D
1DC4:  MOVFF  39A,39C
1DC8:  MOVLB  0
1DCA:  CALL   1326
1DCE:  MOVFF  399,FEA
1DD2:  MOVFF  398,FE9
1DD6:  MOVFF  02,FEC
1DDA:  MOVF   FED,F
1DDC:  MOVFF  01,FEF
....................     h->Identification   = swaps(h->Identification); 
1DE0:  MOVLW  04
1DE2:  MOVLB  3
1DE4:  ADDWF  x96,W
1DE6:  MOVWF  01
1DE8:  MOVLW  00
1DEA:  ADDWFC x97,W
1DEC:  MOVWF  03
1DEE:  MOVFF  01,398
1DF2:  MOVWF  x99
1DF4:  MOVLW  04
1DF6:  ADDWF  x96,W
1DF8:  MOVWF  FE9
1DFA:  MOVLW  00
1DFC:  ADDWFC x97,W
1DFE:  MOVWF  FEA
1E00:  MOVFF  FEC,39B
1E04:  MOVF   FED,F
1E06:  MOVFF  FEF,39A
1E0A:  MOVFF  39B,39D
1E0E:  MOVFF  39A,39C
1E12:  MOVLB  0
1E14:  CALL   1326
1E18:  MOVFF  399,FEA
1E1C:  MOVFF  398,FE9
1E20:  MOVFF  02,FEC
1E24:  MOVF   FED,F
1E26:  MOVFF  01,FEF
....................     h->HeaderChecksum   = swaps(h->HeaderChecksum); 
1E2A:  MOVLW  0A
1E2C:  MOVLB  3
1E2E:  ADDWF  x96,W
1E30:  MOVWF  01
1E32:  MOVLW  00
1E34:  ADDWFC x97,W
1E36:  MOVWF  03
1E38:  MOVFF  01,398
1E3C:  MOVWF  x99
1E3E:  MOVLW  0A
1E40:  ADDWF  x96,W
1E42:  MOVWF  FE9
1E44:  MOVLW  00
1E46:  ADDWFC x97,W
1E48:  MOVWF  FEA
1E4A:  MOVFF  FEC,39B
1E4E:  MOVF   FED,F
1E50:  MOVFF  FEF,39A
1E54:  MOVFF  39B,39D
1E58:  MOVFF  39A,39C
1E5C:  MOVLB  0
1E5E:  CALL   1326
1E62:  MOVFF  399,FEA
1E66:  MOVFF  398,FE9
1E6A:  MOVFF  02,FEC
1E6E:  MOVF   FED,F
1E70:  MOVFF  01,FEF
.................... } 
1E74:  RETLW  00
....................  
....................  
.................... #if STACK_USE_TCP 
....................    #include "tcpip/tcp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module for Microchip TCP/IP Stack 
....................  *               Based on RFC 793 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
.................... * FileName:        TCP.C 
.................... * Dependencies:    string.h 
.................... *                  StackTsk.h 
.................... *                  Helpers.h 
.................... *                  IP.h 
.................... *                  MAC.h 
.................... *                  ARP.h 
.................... *                  Tick.h 
.................... *                  TCP.h 
.................... * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
.................... * Complier:        CCS PCH 
.................... * Company:         Microchip Technology, Inc. 
.................... * 
.................... * Software License Agreement 
.................... * 
.................... * This software is owned by Microchip Technology Inc. ("Microchip") 
.................... * and is supplied to you for use exclusively as described in the 
.................... * associated software agreement.  This software is protected by 
.................... * software and other intellectual property laws.  Any use in 
.................... * violation of the software license may subject the user to criminal 
.................... * sanctions as well as civil liability.  Copyright 2006 Microchip 
.................... * Technology Inc.  All rights reserved. 
.................... * 
.................... * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
.................... * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
.................... * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
.................... * INFRINGEMENT.  Microchip shall in no event be liable for special, 
.................... * incidental, or consequential damages. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     11/1/02 Fixed TCPTick() SYN Retry bug. 
....................  * Darren Rook (CCS)    06/28/04  Applied 2.20 fix (above) 
....................  * Darren Rook (CCS)    06/30/04 TCPTick() will not time out an establisehd socket if that socket is in server mode. 
....................  * Darren Rook (CCS)    07/02/04 A bug fix for change made on 06/28/04 
....................  * Darren Rook (CCS)    07/12/04 TCPConnect() will set StartTick to fix a bug with timeout 
....................  * Darren Rook (CCS)    07/12/04 TCPInit() attempts to make _NextPort a random number 
....................  * Darren Rook (CCS)    07/12/06 startTick spelled wrong (case) 
....................  * Nilesh Rajbharti     12/5/02   Modified TCPProcess() 
....................  *                              to include localIP as third param. 
....................  *                              This was done to allow this function 
....................  *                              to calculate checksum correctly. 
....................  * Roy Schofield      10/1/04   TCPConnect() startTick bug fix. 
....................  * Howard Schlunder      1/3/05   Fixed HandleTCPSeg() unexpected 
....................  *                         discard problem identified by Richard 
....................  *                         Shelquist. 
....................  * Howard Schlunder      1/16/06   Fixed an imporbable RX checksum bug 
....................  *                        when using a Microchip Ethernet controller) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    09/18/06 Added TCPPutAvailable() 
....................  * Howard Schlunder      5/10/06   Revised TCP state machine, add TCP_FIN_2 
....................  * Howard Schlunder      8/01/06 Adjusted response to ACK only in TCP_SYN_SENT state 
....................  * Howard Schlunder      8/03/06 Fixed checksum comparison check 
....................  *                        reported by DouglasPunch on Microchip Forum. 
....................  * Howard Schlunder      8/11/06 Fixed a resource leak causing MAC TX 
....................  *                        Buffers to be obtained but not 
....................  *                        released when many web requests were 
....................  *                        received concurrently. 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               10 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tcp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        CCS PCH 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip")  
....................  * and is supplied to you for use exclusively as described in the  
....................  * associated software agreement.  This software is protected by  
....................  * software and other intellectual property laws.  Any use in  
....................  * violation of the software license may subject the user to criminal  
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL  
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED  
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND  
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,  
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     12/5/03 Modified TCPProcess() prototype. 
....................  *                              See TCP.c for more information. 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef TCP_H 
.................... #define TCP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               10 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... typedef BYTE TCP_SOCKET; 
.................... typedef WORD TCP_PORT; 
....................  
.................... #ifndef TCP_NO_WAIT_FOR_ACK 
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * Maximum number of times a connection be retried before 
....................  * closing it down. 
....................  */ 
.................... #define MAX_RETRY_COUNTS    (3) 
....................  
.................... #define INVALID_SOCKET      (0xfe) 
.................... #define UNKNOWN_SOCKET      (0xff) 
....................  
.................... #define REMOTE_HOST(s)      (TCB[s].remote) 
....................  
.................... /* 
....................  * TCP States as defined by rfc793 
....................  */ 
.................... typedef enum _TCP_STATE 
.................... { 
....................     TCP_LISTEN = 0, 
....................     TCP_SYN_SENT, 
....................     TCP_SYN_RECEIVED, 
....................     TCP_ESTABLISHED, 
....................     TCP_FIN_WAIT_1, 
....................     TCP_FIN_WAIT_2, 
....................     TCP_CLOSING, 
....................     TCP_TIME_WAIT, 
.................... 	TCP_CLOSE_WAIT, 
....................     TCP_LAST_ACK, 
....................     TCP_CLOSED, 
.................... } TCP_STATE; 
....................  
.................... /* 
....................  * Socket info. 
....................  * Union is used to create anonymous structure members. 
....................  */ 
.................... typedef struct _SOCKET_INFO 
.................... { 
....................     TCP_STATE smState; 
....................  
....................     NODE_INFO remote; 
....................     TCP_PORT localPort; 
....................     TCP_PORT remotePort; 
....................  
....................     BUFFER TxBuffer; 
....................     WORD TxCount; 
....................     WORD RxCount; 
.................... 	WORD RemoteWindow; 
.................... 	 
....................     DWORD SND_SEQ; 
....................     DWORD SND_ACK; 
....................  
....................     BYTE RetryCount; 
....................     TICKTYPE startTick; 
....................     TICKTYPE TimeOut; 
....................  
....................     struct 
....................     { 
....................         int1 bServer        : 1; 
....................         int1 bIsPutReady    : 1; 
....................         int1 bFirstRead     : 1; 
....................         int1 bIsGetReady    : 1; 
....................         int1 bIsTxInProgress : 1; 
....................         int1 bACKValid : 1; 
....................     } Flags; 
....................  
.................... } SOCKET_INFO; 
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TCP is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initialize all socket info. 
....................  * 
....................  * Note:            This function is called only one during lifetime 
....................  *                  of the application. 
....................  ********************************************************************/ 
.................... void        TCPInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPListen(TCP_PORT port) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           port    - A TCP port to be opened. 
....................  * 
....................  * Output:          Given port is opened and returned on success 
....................  *                  INVALID_SOCKET if no more sockets left. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TCP_SOCKET  TCPListen(TCP_PORT port); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote, 
....................  *                                      TCP_PORT remotePort) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           remote      - Remote node address info 
....................  *                  remotePort  - remote port to be connected. 
....................  * 
....................  * Output:          A new socket is created, connection request is 
....................  *                  sent and socket handle is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT port); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket to be checked for connection. 
....................  * 
....................  * Output:          TRUE    if given socket is connected 
....................  *                  FALSE   if given socket is not connected. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            A socket is said to be connected if it is not 
....................  *                  in LISTEN and CLOSED mode.  Socket may be in 
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket 
....................  *                  data. 
....................  ********************************************************************/ 
.................... BOOL        TCPIsConnected(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPDisconnect(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsPutReady(s) == TRUE 
....................  * 
....................  * Input:           s       - Socket to be disconnected. 
....................  * 
....................  * Output:          A disconnect request is sent for given socket. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void        TCPDisconnect(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' is free to transmit 
....................  *                  FALSE if socket 's' is not free to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Each socket maintains only transmit buffer. 
....................  *                  Hence until a data packet is acknowledeged by 
....................  *                  remote node, socket will not be ready for 
....................  *                  next transmission. 
....................  *                  All control transmission such as Connect, 
....................  *                  Disconnect do not consume/reserve any transmit 
....................  *                  buffer. 
....................  ********************************************************************/ 
.................... BOOL        TCPIsPutReady(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE byte) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s       - socket to use 
....................  *                  byte    - a data byte to send 
....................  * 
....................  * Output:          TRUE if given byte was put in transmit buffer 
....................  *                  FALSE if transmit buffer is full. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPPut(TCP_SOCKET socket, BYTE data); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPFlush(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket whose data is to be transmitted. 
....................  * 
....................  * Output:          All and any data associated with this socket 
....................  *                  is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPFlush(TCP_SOCKET socket); 
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' contains any data. 
....................  *                  FALSE if socket 's' does not contain any data. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPIsGetReady(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  byte    - Pointer to a byte. 
....................  * 
....................  * Output:          TRUE if a byte was read. 
....................  *                  FALSE if byte was not read. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPGet(TCP_SOCKET socket, int8 *data); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer, 
....................  *                                      WORD count) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  buffer  - Buffer to hold received data. 
....................  *                  count   - Buffer length 
....................  * 
....................  * Output:          Number of bytes loaded into buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD        TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket 
....................  * 
....................  * Output:          TRUE if socket received data was discarded 
....................  *                  FALSE if socket received data was already 
....................  *                          discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPDiscard(TCP_SOCKET socket); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPProcess(NODE_INFO* remote, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  len         - Total length of TCP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPProcess(NODE_INFO *remote, 
....................                        IP_ADDR *localIP, 
....................                        WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPTick(void) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Each socket FSM is executed for any timeout 
....................  *                  situation. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void        TCPTick(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #define debug_tcp(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u) 
.................... //#define debug_tcp debug_printf 
....................  
.................... // Max TCP data length is MAC_TX_BUFFER_SIZE - sizeof(TCP_HEADER) - 
.................... // sizeof(IP_HEADER) - sizeof(ETHER_HEADER) 
.................... #define MAX_TCP_DATA_LEN    (MAC_TX_BUFFER_SIZE - 54) 
....................  
.................... // TCP Timeout value to begin with. 
.................... #define TCP_START_TIMEOUT_VAL   (TICKS_PER_SECOND * (TICKTYPE)3) 
....................  
.................... // TCP Flags defined in RFC 
.................... #define FIN     (0x01) 
.................... #define SYN     (0x02) 
.................... #define RST     (0x04) 
.................... #define PSH     (0x08) 
.................... #define ACK     (0x10) 
.................... #define URG     (0x20) 
....................  
....................  
.................... // TCP Header 
.................... typedef struct _TCP_HEADER 
.................... { 
....................     WORD    SourcePort; 
....................     WORD    DestPort; 
....................     DWORD   SeqNumber; 
....................     DWORD   AckNumber; 
....................  
....................     struct 
....................     { 
....................        BYTE Reserved3:4; 
....................        BYTE Val:4; 
....................     } DataOffset; 
....................  
....................  
....................     union 
....................     { 
....................         struct 
....................         { 
....................              int1 flagFIN    : 1; 
....................              int1 flagSYN    : 1; 
....................              int1 flagRST    : 1; 
....................              int1 flagPSH    : 1; 
....................              int1 flagACK    : 1; 
....................              int1 flagURG    : 1; 
....................              int1 Reserved2  : 2; 
....................         } bits; 
....................         BYTE b; 
....................     } Flags; 
....................  
....................     WORD    Window; 
....................     WORD    Checksum; 
....................     WORD    UrgentPointer; 
.................... } TCP_HEADER; 
....................  
....................  
.................... // TCP Options as defined by RFC 
.................... #define TCP_OPTIONS_END_OF_LIST     (0x00) 
.................... #define TCP_OPTIONS_NO_OP           (0x01) 
.................... #define TCP_OPTIONS_MAX_SEG_SIZE    (0x02) 
.................... typedef struct _TCP_OPTIONS 
.................... { 
....................     BYTE        Kind; 
....................     BYTE        Length; 
....................     WORD_VAL    MaxSegSize; 
.................... } TCP_OPTIONS; 
....................  
.................... #define SwapPseudoTCPHeader(h)  (h.TCPLength = swaps(h.TCPLength)) 
....................  
.................... // IP pseudo header as defined by RFC 793 
.................... typedef struct _PSEUDO_HEADER 
.................... { 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................     BYTE Zero; 
....................     BYTE Protocol; 
....................     WORD TCPLength; 
.................... } PSEUDO_HEADER; 
....................  
.................... #define LOCAL_PORT_START_NUMBER (1024) 
.................... #define LOCAL_PORT_END_NUMBER   (5000) 
....................  
.................... // Local temp port numbers. 
.................... static WORD _NextPort = LOCAL_PORT_START_NUMBER; 
....................  
.................... // The TCB array is very large.  With the C18 compiler, one must 
.................... // modify the linker script to make an array that spans more than 
.................... // one memory bank.  To do this, make the necessary changes to your 
.................... // processor's linker script (.lkr).  Here is an example showing 
.................... // gpr11 and 128 bytes of gpr12 being combined into one 384 byte 
.................... // block used exclusively by the TCB_MEM data section: 
.................... // ... 
.................... // //DATABANK   NAME=gpr11      START=0xB00          END=0xBFF 
.................... // //DATABANK   NAME=gpr12      START=0xC00          END=0xCFF 
.................... // DATABANK   NAME=gpr11b     START=0xB00          END=0xC7F           PROTECTED 
.................... // DATABANK   NAME=gpr12      START=0xC80          END=0xCFF 
.................... // ... 
.................... // SECTION    NAME=TCB_MEM    RAM=gpr11b 
.................... // ... 
.................... //#pragma udata TCB_MEM   //not needed in ccs 
.................... SOCKET_INFO TCB[MAX_SOCKETS]; 
.................... //   #pragma udata bla   // Return to any other RAM section   //not needed in ccs 
....................  
.................... static void    HandleTCPSeg(TCP_SOCKET s, 
....................                                NODE_INFO *remote, 
....................                                TCP_HEADER *h, 
....................                                WORD len); 
....................  
.................... static void TransmitTCP(NODE_INFO *remote, 
....................                         TCP_PORT localPort, 
....................                         TCP_PORT remotePort, 
....................                         DWORD tseq, 
....................                         DWORD tack, 
....................                         BYTE flags, 
....................                         BUFFER buff, 
....................                         WORD len); 
....................  
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, 
....................                                     NODE_INFO *remote); 
.................... static void    SwapTCPHeader(TCP_HEADER* header); 
.................... static void CloseSocket(SOCKET_INFO* ps); 
....................  
.................... #define SendTCP(remote, localPort, remotePort, seq, ack, flags)     \ 
....................         TransmitTCP(remote, localPort, remotePort, seq, ack, flags, \ 
....................                     INVALID_BUFFER, 0) 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPInit(void) 
.................... * 
.................... * PreCondition:    None 
.................... * 
.................... * Input:           None 
.................... * 
.................... * Output:          TCP is initialized. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        Initialize all socket states 
.................... * 
.................... * Note:            This function is called only once during lifetime 
.................... *                  of the application. 
.................... ********************************************************************/ 
.................... int16 TCPInit_RandSeed; 
.................... void TCPInit(void) 
.................... { 
....................     TCP_SOCKET s; 
....................     SOCKET_INFO* ps; 
....................  
....................  
....................     // Initialize all sockets. 
....................     for ( s = 0; s < MAX_SOCKETS; s++ ) 
*
0EBC:  MOVLB  2
0EBE:  CLRF   xEE
0EC0:  MOVF   xEE,W
0EC2:  SUBLW  04
0EC4:  BNC   0F98
....................     { 
....................         ps = &TCB[s]; 
0EC6:  MOVF   xEE,W
0EC8:  MULLW  24
0ECA:  MOVF   FF3,W
0ECC:  CLRF   03
0ECE:  ADDLW  5E
0ED0:  MOVWF  01
0ED2:  MOVLW  00
0ED4:  ADDWFC 03,F
0ED6:  MOVFF  01,2EF
0EDA:  MOVFF  03,2F0
....................  
....................         ps->smState             = TCP_CLOSED; 
0EDE:  MOVFF  2EF,FE9
0EE2:  MOVFF  2F0,FEA
0EE6:  MOVLW  0A
0EE8:  MOVWF  FEF
....................         ps->Flags.bServer       = FALSE; 
0EEA:  MOVLW  23
0EEC:  ADDWF  xEF,W
0EEE:  MOVWF  FE9
0EF0:  MOVLW  00
0EF2:  ADDWFC xF0,W
0EF4:  MOVWF  FEA
0EF6:  BCF    FEF.0
....................         ps->Flags.bIsPutReady   = TRUE; 
0EF8:  MOVLW  23
0EFA:  ADDWF  xEF,W
0EFC:  MOVWF  FE9
0EFE:  MOVLW  00
0F00:  ADDWFC xF0,W
0F02:  MOVWF  FEA
0F04:  BSF    FEF.1
....................         ps->Flags.bFirstRead    = TRUE; 
0F06:  MOVLW  23
0F08:  ADDWF  xEF,W
0F0A:  MOVWF  FE9
0F0C:  MOVLW  00
0F0E:  ADDWFC xF0,W
0F10:  MOVWF  FEA
0F12:  BSF    FEF.2
....................         ps->Flags.bIsTxInProgress = FALSE; 
0F14:  MOVLW  23
0F16:  ADDWF  xEF,W
0F18:  MOVWF  FE9
0F1A:  MOVLW  00
0F1C:  ADDWFC xF0,W
0F1E:  MOVWF  FEA
0F20:  BCF    FEF.4
....................         ps->Flags.bIsGetReady   = FALSE; 
0F22:  MOVLW  23
0F24:  ADDWF  xEF,W
0F26:  MOVWF  FE9
0F28:  MOVLW  00
0F2A:  ADDWFC xF0,W
0F2C:  MOVWF  FEA
0F2E:  BCF    FEF.3
....................       if(ps->TxBuffer != INVALID_BUFFER) 
0F30:  MOVLW  0F
0F32:  ADDWF  xEF,W
0F34:  MOVWF  FE9
0F36:  MOVLW  00
0F38:  ADDWFC xF0,W
0F3A:  MOVWF  FEA
0F3C:  INCFSZ FEF,W
0F3E:  BRA    0F42
0F40:  BRA    0F6E
....................       { 
....................          MACDiscardTx(ps->TxBuffer); 
0F42:  MOVLW  0F
0F44:  ADDWF  xEF,W
0F46:  MOVWF  FE9
0F48:  MOVLW  00
0F4A:  ADDWFC xF0,W
0F4C:  MOVWF  FEA
0F4E:  MOVFF  FEF,2F1
0F52:  MOVFF  2F1,341
0F56:  MOVLB  0
0F58:  CALL   0004
....................          ps->TxBuffer        = INVALID_BUFFER; 
0F5C:  MOVLW  0F
0F5E:  MOVLB  2
0F60:  ADDWF  xEF,W
0F62:  MOVWF  FE9
0F64:  MOVLW  00
0F66:  ADDWFC xF0,W
0F68:  MOVWF  FEA
0F6A:  MOVLW  FF
0F6C:  MOVWF  FEF
....................       } 
....................         ps->TimeOut             = TCP_START_TIMEOUT_VAL; 
0F6E:  MOVLW  21
0F70:  ADDWF  xEF,W
0F72:  MOVWF  FE9
0F74:  MOVLW  00
0F76:  ADDWFC xF0,W
0F78:  MOVWF  FEA
0F7A:  CLRF   FEC
0F7C:  MOVF   FED,F
0F7E:  MOVLW  1E
0F80:  MOVWF  FEF
....................       ps->TxCount            = 0; 
0F82:  MOVLW  10
0F84:  ADDWF  xEF,W
0F86:  MOVWF  FE9
0F88:  MOVLW  00
0F8A:  ADDWFC xF0,W
0F8C:  MOVWF  FEA
0F8E:  CLRF   FEC
0F90:  MOVF   FED,F
0F92:  CLRF   FEF
....................    } 
....................  
....................     //_NextPort = LOCAL_PORT_START_NUMBER; 
....................     #if getenv("TIMER0") 
0F94:  INCF   xEE,F
0F96:  BRA    0EC0
....................     TCPInit_RandSeed+=get_timer0(); 
0F98:  MOVF   FD6,W
0F9A:  MOVLB  1
0F9C:  ADDWF  x12,F
0F9E:  MOVF   FD7,W
0FA0:  ADDWFC x13,F
....................     #endif 
....................     #if getenv("TIMER1") 
....................      TCPInit_RandSeed+=get_timer1(); 
0FA2:  MOVF   FCE,W
0FA4:  ADDWF  x12,F
0FA6:  MOVF   FCF,W
0FA8:  ADDWFC x13,F
....................     #endif 
....................     #if getenv("TIMER2") 
....................      TCPInit_RandSeed+=get_timer2(); 
0FAA:  MOVF   FCC,W
0FAC:  ADDWF  x12,F
0FAE:  MOVLW  00
0FB0:  ADDWFC x13,F
....................     #endif 
....................     #if getenv("TIMER3") 
....................      TCPInit_RandSeed+=get_timer3(); 
0FB2:  MOVF   FB2,W
0FB4:  ADDWF  x12,F
0FB6:  MOVF   FB3,W
0FB8:  ADDWFC x13,F
....................     #endif 
....................     #if getenv("TIMER4") 
....................      TCPInit_RandSeed+=get_timer4(); 
....................     #endif 
....................     #if getenv("TIMER5") 
....................      TCPInit_RandSeed+=get_timer5(); 
....................     #endif 
....................     srand(TCPInit_RandSeed); 
0FBA:  MOVLB  2
0FBC:  CLRF   xF4
0FBE:  CLRF   xF3
0FC0:  MOVFF  113,2F2
0FC4:  MOVFF  112,2F1
0FC8:  MOVLB  0
0FCA:  BRA    0D8E
....................     _NextPort=rand(); 
0FCC:  BRA    0E48
0FCE:  MOVFF  02,5D
0FD2:  MOVFF  01,5C
....................     _NextPort+=LOCAL_PORT_START_NUMBER; 
0FD6:  MOVLW  04
0FD8:  ADDWF  5D,F
....................     while (_NextPort >= LOCAL_PORT_END_NUMBER) {_NextPort-=LOCAL_PORT_END_NUMBER;} 
0FDA:  MOVF   5D,W
0FDC:  SUBLW  12
0FDE:  BC    0FF4
0FE0:  XORLW  FF
0FE2:  BNZ   0FEA
0FE4:  MOVF   5C,W
0FE6:  SUBLW  87
0FE8:  BC    0FF4
0FEA:  MOVLW  88
0FEC:  SUBWF  5C,F
0FEE:  MOVLW  13
0FF0:  SUBWFB 5D,F
0FF2:  BRA    0FDA
....................     if (_NextPort < LOCAL_PORT_START_NUMBER) {_NextPort+=LOCAL_PORT_START_NUMBER;} 
0FF4:  MOVF   5D,W
0FF6:  SUBLW  03
0FF8:  BNC   0FFE
0FFA:  MOVLW  04
0FFC:  ADDWF  5D,F
.................... } 
0FFE:  GOTO   1178 (RETURN)
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        TCP_SOCKET TCPListen(TCP_PORT port) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           port    - A TCP port to be opened. 
.................... * 
.................... * Output:          Given port is opened and returned on success 
.................... *                  INVALID_SOCKET if no more sockets left. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... TCP_SOCKET TCPListen(TCP_PORT port) 
.................... { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................  
....................    debug_tcp("\r\nTCP LISTEN PORT=%LU -> ", port); 
....................  
....................    for(s = 0; s < MAX_SOCKETS; s++) 
1002:  MOVLB  2
1004:  CLRF   xF3
1006:  MOVF   xF3,W
1008:  SUBLW  04
100A:  BNC   10F4
....................    { 
....................       ps = &TCB[s]; 
100C:  MOVF   xF3,W
100E:  MULLW  24
1010:  MOVF   FF3,W
1012:  CLRF   03
1014:  ADDLW  5E
1016:  MOVWF  01
1018:  MOVLW  00
101A:  ADDWFC 03,F
101C:  MOVFF  01,2F4
1020:  MOVFF  03,2F5
....................  
....................       if(ps->smState == TCP_CLOSED) 
1024:  MOVFF  2F4,FE9
1028:  MOVFF  2F5,FEA
102C:  MOVF   FEF,W
102E:  SUBLW  0A
1030:  BNZ   10F0
....................       { 
....................          // We have a CLOSED socket. 
....................          // Initialize it with LISTENing state info. 
....................          ps->smState             = TCP_LISTEN; 
1032:  MOVFF  2F4,FE9
1036:  MOVFF  2F5,FEA
103A:  CLRF   FEF
....................          ps->localPort           = port; 
103C:  MOVLW  0B
103E:  ADDWF  xF4,W
1040:  MOVWF  FE9
1042:  MOVLW  00
1044:  ADDWFC xF5,W
1046:  MOVWF  FEA
1048:  MOVFF  2F2,FEC
104C:  MOVF   FED,F
104E:  MOVFF  2F1,FEF
....................          ps->remotePort          = 0; 
1052:  MOVLW  0D
1054:  ADDWF  xF4,W
1056:  MOVWF  FE9
1058:  MOVLW  00
105A:  ADDWFC xF5,W
105C:  MOVWF  FEA
105E:  CLRF   FEC
1060:  MOVF   FED,F
1062:  CLRF   FEF
....................  
....................          // There is no remote node IP address info yet. 
....................          ps->remote.IPAddr.Val   = 0x00; 
1064:  MOVLW  07
1066:  ADDWF  xF4,W
1068:  MOVWF  FE9
106A:  MOVLW  00
106C:  ADDWFC xF5,W
106E:  MOVWF  FEA
1070:  MOVF   FEE,F
1072:  MOVF   FEE,F
1074:  CLRF   FEC
1076:  MOVF   FED,F
1078:  CLRF   FEF
107A:  MOVF   FED,F
107C:  CLRF   FEF
107E:  MOVF   FED,F
1080:  CLRF   FEF
....................  
....................          // If a socket is listened on, it is a SERVER. 
....................          ps->Flags.bServer       = TRUE; 
1082:  MOVLW  23
1084:  ADDWF  xF4,W
1086:  MOVWF  FE9
1088:  MOVLW  00
108A:  ADDWFC xF5,W
108C:  MOVWF  FEA
108E:  BSF    FEF.0
....................  
....................          ps->Flags.bIsGetReady   = FALSE; 
1090:  MOVLW  23
1092:  ADDWF  xF4,W
1094:  MOVWF  FE9
1096:  MOVLW  00
1098:  ADDWFC xF5,W
109A:  MOVWF  FEA
109C:  BCF    FEF.3
....................          if(ps->TxBuffer != INVALID_BUFFER) 
109E:  MOVLW  0F
10A0:  ADDWF  xF4,W
10A2:  MOVWF  FE9
10A4:  MOVLW  00
10A6:  ADDWFC xF5,W
10A8:  MOVWF  FEA
10AA:  INCFSZ FEF,W
10AC:  BRA    10B0
10AE:  BRA    10DC
....................          { 
....................             MACDiscardTx(ps->TxBuffer); 
10B0:  MOVLW  0F
10B2:  ADDWF  xF4,W
10B4:  MOVWF  FE9
10B6:  MOVLW  00
10B8:  ADDWFC xF5,W
10BA:  MOVWF  FEA
10BC:  MOVFF  FEF,2F6
10C0:  MOVFF  2F6,341
10C4:  MOVLB  0
10C6:  CALL   0004
....................             ps->TxBuffer        = INVALID_BUFFER; 
10CA:  MOVLW  0F
10CC:  MOVLB  2
10CE:  ADDWF  xF4,W
10D0:  MOVWF  FE9
10D2:  MOVLW  00
10D4:  ADDWFC xF5,W
10D6:  MOVWF  FEA
10D8:  MOVLW  FF
10DA:  MOVWF  FEF
....................          } 
....................          ps->Flags.bIsPutReady   = TRUE; 
10DC:  MOVLW  23
10DE:  ADDWF  xF4,W
10E0:  MOVWF  FE9
10E2:  MOVLW  00
10E4:  ADDWFC xF5,W
10E6:  MOVWF  FEA
10E8:  BSF    FEF.1
....................  
....................          debug_tcp("SOCK=%U", s); 
....................  
....................          return s; 
10EA:  MOVFF  2F3,01
10EE:  BRA    10F8
....................       } 
....................    } 
10F0:  INCF   xF3,F
10F2:  BRA    1006
....................  
....................    debug_tcp("FAIL"); 
....................  
....................    return INVALID_SOCKET; 
10F4:  MOVLW  FE
10F6:  MOVWF  01
.................... } 
10F8:  MOVLB  0
10FA:  GOTO   1124 (RETURN)
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote, 
.................... *                                      TCP_PORT remotePort) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           remote      - Remote node address info 
.................... *                  remotePort  - remote port to be connected. 
.................... * 
.................... * Output:          A new socket is created, connection request is 
.................... *                  sent and socket handle is returned. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... ********************************************************************/ 
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT remotePort) 
.................... { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................    BOOL lbFound; 
....................  
....................  
....................    lbFound = FALSE; 
....................  
....................    debug_tcp("\r\nTCP CONNECT PORT=%LU -> ", remotePort); 
....................  
....................    // Find an available socket 
....................    for(s = 0; s < MAX_SOCKETS; s++) 
....................    { 
....................       ps = &TCB[s]; 
....................       if(ps->smState == TCP_CLOSED) 
....................       { 
....................          lbFound = TRUE; 
....................          break; 
....................       } 
....................    } 
....................  
....................    // If there is no socket available, return error. 
....................    if(!lbFound) 
....................       return INVALID_SOCKET; 
....................  
....................    // Each new socket that is opened by this node, gets 
....................    // next sequential port number. 
....................    ps->localPort = ++_NextPort; 
....................    if(_NextPort >= LOCAL_PORT_END_NUMBER) 
....................       _NextPort = LOCAL_PORT_START_NUMBER-1; 
....................  
....................    // This is a client socket. 
....................    ps->Flags.bServer = FALSE; 
....................  
....................    // This is the port, we are trying to connect to. 
....................    ps->remotePort = remotePort; 
....................  
....................    // Each new socket that is opened by this node, will 
....................    // start with next the next seqeuence number (essentially random) 
....................    ps->SND_SEQ++; 
....................    ps->SND_ACK = 0; 
....................  
....................    memcpy((BYTE*)&ps->remote, (void*)remote, sizeof(ps->remote)); 
....................  
....................    // Send SYN message. 
....................    SendTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       SYN); 
....................  
....................    ps->smState = TCP_SYN_SENT; 
....................    ps->SND_SEQ++; 
....................  
....................    // Allow TCPTick() to operate properly 
....................    ps->startTick = TickGet(); 
....................  
....................    debug_tcp("SOCK=%U", s); 
....................  
....................    return s; 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket to be checked for connection. 
....................  * 
....................  * Output:          TRUE    if given socket is connected 
....................  *                  FALSE   if given socket is not connected. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            A socket is said to be connected if it is not 
....................  *                  in LISTEN and CLOSED mode.  Socket may be in 
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket 
....................  *                  data. 
....................  ********************************************************************/ 
.................... BOOL TCPIsConnected(TCP_SOCKET s) 
.................... { 
....................     return ( TCB[s].smState == TCP_ESTABLISHED ); 
*
40C0:  MOVLB  2
40C2:  MOVF   xFC,W
40C4:  MULLW  24
40C6:  MOVF   FF3,W
40C8:  CLRF   xFE
40CA:  MOVWF  xFD
40CC:  MOVLW  5E
40CE:  ADDWF  xFD,W
40D0:  MOVWF  FE9
40D2:  MOVLW  00
40D4:  ADDWFC xFE,W
40D6:  MOVWF  FEA
40D8:  MOVF   FEF,W
40DA:  SUBLW  03
40DC:  BZ    40E2
40DE:  MOVLW  00
40E0:  BRA    40E4
40E2:  MOVLW  01
40E4:  MOVWF  01
.................... } 
40E6:  MOVLB  0
40E8:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPDisconnect(TCP_SOCKET s) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPIsPutReady(s) == TRUE 
.................... * 
.................... * Input:           s       - Socket to be disconnected. 
.................... * 
.................... * Output:          A disconnect request is sent for given socket. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... void TCPDisconnect(TCP_SOCKET s) 
.................... { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
*
6226:  MOVLB  2
6228:  MOVF   xFC,W
622A:  MULLW  24
622C:  MOVF   FF3,W
622E:  CLRF   03
6230:  ADDLW  5E
6232:  MOVWF  01
6234:  MOVLW  00
6236:  ADDWFC 03,F
6238:  MOVFF  01,2FD
623C:  MOVFF  03,2FE
....................  
....................    // If socket is not connected, may be it is already closed 
....................    // or in the process of closing.  Since we have called this 
....................    // explicitly, close it forcefully. 
....................    if(ps->smState != TCP_ESTABLISHED && ps->smState != TCP_SYN_RECEIVED) 
6240:  MOVFF  2FD,FE9
6244:  MOVFF  2FE,FEA
6248:  MOVF   FEF,W
624A:  SUBLW  03
624C:  BZ    626C
624E:  MOVFF  2FD,FE9
6252:  MOVFF  2FE,FEA
6256:  MOVF   FEF,W
6258:  SUBLW  02
625A:  BZ    626C
....................    { 
....................       CloseSocket(ps); 
625C:  MOVFF  2FE,33F
6260:  MOVFF  2FD,33E
6264:  MOVLB  0
6266:  CALL   261A
....................       return; 
626A:  BRA    6364
....................    } 
....................  
....................    // Discard any outstanding data that is to be read. 
....................    TCPDiscard(s); 
626C:  MOVFF  2FC,303
6270:  MOVLB  0
6272:  CALL   5276
....................  
....................    // Send FIN message. 
....................    SendTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       FIN | ACK); 
6276:  MOVLW  01
6278:  MOVLB  2
627A:  ADDWF  xFD,W
627C:  MOVWF  01
627E:  MOVLW  00
6280:  ADDWFC xFE,W
6282:  MOVWF  03
6284:  MOVFF  01,300
6288:  MOVLB  3
628A:  MOVWF  x01
628C:  MOVLW  0B
628E:  MOVLB  2
6290:  ADDWF  xFD,W
6292:  MOVWF  FE9
6294:  MOVLW  00
6296:  ADDWFC xFE,W
6298:  MOVWF  FEA
629A:  MOVFF  FEC,303
629E:  MOVF   FED,F
62A0:  MOVFF  FEF,302
62A4:  MOVLW  0D
62A6:  ADDWF  xFD,W
62A8:  MOVWF  FE9
62AA:  MOVLW  00
62AC:  ADDWFC xFE,W
62AE:  MOVWF  FEA
62B0:  MOVFF  FEC,305
62B4:  MOVF   FED,F
62B6:  MOVFF  FEF,304
62BA:  MOVLW  16
62BC:  ADDWF  xFD,W
62BE:  MOVWF  FE9
62C0:  MOVLW  00
62C2:  ADDWFC xFE,W
62C4:  MOVWF  FEA
62C6:  MOVFF  FEF,306
62CA:  MOVFF  FEC,307
62CE:  MOVFF  FEC,308
62D2:  MOVFF  FEC,309
62D6:  MOVLW  1A
62D8:  ADDWF  xFD,W
62DA:  MOVWF  FE9
62DC:  MOVLW  00
62DE:  ADDWFC xFE,W
62E0:  MOVWF  FEA
62E2:  MOVFF  FEF,30A
62E6:  MOVFF  FEC,30B
62EA:  MOVFF  FEC,30C
62EE:  MOVFF  FEC,30D
62F2:  MOVFF  03,346
62F6:  MOVFF  01,345
62FA:  MOVFF  303,348
62FE:  MOVFF  302,347
6302:  MOVFF  305,34A
6306:  MOVFF  304,349
630A:  MOVFF  309,34E
630E:  MOVFF  308,34D
6312:  MOVFF  307,34C
6316:  MOVFF  306,34B
631A:  MOVFF  30D,352
631E:  MOVFF  30C,351
6322:  MOVFF  30B,350
6326:  MOVFF  30A,34F
632A:  MOVLW  11
632C:  MOVLB  3
632E:  MOVWF  x53
6330:  MOVLW  FF
6332:  MOVWF  x54
6334:  CLRF   x56
6336:  CLRF   x55
6338:  MOVLB  0
633A:  CALL   2A40
....................    //DebugPrint("."); 
....................  
....................    ps->SND_SEQ++; 
633E:  MOVLW  16
6340:  MOVLB  2
6342:  ADDWF  xFD,W
6344:  MOVWF  FE9
6346:  MOVLW  00
6348:  ADDWFC xFE,W
634A:  MOVWF  FEA
634C:  MOVLW  01
634E:  ADDWF  FEE,F
6350:  MOVLW  00
6352:  ADDWFC FEE,F
6354:  ADDWFC FEE,F
6356:  ADDWFC FED,F
....................  
....................    ps->smState = TCP_FIN_WAIT_1; 
6358:  MOVFF  2FD,FE9
635C:  MOVFF  2FE,FEA
6360:  MOVLW  04
6362:  MOVWF  FEF
6364:  MOVLB  0
....................  
....................    return; 
.................... } 
6366:  GOTO   6FA0 (RETURN)
....................  
.................... /********************************************************************* 
.................... * Function:        BOOL TCPFlush(TCP_SOCKET s) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           s       - Socket whose data is to be transmitted. 
.................... * 
.................... * Output:          All and any data associated with this socket 
.................... *                  is marked as ready for transmission. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... BOOL TCPFlush(TCP_SOCKET s) 
.................... { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
*
536A:  MOVLB  3
536C:  MOVF   x31,W
536E:  MULLW  24
5370:  MOVF   FF3,W
5372:  CLRF   03
5374:  ADDLW  5E
5376:  MOVWF  01
5378:  MOVLW  00
537A:  ADDWFC 03,F
537C:  MOVFF  01,332
5380:  MOVFF  03,333
....................  
....................    // Make sure that there is TxBuffer assigned to this socket. 
....................    if ( ps->TxBuffer == INVALID_BUFFER ) 
5384:  MOVLW  0F
5386:  ADDWF  x32,W
5388:  MOVWF  FE9
538A:  MOVLW  00
538C:  ADDWFC x33,W
538E:  MOVWF  FEA
5390:  INCFSZ FEF,W
5392:  BRA    539A
....................       return FALSE; 
5394:  MOVLW  00
5396:  MOVWF  01
5398:  BRA    5530
....................  
....................    if ( ps->Flags.bIsPutReady == FALSE ) 
539A:  MOVLW  23
539C:  ADDWF  x32,W
539E:  MOVWF  FE9
53A0:  MOVLW  00
53A2:  ADDWFC x33,W
53A4:  MOVWF  FEA
53A6:  MOVLW  00
53A8:  BTFSC  FEF.1
53AA:  MOVLW  01
53AC:  ANDLW  01
53AE:  BNZ   53B6
....................       return FALSE; 
53B0:  MOVLW  00
53B2:  MOVWF  01
53B4:  BRA    5530
....................  
....................    TransmitTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       ACK + PSH,      // Use PSH to make sure the end application receives the data right away 
....................       ps->TxBuffer, 
....................       ps->TxCount); 
53B6:  MOVLW  01
53B8:  ADDWF  x32,W
53BA:  MOVWF  01
53BC:  MOVLW  00
53BE:  ADDWFC x33,W
53C0:  MOVWF  03
53C2:  MOVFF  01,334
53C6:  MOVWF  x35
53C8:  MOVLW  0B
53CA:  ADDWF  x32,W
53CC:  MOVWF  FE9
53CE:  MOVLW  00
53D0:  ADDWFC x33,W
53D2:  MOVWF  FEA
53D4:  MOVFF  FEC,337
53D8:  MOVF   FED,F
53DA:  MOVFF  FEF,336
53DE:  MOVLW  0D
53E0:  ADDWF  x32,W
53E2:  MOVWF  FE9
53E4:  MOVLW  00
53E6:  ADDWFC x33,W
53E8:  MOVWF  FEA
53EA:  MOVFF  FEC,339
53EE:  MOVF   FED,F
53F0:  MOVFF  FEF,338
53F4:  MOVLW  16
53F6:  ADDWF  x32,W
53F8:  MOVWF  FE9
53FA:  MOVLW  00
53FC:  ADDWFC x33,W
53FE:  MOVWF  FEA
5400:  MOVFF  FEF,33A
5404:  MOVFF  FEC,33B
5408:  MOVFF  FEC,33C
540C:  MOVFF  FEC,33D
5410:  MOVLW  1A
5412:  ADDWF  x32,W
5414:  MOVWF  FE9
5416:  MOVLW  00
5418:  ADDWFC x33,W
541A:  MOVWF  FEA
541C:  MOVFF  FEF,33E
5420:  MOVFF  FEC,33F
5424:  MOVFF  FEC,340
5428:  MOVFF  FEC,341
542C:  MOVLW  0F
542E:  ADDWF  x32,W
5430:  MOVWF  FE9
5432:  MOVLW  00
5434:  ADDWFC x33,W
5436:  MOVWF  FEA
5438:  MOVFF  FEF,342
543C:  MOVLW  10
543E:  ADDWF  x32,W
5440:  MOVWF  FE9
5442:  MOVLW  00
5444:  ADDWFC x33,W
5446:  MOVWF  FEA
5448:  MOVFF  FEC,344
544C:  MOVF   FED,F
544E:  MOVFF  FEF,343
5452:  MOVFF  03,346
5456:  MOVFF  01,345
545A:  MOVFF  337,348
545E:  MOVFF  336,347
5462:  MOVFF  339,34A
5466:  MOVFF  338,349
546A:  MOVFF  33D,34E
546E:  MOVFF  33C,34D
5472:  MOVFF  33B,34C
5476:  MOVFF  33A,34B
547A:  MOVFF  341,352
547E:  MOVFF  340,351
5482:  MOVFF  33F,350
5486:  MOVFF  33E,34F
548A:  MOVLW  18
548C:  MOVWF  x53
548E:  MOVFF  342,354
5492:  MOVFF  344,356
5496:  MOVFF  343,355
549A:  MOVLB  0
549C:  CALL   2A40
....................  
....................    ps->SND_SEQ += (DWORD)ps->TxCount; 
54A0:  MOVLW  16
54A2:  MOVLB  3
54A4:  ADDWF  x32,W
54A6:  MOVWF  01
54A8:  MOVLW  00
54AA:  ADDWFC x33,W
54AC:  MOVWF  03
54AE:  MOVFF  01,334
54B2:  MOVWF  x35
54B4:  MOVWF  FEA
54B6:  MOVFF  01,FE9
54BA:  MOVFF  FEF,336
54BE:  MOVFF  FEC,337
54C2:  MOVFF  FEC,338
54C6:  MOVFF  FEC,339
54CA:  MOVLW  10
54CC:  ADDWF  x32,W
54CE:  MOVWF  FE9
54D0:  MOVLW  00
54D2:  ADDWFC x33,W
54D4:  MOVWF  FEA
54D6:  MOVFF  FEC,03
54DA:  MOVF   FED,F
54DC:  MOVFF  FEF,00
54E0:  MOVFF  03,01
54E4:  CLRF   02
54E6:  CLRF   03
54E8:  MOVF   x36,W
54EA:  ADDWF  00,F
54EC:  MOVF   x37,W
54EE:  ADDWFC 01,F
54F0:  MOVF   x38,W
54F2:  ADDWFC 02,F
54F4:  MOVF   x39,W
54F6:  ADDWFC 03,F
54F8:  MOVFF  335,FEA
54FC:  MOVFF  334,FE9
5500:  MOVFF  00,FEF
5504:  MOVFF  01,FEC
5508:  MOVFF  02,FEC
550C:  MOVFF  03,FEC
....................    ps->Flags.bIsPutReady       = FALSE; 
5510:  MOVLW  23
5512:  ADDWF  x32,W
5514:  MOVWF  FE9
5516:  MOVLW  00
5518:  ADDWFC x33,W
551A:  MOVWF  FEA
551C:  BCF    FEF.1
....................    ps->Flags.bIsTxInProgress   = FALSE; 
551E:  MOVLW  23
5520:  ADDWF  x32,W
5522:  MOVWF  FE9
5524:  MOVLW  00
5526:  ADDWFC x33,W
5528:  MOVWF  FEA
552A:  BCF    FEF.4
....................  
.................... #if TCP_NO_WAIT_FOR_ACK 
....................    if(ps->TxBuffer != INVALID_BUFFER) 
....................    { 
....................       MACDiscardTx(ps->TxBuffer); 
....................       ps->TxBuffer        = INVALID_BUFFER; 
....................    } 
....................    ps->Flags.bIsPutReady       = TRUE; 
.................... #endif 
....................  
....................    return TRUE; 
552C:  MOVLW  01
552E:  MOVWF  01
.................... } 
5530:  MOVLB  0
5532:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' is free to transmit 
....................  *                  FALSE if socket 's' is not free to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Each socket maintains only transmit buffer. 
....................  *                  Hence until a data packet is acknowledeged by 
....................  *                  remote node, socket will not be ready for 
....................  *                  next transmission. 
....................  *                  All control transmission such as Connect, 
....................  *                  Disconnect do not consume/reserve any transmit 
....................  *                  buffer. 
....................  ********************************************************************/ 
.................... BOOL TCPIsPutReady(TCP_SOCKET s) 
.................... { 
....................    if(TCB[s].RemoteWindow == 0) 
*
52C4:  MOVLB  3
52C6:  MOVF   x1F,W
52C8:  MULLW  24
52CA:  MOVF   FF3,W
52CC:  CLRF   x21
52CE:  MOVWF  x20
52D0:  MOVLW  14
52D2:  ADDWF  x20,W
52D4:  MOVWF  01
52D6:  MOVLW  00
52D8:  ADDWFC x21,W
52DA:  MOVWF  03
52DC:  MOVF   01,W
52DE:  ADDLW  5E
52E0:  MOVWF  FE9
52E2:  MOVLW  00
52E4:  ADDWFC 03,W
52E6:  MOVWF  FEA
52E8:  MOVFF  FEC,321
52EC:  MOVF   FED,F
52EE:  MOVFF  FEF,320
52F2:  MOVF   x20,F
52F4:  BNZ   5300
52F6:  MOVF   x21,F
52F8:  BNZ   5300
....................       return FALSE; 
52FA:  MOVLW  00
52FC:  MOVWF  01
52FE:  BRA    535E
....................  
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER ) 
5300:  MOVF   x1F,W
5302:  MULLW  24
5304:  MOVF   FF3,W
5306:  CLRF   x21
5308:  MOVWF  x20
530A:  MOVLW  0F
530C:  ADDWF  x20,W
530E:  MOVWF  01
5310:  MOVLW  00
5312:  ADDWFC x21,W
5314:  MOVWF  03
5316:  MOVF   01,W
5318:  ADDLW  5E
531A:  MOVWF  FE9
531C:  MOVLW  00
531E:  ADDWFC 03,W
5320:  MOVWF  FEA
5322:  INCFSZ FEF,W
5324:  BRA    5336
....................       return IPIsTxReady(FALSE); 
5326:  CLRF   x7D
5328:  MOVLB  0
532A:  CALL   271E
532E:  MOVF   01,W
5330:  MOVLB  3
5332:  BRA    535E
....................    else 
5334:  BRA    535E
....................       return TCB[s].Flags.bIsPutReady; 
5336:  MOVF   x1F,W
5338:  MULLW  24
533A:  MOVF   FF3,W
533C:  CLRF   x21
533E:  MOVWF  x20
5340:  MOVLW  23
5342:  ADDWF  x20,F
5344:  MOVLW  00
5346:  ADDWFC x21,F
5348:  MOVLW  5E
534A:  ADDWF  x20,W
534C:  MOVWF  FE9
534E:  MOVLW  00
5350:  ADDWFC x21,W
5352:  MOVWF  FEA
5354:  MOVLW  00
5356:  BTFSC  FEF.1
5358:  MOVLW  01
535A:  MOVWF  01
535C:  BRA    535E
.................... } 
535E:  MOVLB  0
5360:  RETLW  00
....................  
....................  
.................... int16 TCPPutAvailable(TCP_SOCKET s) 
.................... { 
....................    int16 txCount, txAvail; 
....................  
....................    if (!TCPIsPutReady(s)) 
*
57BA:  MOVFF  31A,31F
57BE:  RCALL  52C4
57C0:  MOVF   01,F
57C2:  BNZ   57CC
....................       return(0); 
57C4:  MOVLW  00
57C6:  MOVWF  01
57C8:  MOVWF  02
57CA:  BRA    58B2
....................  
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER ) 
57CC:  MOVLB  3
57CE:  MOVF   x1A,W
57D0:  MULLW  24
57D2:  MOVF   FF3,W
57D4:  CLRF   x20
57D6:  MOVWF  x1F
57D8:  MOVLW  0F
57DA:  ADDWF  x1F,W
57DC:  MOVWF  01
57DE:  MOVLW  00
57E0:  ADDWFC x20,W
57E2:  MOVWF  03
57E4:  MOVF   01,W
57E6:  ADDLW  5E
57E8:  MOVWF  FE9
57EA:  MOVLW  00
57EC:  ADDWFC 03,W
57EE:  MOVWF  FEA
57F0:  INCFSZ FEF,W
57F2:  BRA    57FA
....................       txCount = 0; 
57F4:  CLRF   x1C
57F6:  CLRF   x1B
....................    else 
57F8:  BRA    582A
....................       txCount = TCB[s].TxCount; 
57FA:  MOVF   x1A,W
57FC:  MULLW  24
57FE:  MOVF   FF3,W
5800:  CLRF   x20
5802:  MOVWF  x1F
5804:  MOVLW  10
5806:  ADDWF  x1F,W
5808:  MOVWF  01
580A:  MOVLW  00
580C:  ADDWFC x20,W
580E:  MOVWF  03
5810:  MOVF   01,W
5812:  ADDLW  5E
5814:  MOVWF  FE9
5816:  MOVLW  00
5818:  ADDWFC 03,W
581A:  MOVWF  FEA
581C:  MOVFF  FEC,03
5820:  MOVF   FED,F
5822:  MOVFF  FEF,31B
5826:  MOVFF  03,31C
....................  
....................    txAvail = MAX_TCP_DATA_LEN - txCount; 
582A:  MOVLW  CA
582C:  BSF    FD8.0
582E:  SUBFWB x1B,W
5830:  MOVWF  x1D
5832:  MOVLW  03
5834:  SUBFWB x1C,W
5836:  MOVWF  x1E
....................  
....................    txAvail = txAvail > TCB[s].RemoteWindow ? TCB[s].RemoteWindow : txAvail; 
5838:  MOVF   x1A,W
583A:  MULLW  24
583C:  MOVF   FF3,W
583E:  CLRF   x20
5840:  MOVWF  x1F
5842:  MOVLW  14
5844:  ADDWF  x1F,W
5846:  MOVWF  01
5848:  MOVLW  00
584A:  ADDWFC x20,W
584C:  MOVWF  03
584E:  MOVF   01,W
5850:  ADDLW  5E
5852:  MOVWF  FE9
5854:  MOVLW  00
5856:  ADDWFC 03,W
5858:  MOVWF  FEA
585A:  MOVFF  FEC,03
585E:  MOVF   FED,F
5860:  MOVFF  FEF,01
5864:  MOVF   03,W
5866:  SUBWF  x1E,W
5868:  BNC   589E
586A:  BNZ   5872
586C:  MOVF   x1D,W
586E:  SUBWF  01,W
5870:  BC    589E
5872:  MOVF   x1A,W
5874:  MULLW  24
5876:  MOVF   FF3,W
5878:  CLRF   x20
587A:  MOVWF  x1F
587C:  MOVLW  14
587E:  ADDWF  x1F,W
5880:  MOVWF  01
5882:  MOVLW  00
5884:  ADDWFC x20,W
5886:  MOVWF  03
5888:  MOVF   01,W
588A:  ADDLW  5E
588C:  MOVWF  FE9
588E:  MOVLW  00
5890:  ADDWFC 03,W
5892:  MOVWF  FEA
5894:  MOVFF  FEC,03
5898:  MOVF   FED,F
589A:  MOVF   FEF,W
589C:  BRA    58A4
589E:  MOVFF  31E,03
58A2:  MOVF   x1D,W
58A4:  MOVWF  x1D
58A6:  MOVFF  03,31E
....................  
....................    return(txAvail); 
58AA:  MOVFF  31D,01
58AE:  MOVFF  31E,02
58B2:  MOVLB  0
.................... } 
58B4:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s      - socket to use 
....................  *                  ptr    - Block of data to send over TCP 
....................  *                  len    - number of bytes to send over TCP 
....................  * 
....................  * Output:          Total number of bytes written to TCP.  If this value 
....................  *                  is not equal len that means we ran out of space in the 
....................  *                  TX buffer -OR- we ran out of space in the remote node's 
....................  *                  window.  In either case you will have to continue later. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len) 
.................... { 
....................    SOCKET_INFO* ps; 
....................    WORD n; 
....................  
....................    ps = &TCB[s]; 
....................  
....................    // Make sure that the remote node is able to accept our data 
....................    if(ps->RemoteWindow == 0) 
....................       return 0; 
....................  
....................    if(ps->TxBuffer == INVALID_BUFFER) 
....................    { 
....................       ps->TxBuffer = MACGetTxBuffer(FALSE); 
....................  
....................       // Check to make sure that we received a TX Buffer 
....................       if(ps->TxBuffer == INVALID_BUFFER) 
....................          return 0; 
....................  
....................       ps->TxCount = 0; 
....................  
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER)); 
....................    } 
....................  
....................    n = TCPPutAvailable(s); 
....................  
....................    ps->Flags.bIsTxInProgress = TRUE; 
....................  
....................    while (n--) 
....................    { 
....................       MACPut(*ptr++); 
....................       ps->RemoteWindow -= 1; 
....................       ps->TxCount += 1; 
....................    } 
....................  
....................    if(ps->TxCount >= MAX_TCP_DATA_LEN) 
....................       TCPFlush(s); 
....................  
....................    return(len); 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE *ptr, WORD len) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s      - socket to use 
....................  *                  ptr    - Block of data to send over TCP 
....................  *                  len    - number of bytes to send over TCP 
....................  * 
....................  * Output:          Total number of bytes written to TCP.  If this value 
....................  *                  is not equal len that means we ran out of space in the 
....................  *                  TX buffer and you will have to continue later. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPPut(TCP_SOCKET s, BYTE byte) 
.................... { 
....................    SOCKET_INFO* ps; 
....................    WORD tempCount; 
....................  
....................    ps = &TCB[s]; 
*
5534:  MOVLB  3
5536:  MOVF   x2B,W
5538:  MULLW  24
553A:  MOVF   FF3,W
553C:  CLRF   03
553E:  ADDLW  5E
5540:  MOVWF  01
5542:  MOVLW  00
5544:  ADDWFC 03,F
5546:  MOVFF  01,32D
554A:  MOVFF  03,32E
....................  
....................    // Make sure that the remote node is able to accept our data 
....................    if(ps->RemoteWindow == 0) 
554E:  MOVLW  14
5550:  ADDWF  x2D,W
5552:  MOVWF  FE9
5554:  MOVLW  00
5556:  ADDWFC x2E,W
5558:  MOVWF  FEA
555A:  MOVFF  FEC,332
555E:  MOVF   FED,F
5560:  MOVFF  FEF,331
5564:  MOVF   x31,F
5566:  BNZ   5572
5568:  MOVF   x32,F
556A:  BNZ   5572
....................       return FALSE; 
556C:  MOVLW  00
556E:  MOVWF  01
5570:  BRA    5678
....................  
....................    if(ps->TxBuffer == INVALID_BUFFER) 
5572:  MOVLW  0F
5574:  ADDWF  x2D,W
5576:  MOVWF  FE9
5578:  MOVLW  00
557A:  ADDWFC x2E,W
557C:  MOVWF  FEA
557E:  INCFSZ FEF,W
5580:  BRA    55F4
....................    { 
....................       ps->TxBuffer = MACGetTxBuffer(FALSE); 
5582:  MOVLW  0F
5584:  ADDWF  x2D,W
5586:  MOVWF  01
5588:  MOVLW  00
558A:  ADDWFC x2E,W
558C:  MOVWF  03
558E:  MOVFF  01,331
5592:  MOVWF  x32
5594:  CLRF   x7D
5596:  MOVLB  0
5598:  CALL   162C
559C:  MOVFF  332,FEA
55A0:  MOVFF  331,FE9
55A4:  MOVFF  01,FEF
....................  
....................       // Check to make sure that we received a TX Buffer 
....................       if(ps->TxBuffer == INVALID_BUFFER) 
55A8:  MOVLW  0F
55AA:  MOVLB  3
55AC:  ADDWF  x2D,W
55AE:  MOVWF  FE9
55B0:  MOVLW  00
55B2:  ADDWFC x2E,W
55B4:  MOVWF  FEA
55B6:  INCFSZ FEF,W
55B8:  BRA    55C0
....................          return FALSE; 
55BA:  MOVLW  00
55BC:  MOVWF  01
55BE:  BRA    5678
....................  
....................       ps->TxCount = 0; 
55C0:  MOVLW  10
55C2:  ADDWF  x2D,W
55C4:  MOVWF  FE9
55C6:  MOVLW  00
55C8:  ADDWFC x2E,W
55CA:  MOVWF  FEA
55CC:  CLRF   FEC
55CE:  MOVF   FED,F
55D0:  CLRF   FEF
....................  
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER)); 
55D2:  MOVLW  0F
55D4:  ADDWF  x2D,W
55D6:  MOVWF  FE9
55D8:  MOVLW  00
55DA:  ADDWFC x2E,W
55DC:  MOVWF  FEA
55DE:  MOVFF  FEF,331
55E2:  MOVFF  331,396
55E6:  CLRF   x98
55E8:  MOVLW  28
55EA:  MOVWF  x97
55EC:  MOVLB  0
55EE:  CALL   1648
55F2:  MOVLB  3
....................    } 
....................  
....................    ps->Flags.bIsTxInProgress = TRUE; 
55F4:  MOVLW  23
55F6:  ADDWF  x2D,W
55F8:  MOVWF  FE9
55FA:  MOVLW  00
55FC:  ADDWFC x2E,W
55FE:  MOVWF  FEA
5600:  BSF    FEF.4
....................  
....................    MACPut(byte); 
5602:  MOVFF  32C,3A0
5606:  MOVLB  0
5608:  CALL   16D2
....................    ps->RemoteWindow--; 
560C:  MOVLW  14
560E:  MOVLB  3
5610:  ADDWF  x2D,W
5612:  MOVWF  FE9
5614:  MOVLW  00
5616:  ADDWFC x2E,W
5618:  MOVWF  FEA
561A:  MOVLW  FF
561C:  ADDWF  FEF,F
561E:  BC    5624
5620:  MOVF   FEE,F
5622:  DECF   FED,F
....................  
....................    tempCount = ps->TxCount; 
5624:  MOVLW  10
5626:  ADDWF  x2D,W
5628:  MOVWF  FE9
562A:  MOVLW  00
562C:  ADDWFC x2E,W
562E:  MOVWF  FEA
5630:  MOVFF  FEC,03
5634:  MOVF   FED,F
5636:  MOVFF  FEF,32F
563A:  MOVFF  03,330
....................    tempCount++; 
563E:  INCF   x2F,F
5640:  BTFSC  FD8.2
5642:  INCF   x30,F
....................    ps->TxCount = tempCount; 
5644:  MOVLW  10
5646:  ADDWF  x2D,W
5648:  MOVWF  FE9
564A:  MOVLW  00
564C:  ADDWFC x2E,W
564E:  MOVWF  FEA
5650:  MOVFF  330,FEC
5654:  MOVF   FED,F
5656:  MOVFF  32F,FEF
....................    if(tempCount >= MAX_TCP_DATA_LEN) 
565A:  MOVF   x30,W
565C:  SUBLW  02
565E:  BC    5674
5660:  XORLW  FF
5662:  BNZ   566A
5664:  MOVF   x2F,W
5666:  SUBLW  C9
5668:  BC    5674
....................       TCPFlush(s); 
566A:  MOVFF  32B,331
566E:  MOVLB  0
5670:  RCALL  536A
5672:  MOVLB  3
....................  
....................    return TRUE; 
5674:  MOVLW  01
5676:  MOVWF  01
.................... } 
5678:  MOVLB  0
567A:  GOTO   5688 (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket 
....................  * 
....................  * Output:          TRUE if socket received data was discarded 
....................  *                  FALSE if socket received data was already 
....................  *                          discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPDiscard(TCP_SOCKET s) 
.................... { 
....................     SOCKET_INFO* ps; 
....................  
....................     ps = &TCB[s]; 
*
5276:  MOVLB  3
5278:  MOVF   x03,W
527A:  MULLW  24
527C:  MOVF   FF3,W
527E:  CLRF   03
5280:  ADDLW  5E
5282:  MOVWF  01
5284:  MOVLW  00
5286:  ADDWFC 03,F
5288:  MOVFF  01,304
528C:  MOVFF  03,305
....................  
....................     // This socket must contain data for it to be discarded. 
....................     if ( !ps->Flags.bIsGetReady ) 
5290:  MOVLW  23
5292:  ADDWF  x04,W
5294:  MOVWF  FE9
5296:  MOVLW  00
5298:  ADDWFC x05,W
529A:  MOVWF  FEA
529C:  BTFSC  FEF.3
529E:  BRA    52A6
....................         return FALSE; 
52A0:  MOVLW  00
52A2:  MOVWF  01
52A4:  BRA    52C0
....................  
....................     MACDiscardRx(); 
52A6:  MOVLB  0
52A8:  CALL   1256
....................     ps->Flags.bIsGetReady = FALSE; 
52AC:  MOVLW  23
52AE:  MOVLB  3
52B0:  ADDWF  x04,W
52B2:  MOVWF  FE9
52B4:  MOVLW  00
52B6:  ADDWFC x05,W
52B8:  MOVWF  FEA
52BA:  BCF    FEF.3
....................  
....................     return TRUE; 
52BC:  MOVLW  01
52BE:  MOVWF  01
.................... } 
52C0:  MOVLB  0
52C2:  RETLW  00
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer, 
....................  *                                      WORD count) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  buffer  - Buffer to hold received data. 
....................  *                  count   - Buffer length 
....................  * 
....................  * Output:          Number of bytes loaded into buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count) 
.................... { 
....................     SOCKET_INFO *ps; 
....................  
....................     ps = &TCB[s]; 
....................  
....................     if ( ps->Flags.bIsGetReady ) 
....................     { 
....................         if ( ps->Flags.bFirstRead ) 
....................         { 
....................          // Position read pointer to begining of TCP data 
....................             IPSetRxBuffer(sizeof(TCP_HEADER)); 
....................  
....................             ps->Flags.bFirstRead = FALSE; 
....................         } 
....................  
....................         ps->Flags.bIsTxInProgress = TRUE; 
....................  
....................         return MACGetArray(buff, count); 
....................     } 
....................     else 
....................         return 0; 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  byte    - Pointer to a byte. 
....................  * 
....................  * Output:          TRUE if a byte was read. 
....................  *                  FALSE if byte was not read. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPGet(TCP_SOCKET s, BYTE *data) 
.................... { 
....................     SOCKET_INFO* ps; 
....................  
....................     ps = &TCB[s]; 
*
4116:  MOVLB  2
4118:  MOVF   xFC,W
411A:  MULLW  24
411C:  MOVF   FF3,W
411E:  CLRF   03
4120:  ADDLW  5E
4122:  MOVWF  01
4124:  MOVLW  00
4126:  ADDWFC 03,F
4128:  MOVFF  01,2FF
412C:  MOVFF  03,300
....................  
....................     if ( ps->Flags.bIsGetReady ) 
4130:  MOVLW  23
4132:  ADDWF  xFF,W
4134:  MOVWF  FE9
4136:  MOVLW  00
4138:  MOVLB  3
413A:  ADDWFC x00,W
413C:  MOVWF  FEA
413E:  BTFSS  FEF.3
4140:  BRA    41F4
....................     { 
....................         if ( ps->Flags.bFirstRead ) 
4142:  MOVLW  23
4144:  MOVLB  2
4146:  ADDWF  xFF,W
4148:  MOVWF  FE9
414A:  MOVLW  00
414C:  MOVLB  3
414E:  ADDWFC x00,W
4150:  MOVWF  FEA
4152:  BTFSS  FEF.2
4154:  BRA    4174
....................         { 
....................             // Position read pointer to begining of correct 
....................             // buffer. 
....................             IPSetRxBuffer(sizeof(TCP_HEADER)); 
4156:  CLRF   x22
4158:  MOVLW  14
415A:  MOVWF  x21
415C:  MOVLB  0
415E:  CALL   21C0
....................  
....................             ps->Flags.bFirstRead = FALSE; 
4162:  MOVLW  23
4164:  MOVLB  2
4166:  ADDWF  xFF,W
4168:  MOVWF  FE9
416A:  MOVLW  00
416C:  MOVLB  3
416E:  ADDWFC x00,W
4170:  MOVWF  FEA
4172:  BCF    FEF.2
....................         } 
....................  
....................         if ( ps->RxCount == 0 ) 
4174:  MOVLW  12
4176:  MOVLB  2
4178:  ADDWF  xFF,W
417A:  MOVWF  FE9
417C:  MOVLW  00
417E:  MOVLB  3
4180:  ADDWFC x00,W
4182:  MOVWF  FEA
4184:  MOVFF  FEC,302
4188:  MOVF   FED,F
418A:  MOVFF  FEF,301
418E:  MOVF   x01,F
4190:  BNZ   41B4
4192:  MOVF   x02,F
4194:  BNZ   41B4
....................         { 
....................             MACDiscardRx(); 
4196:  MOVLB  0
4198:  CALL   1256
....................             ps->Flags.bIsGetReady = FALSE; 
419C:  MOVLW  23
419E:  MOVLB  2
41A0:  ADDWF  xFF,W
41A2:  MOVWF  FE9
41A4:  MOVLW  00
41A6:  MOVLB  3
41A8:  ADDWFC x00,W
41AA:  MOVWF  FEA
41AC:  BCF    FEF.3
....................             return FALSE; 
41AE:  MOVLW  00
41B0:  MOVWF  01
41B2:  BRA    41F8
....................         } 
....................  
....................          ps->RxCount--; 
41B4:  MOVLW  12
41B6:  MOVLB  2
41B8:  ADDWF  xFF,W
41BA:  MOVWF  FE9
41BC:  MOVLW  00
41BE:  MOVLB  3
41C0:  ADDWFC x00,W
41C2:  MOVWF  FEA
41C4:  MOVLW  FF
41C6:  ADDWF  FEF,F
41C8:  BC    41CE
41CA:  MOVF   FEE,F
41CC:  DECF   FED,F
....................          *data = MACGet(); 
41CE:  MOVFF  2FE,03
41D2:  MOVFF  2FD,301
41D6:  MOVFF  2FE,302
41DA:  MOVLB  0
41DC:  CALL   204C
41E0:  MOVFF  302,FEA
41E4:  MOVFF  301,FE9
41E8:  MOVFF  01,FEF
....................         return TRUE; 
41EC:  MOVLW  01
41EE:  MOVWF  01
41F0:  MOVLB  3
41F2:  BRA    41F8
....................     } 
....................     return FALSE; 
41F4:  MOVLW  00
41F6:  MOVWF  01
.................... } 
41F8:  MOVLB  0
41FA:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' contains any data. 
....................  *                  FALSE if socket 's' does not contain any data. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPIsGetReady(TCP_SOCKET s) 
.................... { 
....................     /* 
....................      * A socket is said to be "Get" ready when it has already 
....................      * received some data.  Sometime, a socket may be closed, 
....................      * but it still may contain data.  Thus in order to ensure 
....................      * reuse of a socket, caller must make sure that it reads 
....................      * a socket, if is ready. 
....................      */ 
....................     return (TCB[s].Flags.bIsGetReady ); 
*
40EA:  MOVLB  2
40EC:  MOVF   xFC,W
40EE:  MULLW  24
40F0:  MOVF   FF3,W
40F2:  CLRF   xFE
40F4:  MOVWF  xFD
40F6:  MOVLW  23
40F8:  ADDWF  xFD,F
40FA:  MOVLW  00
40FC:  ADDWFC xFE,F
40FE:  MOVLW  5E
4100:  ADDWF  xFD,W
4102:  MOVWF  FE9
4104:  MOVLW  00
4106:  ADDWFC xFE,W
4108:  MOVWF  FEA
410A:  MOVLW  00
410C:  BTFSC  FEF.3
410E:  MOVLW  01
4110:  MOVWF  01
.................... } 
4112:  MOVLB  0
4114:  RETLW  00
....................  
.................... //// internal functions ///// 
....................  
.................... void DebugTCPDisplayState(TCP_STATE st) 
.................... { 
....................    switch(st) 
....................    { 
....................       case TCP_LISTEN:        debug_tcp("LISTEN"); break; 
....................       case TCP_SYN_SENT:      debug_tcp("SYN_SENT"); break; 
....................       case TCP_SYN_RECEIVED:  debug_tcp("SYN_RECVD"); break; 
....................       case TCP_ESTABLISHED:   debug_tcp("ESTABLISHED"); break; 
....................       case TCP_FIN_WAIT_1:    debug_tcp("FIN_WAIT_1"); break; 
....................       case TCP_FIN_WAIT_2:    debug_tcp("FIN_WAIT_2"); break; 
....................       case TCP_CLOSING:       debug_tcp("CLOSING"); break; 
....................       case TCP_TIME_WAIT:     debug_tcp("TIME_WAIT"); break; 
....................       case TCP_CLOSE_WAIT:    debug_tcp("CLOSE_WAIT"); break; 
....................       case TCP_LAST_ACK:      debug_tcp("LAST_ACK"); break; 
....................       case TCP_CLOSED:        debug_tcp("CLOSED"); break; 
....................       default:                debug_tcp("UNKNOWN %U",st); break; 
....................    } 
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPTick(void) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           None 
.................... * 
.................... * Output:          Each socket FSM is executed for any timeout 
.................... *                  situation. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... void TCPTick(void) 
.................... { 
....................    TCP_SOCKET s; 
....................    TICKTYPE diffTicks; 
....................    TICKTYPE tick; 
....................    SOCKET_INFO* ps; 
....................    DWORD seq; 
....................    BYTE flags; 
....................    //BYTE debugLastState; 
....................  
....................    flags = 0x00; 
*
3BD8:  MOVLB  2
3BDA:  CLRF   xFF
....................    // Periodically all "not closed" sockets must perform timed operations 
....................    for(s = 0; s < MAX_SOCKETS; s++) 
3BDC:  CLRF   xF4
3BDE:  MOVF   xF4,W
3BE0:  SUBLW  04
3BE2:  BTFSS  FD8.0
3BE4:  BRA    4084
....................    { 
....................       ps = &TCB[s]; 
3BE6:  MOVF   xF4,W
3BE8:  MULLW  24
3BEA:  MOVF   FF3,W
3BEC:  CLRF   03
3BEE:  ADDLW  5E
3BF0:  MOVWF  01
3BF2:  MOVLW  00
3BF4:  ADDWFC 03,F
3BF6:  MOVFF  01,2F9
3BFA:  MOVFF  03,2FA
....................  
....................       //debugLastState = TCB[s].smState; 
....................  
....................       if ( ps->Flags.bIsGetReady || ps->Flags.bIsTxInProgress ) 
3BFE:  MOVLW  23
3C00:  ADDWF  xF9,W
3C02:  MOVWF  FE9
3C04:  MOVLW  00
3C06:  ADDWFC xFA,W
3C08:  MOVWF  FEA
3C0A:  BTFSC  FEF.3
3C0C:  BRA    3C1E
3C0E:  MOVLW  23
3C10:  ADDWF  xF9,W
3C12:  MOVWF  FE9
3C14:  MOVLW  00
3C16:  ADDWFC xFA,W
3C18:  MOVWF  FEA
3C1A:  BTFSS  FEF.4
3C1C:  BRA    3C20
....................          continue; 
3C1E:  BRA    4080
....................  
....................  
....................       // Closed or Passively Listening socket do not care 
....................       // about timeout conditions. 
....................       if ( (ps->smState == TCP_CLOSED) || 
....................          (ps->smState == TCP_LISTEN && 
....................          ps->Flags.bServer == TRUE) ) 
3C20:  MOVFF  2F9,FE9
3C24:  MOVFF  2FA,FEA
3C28:  MOVF   FEF,W
3C2A:  SUBLW  0A
3C2C:  BZ    3C52
3C2E:  MOVFF  2F9,FE9
3C32:  MOVFF  2FA,FEA
3C36:  MOVF   FEF,F
3C38:  BNZ   3C54
3C3A:  MOVLW  23
3C3C:  ADDWF  xF9,W
3C3E:  MOVWF  FE9
3C40:  MOVLW  00
3C42:  ADDWFC xFA,W
3C44:  MOVWF  FEA
3C46:  MOVLW  00
3C48:  BTFSC  FEF.0
3C4A:  MOVLW  01
3C4C:  ANDLW  01
3C4E:  SUBLW  01
3C50:  BNZ   3C54
....................          continue; 
3C52:  BRA    4080
....................  
....................       //TODO: review this 
....................       //DSR ADD 063004 
....................         //i do this because if i am a server, i don't want to timeout. 
....................       if ( (ps->smState == TCP_ESTABLISHED) && (ps->Flags.bServer == TRUE) ) 
3C54:  MOVFF  2F9,FE9
3C58:  MOVFF  2FA,FEA
3C5C:  MOVF   FEF,W
3C5E:  SUBLW  03
3C60:  BNZ   3C7C
3C62:  MOVLW  23
3C64:  ADDWF  xF9,W
3C66:  MOVWF  FE9
3C68:  MOVLW  00
3C6A:  ADDWFC xFA,W
3C6C:  MOVWF  FEA
3C6E:  MOVLW  00
3C70:  BTFSC  FEF.0
3C72:  MOVLW  01
3C74:  ANDLW  01
3C76:  SUBLW  01
3C78:  BNZ   3C7C
....................          continue; 
3C7A:  BRA    4080
....................  
....................  
....................       tick = TickGet(); 
3C7C:  MOVLB  0
3C7E:  CALL   2600
3C82:  MOVFF  02,2F8
3C86:  MOVFF  01,2F7
....................  
....................       // Calculate timeout value for this socket. 
....................       diffTicks = TickGetDiff(tick, ps->startTick); 
3C8A:  MOVLW  1F
3C8C:  MOVLB  2
3C8E:  ADDWF  xF9,W
3C90:  MOVWF  FE9
3C92:  MOVLW  00
3C94:  ADDWFC xFA,W
3C96:  MOVWF  FEA
3C98:  MOVFF  FEC,03
3C9C:  MOVF   FED,F
3C9E:  MOVFF  FEF,01
3CA2:  MOVF   xF8,W
3CA4:  SUBWF  03,W
3CA6:  BNC   3CB0
3CA8:  BNZ   3CB4
3CAA:  MOVF   01,W
3CAC:  SUBWF  xF7,W
3CAE:  BNC   3CB4
3CB0:  MOVLW  00
3CB2:  BRA    3CB6
3CB4:  MOVLW  01
3CB6:  CLRF   03
3CB8:  IORWF  03,W
3CBA:  BZ    3CFE
3CBC:  MOVLW  1F
3CBE:  ADDWF  xF9,W
3CC0:  MOVWF  FE9
3CC2:  MOVLW  00
3CC4:  ADDWFC xFA,W
3CC6:  MOVWF  FEA
3CC8:  MOVFF  FEC,03
3CCC:  MOVF   FED,F
3CCE:  MOVF   FEF,W
3CD0:  SUBLW  FF
3CD2:  MOVLB  3
3CD4:  MOVWF  x00
3CD6:  MOVLW  FF
3CD8:  SUBFWB 03,W
3CDA:  MOVWF  x01
3CDC:  MOVLB  2
3CDE:  MOVF   xF7,W
3CE0:  MOVLB  3
3CE2:  ADDWF  x00,F
3CE4:  MOVLB  2
3CE6:  MOVF   xF8,W
3CE8:  MOVLB  3
3CEA:  ADDWFC x01,F
3CEC:  MOVLW  01
3CEE:  ADDWF  x00,W
3CF0:  MOVWF  01
3CF2:  MOVLW  00
3CF4:  ADDWFC x01,W
3CF6:  MOVWF  03
3CF8:  MOVF   01,W
3CFA:  BRA    3D1E
3CFC:  MOVLB  2
3CFE:  MOVLW  1F
3D00:  ADDWF  xF9,W
3D02:  MOVWF  FE9
3D04:  MOVLW  00
3D06:  ADDWFC xFA,W
3D08:  MOVWF  FEA
3D0A:  MOVFF  FEC,03
3D0E:  MOVF   FED,F
3D10:  MOVF   FEF,W
3D12:  SUBWF  xF7,W
3D14:  MOVWF  00
3D16:  MOVF   03,W
3D18:  SUBWFB xF8,W
3D1A:  MOVWF  03
3D1C:  MOVF   00,W
3D1E:  MOVLB  2
3D20:  MOVWF  xF5
3D22:  MOVFF  03,2F6
....................  
....................       // If timeout has not occured, do not do anything. 
....................       if(diffTicks <= ps->TimeOut) 
3D26:  MOVLW  21
3D28:  ADDWF  xF9,W
3D2A:  MOVWF  FE9
3D2C:  MOVLW  00
3D2E:  ADDWFC xFA,W
3D30:  MOVWF  FEA
3D32:  MOVFF  FEC,03
3D36:  MOVF   FED,F
3D38:  MOVFF  FEF,01
3D3C:  MOVF   xF6,W
3D3E:  SUBWF  03,W
3D40:  BNC   3D4C
3D42:  BNZ   3D4A
3D44:  MOVF   xF5,W
3D46:  SUBWF  01,W
3D48:  BNC   3D4C
....................          continue; 
3D4A:  BRA    4080
....................  
....................       // Most states require retransmission, so check for transmitter 
....................       // availability right here - common for all. 
....................       if(!IPIsTxReady(TRUE)) 
3D4C:  MOVLW  01
3D4E:  MOVLB  3
3D50:  MOVWF  x7D
3D52:  MOVLB  0
3D54:  CALL   271E
3D58:  MOVF   01,F
3D5A:  BNZ   3D5E
....................          return; 
3D5C:  BRA    4084
....................  
....................       // Restart timeout reference. 
....................       ps->startTick = TickGet(); 
3D5E:  MOVLW  1F
3D60:  MOVLB  2
3D62:  ADDWF  xF9,W
3D64:  MOVWF  01
3D66:  MOVLW  00
3D68:  ADDWFC xFA,W
3D6A:  MOVWF  03
3D6C:  MOVFF  01,300
3D70:  MOVLB  3
3D72:  MOVWF  x01
3D74:  MOVLB  0
3D76:  CALL   2600
3D7A:  MOVFF  301,FEA
3D7E:  MOVFF  300,FE9
3D82:  MOVFF  02,FEC
3D86:  MOVF   FED,F
3D88:  MOVFF  01,FEF
....................  
....................       // Update timeout value if there is need to wait longer. 
....................       ps->TimeOut <<= 1; 
3D8C:  MOVLW  21
3D8E:  MOVLB  2
3D90:  ADDWF  xF9,W
3D92:  MOVWF  FE9
3D94:  MOVLW  00
3D96:  ADDWFC xFA,W
3D98:  MOVWF  FEA
3D9A:  BCF    FD8.0
3D9C:  RLCF   FEF,W
3D9E:  MOVWF  02
3DA0:  RLCF   FEC,W
3DA2:  MOVWF  03
3DA4:  MOVF   02,W
3DA6:  MOVF   FED,F
3DA8:  MOVWF  FEF
3DAA:  MOVFF  03,FEC
....................  
....................       // This will be one more attempt. 
....................       ps->RetryCount++; 
3DAE:  MOVLW  1E
3DB0:  ADDWF  xF9,W
3DB2:  MOVWF  FE9
3DB4:  MOVLW  00
3DB6:  ADDWFC xFA,W
3DB8:  MOVWF  FEA
3DBA:  INCF   FEF,F
....................  
....................       // A timeout has occured.  Respond to this timeout condition 
....................       // depending on what state this socket is in. 
....................       switch(ps->smState) 
....................       { 
3DBC:  MOVFF  2F9,FE9
3DC0:  MOVFF  2FA,FEA
3DC4:  MOVLW  01
3DC6:  SUBWF  FEF,W
3DC8:  ADDLW  F7
3DCA:  BTFSC  FD8.0
3DCC:  BRA    3F5E
3DCE:  ADDLW  09
3DD0:  MOVLB  0
3DD2:  GOTO   408A
....................       case TCP_SYN_SENT: 
....................          // Keep sending SYN until we hear from remote node. 
....................          // This may be for infinite time, in that case 
....................          // caller must detect it and do something. 
....................          // Bug Fix: 11/1/02 
....................          flags = SYN; 
3DD6:  MOVLW  02
3DD8:  MOVLB  2
3DDA:  MOVWF  xFF
....................          break; 
3DDC:  BRA    3F5E
....................  
....................       case TCP_SYN_RECEIVED: 
....................          // We must receive ACK before timeout expires. 
....................          // If not, resend SYN+ACK. 
....................          // Abort, if maximum attempts counts are reached. 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
3DDE:  MOVLW  1E
3DE0:  MOVLB  2
3DE2:  ADDWF  xF9,W
3DE4:  MOVWF  FE9
3DE6:  MOVLW  00
3DE8:  ADDWFC xFA,W
3DEA:  MOVWF  FEA
3DEC:  MOVF   FEF,W
3DEE:  SUBLW  03
3DF0:  BNC   3DF8
....................          { 
....................             flags = SYN | ACK; 
3DF2:  MOVLW  12
3DF4:  MOVWF  xFF
....................          } 
....................          else 
3DF6:  BRA    3E24
....................          { 
....................             if(ps->Flags.bServer) 
3DF8:  MOVLW  23
3DFA:  ADDWF  xF9,W
3DFC:  MOVWF  FE9
3DFE:  MOVLW  00
3E00:  ADDWFC xFA,W
3E02:  MOVWF  FEA
3E04:  BTFSS  FEF.0
3E06:  BRA    3E14
....................             { 
....................                ps->smState = TCP_LISTEN; 
3E08:  MOVFF  2F9,FE9
3E0C:  MOVFF  2FA,FEA
3E10:  CLRF   FEF
....................             } 
....................             else 
3E12:  BRA    3E24
....................             { 
....................                flags = SYN; 
3E14:  MOVLW  02
3E16:  MOVWF  xFF
....................                ps->smState = TCP_SYN_SENT; 
3E18:  MOVFF  2F9,FE9
3E1C:  MOVFF  2FA,FEA
3E20:  MOVLW  01
3E22:  MOVWF  FEF
....................             } 
....................          } 
....................          break; 
3E24:  BRA    3F5E
....................  
....................       case TCP_ESTABLISHED: 
.................... #if !TCP_NO_WAIT_FOR_ACK 
....................          // Don't let this connection idle for very long time. 
....................          // If we did not receive or send any message before timeout 
....................          // expires, close this connection. 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
3E26:  MOVLW  1E
3E28:  MOVLB  2
3E2A:  ADDWF  xF9,W
3E2C:  MOVWF  FE9
3E2E:  MOVLW  00
3E30:  ADDWFC xFA,W
3E32:  MOVWF  FEA
3E34:  MOVF   FEF,W
3E36:  SUBLW  03
3E38:  BNC   3E7E
....................          { 
....................             if(ps->TxBuffer != INVALID_BUFFER) 
3E3A:  MOVLW  0F
3E3C:  ADDWF  xF9,W
3E3E:  MOVWF  FE9
3E40:  MOVLW  00
3E42:  ADDWFC xFA,W
3E44:  MOVWF  FEA
3E46:  INCFSZ FEF,W
3E48:  BRA    3E4C
3E4A:  BRA    3E74
....................             { 
....................                MACSetTxBuffer(ps->TxBuffer, 0); 
3E4C:  MOVLW  0F
3E4E:  ADDWF  xF9,W
3E50:  MOVWF  FE9
3E52:  MOVLW  00
3E54:  ADDWFC xFA,W
3E56:  MOVWF  FEA
3E58:  MOVFF  FEF,300
3E5C:  MOVFF  300,396
3E60:  MOVLB  3
3E62:  CLRF   x98
3E64:  CLRF   x97
3E66:  MOVLB  0
3E68:  CALL   1648
....................                MACFlush(); 
3E6C:  CALL   17FC
....................             } 
....................             else 
3E70:  BRA    3E7A
3E72:  MOVLB  2
....................                flags = ACK; 
3E74:  MOVLW  10
3E76:  MOVWF  xFF
3E78:  MOVLB  0
....................          } 
....................          else 
3E7A:  BRA    3ECC
3E7C:  MOVLB  2
....................          { 
....................             // Forget about previous transmission. 
....................             if(ps->TxBuffer != INVALID_BUFFER) 
3E7E:  MOVLW  0F
3E80:  ADDWF  xF9,W
3E82:  MOVWF  FE9
3E84:  MOVLW  00
3E86:  ADDWFC xFA,W
3E88:  MOVWF  FEA
3E8A:  INCFSZ FEF,W
3E8C:  BRA    3E90
3E8E:  BRA    3EBC
....................             { 
....................                MACDiscardTx(ps->TxBuffer); 
3E90:  MOVLW  0F
3E92:  ADDWF  xF9,W
3E94:  MOVWF  FE9
3E96:  MOVLW  00
3E98:  ADDWFC xFA,W
3E9A:  MOVWF  FEA
3E9C:  MOVFF  FEF,300
3EA0:  MOVFF  300,341
3EA4:  MOVLB  0
3EA6:  CALL   0004
....................                ps->TxBuffer = INVALID_BUFFER; 
3EAA:  MOVLW  0F
3EAC:  MOVLB  2
3EAE:  ADDWF  xF9,W
3EB0:  MOVWF  FE9
3EB2:  MOVLW  00
3EB4:  ADDWFC xFA,W
3EB6:  MOVWF  FEA
3EB8:  MOVLW  FF
3EBA:  MOVWF  FEF
....................             } 
....................  
.................... #endif 
....................             // Request closure. 
....................             flags = FIN | ACK; 
3EBC:  MOVLW  11
3EBE:  MOVWF  xFF
....................             //DebugPrint("!"); 
....................  
....................             ps->smState = TCP_FIN_WAIT_1; 
3EC0:  MOVFF  2F9,FE9
3EC4:  MOVFF  2FA,FEA
3EC8:  MOVLW  04
3ECA:  MOVWF  FEF
.................... #if !TCP_NO_WAIT_FOR_ACK 
....................          } 
.................... #endif 
....................          break; 
3ECC:  MOVLB  2
3ECE:  BRA    3F5E
....................  
....................       case TCP_FIN_WAIT_1: 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
3ED0:  MOVLW  1E
3ED2:  MOVLB  2
3ED4:  ADDWF  xF9,W
3ED6:  MOVWF  FE9
3ED8:  MOVLW  00
3EDA:  ADDWFC xFA,W
3EDC:  MOVWF  FEA
3EDE:  MOVF   FEF,W
3EE0:  SUBLW  03
3EE2:  BNC   3EEA
....................          { 
....................                // Send another FIN 
....................                flags = FIN; 
3EE4:  MOVLW  01
3EE6:  MOVWF  xFF
....................          } 
....................          else 
3EE8:  BRA    3EFA
....................          { 
....................             // Close on our own, we can't seem to communicate 
....................             // with the remote node anymore 
....................             CloseSocket(ps); 
3EEA:  MOVFF  2FA,33F
3EEE:  MOVFF  2F9,33E
3EF2:  MOVLB  0
3EF4:  CALL   261A
3EF8:  MOVLB  2
....................          } 
....................          break; 
3EFA:  BRA    3F5E
....................  
....................       case TCP_FIN_WAIT_2: 
....................       case TCP_CLOSING: 
....................          // Close on our own, we can't seem to communicate 
....................          // with the remote node anymore 
....................          CloseSocket(ps); 
3EFC:  MOVFF  2FA,33F
3F00:  MOVFF  2F9,33E
3F04:  CALL   261A
....................          break; 
3F08:  MOVLB  2
3F0A:  BRA    3F5E
....................  
....................       case TCP_TIME_WAIT: 
....................          // Wait around for a while (2MSL) and then goto closed state 
....................          CloseSocket(ps); 
3F0C:  MOVFF  2FA,33F
3F10:  MOVFF  2F9,33E
3F14:  CALL   261A
....................          break; 
3F18:  MOVLB  2
3F1A:  BRA    3F5E
....................  
....................       case TCP_CLOSE_WAIT: 
....................          flags = FIN; 
3F1C:  MOVLW  01
3F1E:  MOVLB  2
3F20:  MOVWF  xFF
....................          ps->smState = TCP_LAST_ACK; 
3F22:  MOVFF  2F9,FE9
3F26:  MOVFF  2FA,FEA
3F2A:  MOVLW  09
3F2C:  MOVWF  FEF
....................          break; 
3F2E:  BRA    3F5E
....................  
....................       case TCP_LAST_ACK: 
....................          // Send some more FINs or close anyway 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
3F30:  MOVLW  1E
3F32:  MOVLB  2
3F34:  ADDWF  xF9,W
3F36:  MOVWF  FE9
3F38:  MOVLW  00
3F3A:  ADDWFC xFA,W
3F3C:  MOVWF  FEA
3F3E:  MOVF   FEF,W
3F40:  SUBLW  03
3F42:  BNC   3F4A
....................             flags = FIN; 
3F44:  MOVLW  01
3F46:  MOVWF  xFF
....................          else 
3F48:  BRA    3F5A
....................             CloseSocket(ps); 
3F4A:  MOVFF  2FA,33F
3F4E:  MOVFF  2F9,33E
3F52:  MOVLB  0
3F54:  CALL   261A
3F58:  MOVLB  2
....................          break; 
3F5A:  BRA    3F5E
3F5C:  MOVLB  2
....................       } 
....................  
....................  
....................       if(flags) 
3F5E:  MOVF   xFF,F
3F60:  BTFSC  FD8.2
3F62:  BRA    4080
....................       { 
....................          if(flags & ACK) 
3F64:  BTFSS  xFF.4
3F66:  BRA    3F96
....................             seq = ps->SND_SEQ; 
3F68:  MOVLW  16
3F6A:  ADDWF  xF9,W
3F6C:  MOVWF  FE9
3F6E:  MOVLW  00
3F70:  ADDWFC xFA,W
3F72:  MOVWF  FEA
3F74:  MOVFF  FEF,00
3F78:  MOVFF  FEC,01
3F7C:  MOVFF  FEC,02
3F80:  MOVFF  FEC,03
3F84:  MOVFF  03,2FE
3F88:  MOVFF  02,2FD
3F8C:  MOVFF  01,2FC
3F90:  MOVFF  00,2FB
....................          else 
3F94:  BRA    3FD4
....................             seq = ps->SND_SEQ++; 
3F96:  MOVLW  16
3F98:  ADDWF  xF9,W
3F9A:  MOVWF  FE9
3F9C:  MOVLW  00
3F9E:  ADDWFC xFA,W
3FA0:  MOVWF  FEA
3FA2:  MOVF   FEE,F
3FA4:  MOVF   FEE,F
3FA6:  MOVF   FEE,F
3FA8:  MOVFF  FED,03
3FAC:  MOVFF  FED,02
3FB0:  MOVFF  FED,01
3FB4:  MOVFF  FEF,00
3FB8:  MOVLW  01
3FBA:  ADDWF  FEE,F
3FBC:  MOVLW  00
3FBE:  ADDWFC FEE,F
3FC0:  ADDWFC FEE,F
3FC2:  ADDWFC FED,F
3FC4:  MOVFF  03,2FE
3FC8:  MOVFF  02,2FD
3FCC:  MOVFF  01,2FC
3FD0:  MOVFF  00,2FB
....................  
....................          SendTCP(&ps->remote, 
....................             ps->localPort, 
....................             ps->remotePort, 
....................             seq, 
....................             ps->SND_ACK, 
....................             flags); 
3FD4:  MOVLW  01
3FD6:  ADDWF  xF9,W
3FD8:  MOVWF  01
3FDA:  MOVLW  00
3FDC:  ADDWFC xFA,W
3FDE:  MOVWF  03
3FE0:  MOVFF  01,300
3FE4:  MOVLB  3
3FE6:  MOVWF  x01
3FE8:  MOVLW  0B
3FEA:  MOVLB  2
3FEC:  ADDWF  xF9,W
3FEE:  MOVWF  FE9
3FF0:  MOVLW  00
3FF2:  ADDWFC xFA,W
3FF4:  MOVWF  FEA
3FF6:  MOVFF  FEC,303
3FFA:  MOVF   FED,F
3FFC:  MOVFF  FEF,302
4000:  MOVLW  0D
4002:  ADDWF  xF9,W
4004:  MOVWF  FE9
4006:  MOVLW  00
4008:  ADDWFC xFA,W
400A:  MOVWF  FEA
400C:  MOVFF  FEC,305
4010:  MOVF   FED,F
4012:  MOVFF  FEF,304
4016:  MOVLW  1A
4018:  ADDWF  xF9,W
401A:  MOVWF  FE9
401C:  MOVLW  00
401E:  ADDWFC xFA,W
4020:  MOVWF  FEA
4022:  MOVFF  FEF,306
4026:  MOVFF  FEC,307
402A:  MOVFF  FEC,308
402E:  MOVFF  FEC,309
4032:  MOVFF  03,346
4036:  MOVFF  01,345
403A:  MOVFF  303,348
403E:  MOVFF  302,347
4042:  MOVFF  305,34A
4046:  MOVFF  304,349
404A:  MOVFF  2FE,34E
404E:  MOVFF  2FD,34D
4052:  MOVFF  2FC,34C
4056:  MOVFF  2FB,34B
405A:  MOVFF  309,352
405E:  MOVFF  308,351
4062:  MOVFF  307,350
4066:  MOVFF  306,34F
406A:  MOVFF  2FF,353
406E:  MOVLW  FF
4070:  MOVLB  3
4072:  MOVWF  x54
4074:  CLRF   x56
4076:  CLRF   x55
4078:  MOVLB  0
407A:  CALL   2A40
407E:  MOVLB  2
....................       } 
....................  
....................       /*if (debugLastState != ps->smState) 
....................       { 
....................          debug_tcp("\r\nTCP TICK %u - ", s); 
....................          DebugTCPDisplayState(debugLastState); 
....................          debug_tcp(" -> "); 
....................          DebugTCPDisplayState(ps->smState); 
....................       }*/ 
....................    } 
4080:  INCF   xF4,F
4082:  BRA    3BDE
4084:  MOVLB  0
.................... } 
4086:  GOTO   717A (RETURN)
....................  
.................... /********************************************************************* 
.................... * Function:        BOOL TCPProcess(NODE_INFO* remote, 
.................... *                                  IP_ADDR *localIP, 
.................... *                                  WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCP segment is ready in MAC buffer 
.................... * 
.................... * Input:           remote      - Remote node info 
.................... *                  len         - Total length of TCP semgent. 
.................... * 
.................... * Output:          TRUE if this function has completed its task 
.................... *                  FALSE otherwise 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... BOOL TCPProcess(NODE_INFO *remote, IP_ADDR *localIP, WORD len) 
.................... { 
....................    TCP_HEADER      TCPHeader; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................    TCP_SOCKET      socket; 
....................    WORD_VAL        checksum1; 
....................    WORD_VAL        checksum2; 
....................    BYTE            optionsSize; 
....................    
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress      = remote->IPAddr; 
*
3740:  MOVLW  06
3742:  MOVLB  2
3744:  ADDWF  xF4,W
3746:  MOVWF  FE9
3748:  MOVLW  00
374A:  ADDWFC xF5,W
374C:  MOVWF  FEA
374E:  MOVFF  FEF,00
3752:  MOVFF  FEC,01
3756:  MOVFF  FEC,02
375A:  MOVFF  FEC,03
375E:  MOVFF  03,311
3762:  MOVFF  02,310
3766:  MOVFF  01,30F
376A:  MOVFF  00,30E
....................    pseudoHeader.DestAddress        = *localIP; 
376E:  MOVFF  2F6,FE9
3772:  MOVFF  2F7,FEA
3776:  MOVFF  FEF,00
377A:  MOVFF  FEC,01
377E:  MOVFF  FEC,02
3782:  MOVFF  FEC,03
3786:  MOVFF  03,315
378A:  MOVFF  02,314
378E:  MOVFF  01,313
3792:  MOVFF  00,312
....................    pseudoHeader.Zero               = 0x0; 
3796:  MOVLB  3
3798:  CLRF   x16
....................    pseudoHeader.Protocol           = IP_PROT_TCP; 
379A:  MOVLW  06
379C:  MOVWF  x17
....................    pseudoHeader.TCPLength          = len; 
379E:  MOVFF  2F9,319
37A2:  MOVFF  2F8,318
....................  
....................    SwapPseudoTCPHeader(pseudoHeader); 
37A6:  MOVFF  319,39D
37AA:  MOVFF  318,39C
37AE:  MOVLB  0
37B0:  CALL   1326
37B4:  MOVFF  02,319
37B8:  MOVFF  01,318
....................  
....................    checksum1.Val = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
37BC:  MOVLW  03
37BE:  MOVLB  3
37C0:  MOVWF  x21
37C2:  MOVLW  0E
37C4:  MOVFF  321,380
37C8:  MOVWF  x7F
37CA:  CLRF   x82
37CC:  MOVLW  0C
37CE:  MOVWF  x81
37D0:  MOVLB  0
37D2:  CALL   1F5E
37D6:  MOVFF  01,31B
37DA:  MOVLB  3
37DC:  COMF   x1B,F
37DE:  MOVFF  02,31C
37E2:  COMF   x1C,F
....................  
....................  
....................    // Now calculate TCP packet checksum in NIC RAM - should match 
....................    // pesudo header checksum 
....................    checksum2.Val = CalcIPBufferChecksum(len); 
37E4:  MOVFF  2F9,37E
37E8:  MOVFF  2F8,37D
37EC:  MOVLB  0
37EE:  CALL   2078
37F2:  MOVFF  02,31E
37F6:  MOVFF  01,31D
....................  
....................    // Compare checksums.  Note that the endianness is different. 
....................    if(checksum1.v[0] != checksum2.v[1] || checksum1.v[1] != checksum2.v[0]) 
37FA:  MOVLB  3
37FC:  MOVF   x1E,W
37FE:  SUBWF  x1B,W
3800:  BNZ   3808
3802:  MOVF   x1D,W
3804:  SUBWF  x1C,W
3806:  BZ    3816
....................    { 
....................       MACDiscardRx(); 
3808:  MOVLB  0
380A:  CALL   1256
....................       return TRUE; 
380E:  MOVLW  01
3810:  MOVWF  01
3812:  BRA    38FA
3814:  MOVLB  3
....................    } 
....................  
....................    // Retrieve TCP header. 
....................    IPSetRxBuffer(0); 
3816:  CLRF   x22
3818:  CLRF   x21
381A:  MOVLB  0
381C:  CALL   21C0
....................    MACGetArray((BYTE*)&TCPHeader, sizeof(TCPHeader)); 
3820:  MOVLW  02
3822:  MOVLB  3
3824:  MOVWF  x21
3826:  MOVLW  FA
3828:  MOVFF  321,38C
382C:  MOVWF  x8B
382E:  CLRF   x8E
3830:  MOVLW  14
3832:  MOVWF  x8D
3834:  MOVLB  0
3836:  CALL   12C2
....................    SwapTCPHeader(&TCPHeader); 
383A:  MOVLW  02
383C:  MOVLB  3
383E:  MOVWF  x7E
3840:  MOVLW  FA
3842:  MOVWF  x7D
3844:  MOVLB  0
3846:  CALL   21FC
....................  
....................  
....................    // Skip over options and retrieve all data bytes. 
....................    optionsSize = (BYTE)((TCPHeader.DataOffset.Val << 2)- 
....................       sizeof(TCPHeader)); 
384A:  MOVLB  3
384C:  SWAPF  x06,W
384E:  ANDLW  0F
3850:  MOVWF  00
3852:  RLCF   00,W
3854:  MOVWF  x20
3856:  RLCF   x20,F
3858:  MOVLW  FC
385A:  ANDWF  x20,F
385C:  MOVLW  14
385E:  SUBWF  x20,W
3860:  MOVWF  x1F
....................    len = len - optionsSize - sizeof(TCPHeader); 
3862:  MOVF   x1F,W
3864:  MOVLB  2
3866:  SUBWF  xF8,W
3868:  MOVLB  3
386A:  MOVWF  x20
386C:  MOVLW  00
386E:  MOVLB  2
3870:  SUBWFB xF9,W
3872:  MOVLB  3
3874:  MOVWF  x21
3876:  MOVLW  14
3878:  SUBWF  x20,W
387A:  MOVLB  2
387C:  MOVWF  xF8
387E:  MOVLW  00
3880:  MOVLB  3
3882:  SUBWFB x21,W
3884:  MOVLB  2
3886:  MOVWF  xF9
....................  
....................    // Position packet read pointer to start of data area. 
....................    IPSetRxBuffer((TCPHeader.DataOffset.Val << 2)); 
3888:  MOVLB  3
388A:  SWAPF  x06,W
388C:  ANDLW  0F
388E:  MOVWF  00
3890:  RLCF   00,W
3892:  MOVWF  x20
3894:  RLCF   x20,F
3896:  MOVLW  FC
3898:  ANDWF  x20,F
389A:  CLRF   x22
389C:  MOVFF  320,321
38A0:  MOVLB  0
38A2:  CALL   21C0
....................  
....................    // Find matching socket. 
....................    socket =FindMatching_TCP_Socket(&TCPHeader, remote); 
38A6:  MOVLW  02
38A8:  MOVLB  3
38AA:  MOVWF  x21
38AC:  MOVLW  FA
38AE:  MOVWF  x20
38B0:  MOVFF  2F5,323
38B4:  MOVFF  2F4,322
38B8:  MOVLB  0
38BA:  GOTO   2422
38BE:  MOVFF  01,31A
....................    if(socket != INVALID_SOCKET) 
38C2:  MOVLB  3
38C4:  MOVF   x1A,W
38C6:  SUBLW  FE
38C8:  BZ    38F0
....................    { 
....................       HandleTCPSeg(socket, remote, &TCPHeader, len); 
38CA:  MOVFF  31A,320
38CE:  MOVFF  2F5,322
38D2:  MOVFF  2F4,321
38D6:  MOVLW  02
38D8:  MOVWF  x24
38DA:  MOVLW  FA
38DC:  MOVWF  x23
38DE:  MOVFF  2F9,326
38E2:  MOVFF  2F8,325
38E6:  MOVLB  0
38E8:  GOTO   2C6E
....................    } 
....................    else 
38EC:  BRA    38F6
38EE:  MOVLB  3
....................    { 
....................       // If this is an unknown socket, or we don't have any 
....................       // listening sockets available, discard it we can't 
....................       // process it right now 
....................       MACDiscardRx(); 
38F0:  MOVLB  0
38F2:  CALL   1256
....................  
.................... //      // Send a RESET to the remote node is it knows that we 
.................... //      // are not available 
.................... //      TCPHeader.AckNumber += len; 
.................... //      if( TCPHeader.Flags.bits.flagSYN || 
.................... //         TCPHeader.Flags.bits.flagFIN ) 
.................... //         TCPHeader.AckNumber++; 
.................... // 
.................... //      SendTCP(remote, 
.................... //         TCPHeader.DestPort, 
.................... //         TCPHeader.SourcePort, 
.................... //         TCPHeader.AckNumber, 
.................... //         TCPHeader.SeqNumber, 
.................... //         RST); 
....................    } 
....................  
....................    return TRUE; 
38F6:  MOVLW  01
38F8:  MOVWF  01
.................... } 
38FA:  GOTO   70BC (RETURN)
....................  
.................... /********************************************************************* 
.................... * Function:        static void TransmitTCP(NODE_INFO* remote 
.................... *                                          TCP_PORT localPort, 
.................... *                                          TCP_PORT remotePort, 
.................... *                                          DWORD seq, 
.................... *                                          DWORD ack, 
.................... *                                          BYTE flags, 
.................... *                                          BUFFER buffer, 
.................... *                                          WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPIsPutReady() == TRUE 
.................... * 
.................... * Input:           remote      - Remote node info 
.................... *                  localPort   - Source port number 
.................... *                  remotePort  - Destination port number 
.................... *                  seq         - Segment sequence number 
.................... *                  ack         - Segment acknowledge number 
.................... *                  flags       - Segment flags 
.................... *                  buffer      - Buffer to which this segment 
.................... *                                is to be transmitted 
.................... *                  len         - Total data length for this segment. 
.................... * 
.................... * Output:          A TCP segment is assembled and put to transmit. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... static void TransmitTCP(NODE_INFO *remote, 
....................                   TCP_PORT localPort, 
....................                   TCP_PORT remotePort, 
....................                   DWORD tseq, 
....................                   DWORD tack, 
....................                   BYTE flags, 
....................                   BUFFER buff, 
....................                   WORD len) 
.................... { 
....................    WORD_VAL        checkSum; 
....................    TCP_HEADER      header; 
....................    TCP_OPTIONS     options; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................  
....................    debug_tcp("\r\n\nTCP OUT => LP:%LX RP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X", 
....................       localPort, 
....................       remotePort, 
....................       tseq, 
....................       tack, 
....................       len, 
....................       flags 
....................    ); 
....................  
....................    //  Make sure that this Tx buffer isn't currently being transmitted 
....................    while( !IPIsTxReady(TRUE) );   //TODO: This may need to be conditionally false 
*
2A40:  MOVLW  01
2A42:  MOVLB  3
2A44:  MOVWF  x7D
2A46:  MOVLB  0
2A48:  RCALL  271E
2A4A:  MOVF   01,F
2A4C:  BZ    2A40
....................  
....................    // Obtain an AutoFree buffer if this packet is a control packet 
....................    // only (contains no application data in an already allocated 
....................    // buffer) 
....................    if(buff == INVALID_BUFFER) 
2A4E:  MOVLB  3
2A50:  INCFSZ x54,W
2A52:  BRA    2A64
....................       buff = MACGetTxBuffer(TRUE); 
2A54:  MOVLW  01
2A56:  MOVWF  x7D
2A58:  MOVLB  0
2A5A:  CALL   162C
2A5E:  MOVFF  01,354
2A62:  MOVLB  3
....................  
....................    if(buff == INVALID_BUFFER) 
2A64:  INCFSZ x54,W
2A66:  BRA    2A6A
....................       return; 
2A68:  BRA    2C6A
....................  
....................    IPSetTxBuffer(buff, 0); 
2A6A:  MOVFF  354,396
2A6E:  CLRF   x98
2A70:  MOVLW  14
2A72:  MOVWF  x97
2A74:  MOVLB  0
2A76:  CALL   1648
....................  
....................    header.SourcePort           = localPort; 
2A7A:  MOVFF  348,35A
2A7E:  MOVFF  347,359
....................    header.DestPort             = remotePort; 
2A82:  MOVFF  34A,35C
2A86:  MOVFF  349,35B
....................    header.SeqNumber            = tseq; 
2A8A:  MOVFF  34E,360
2A8E:  MOVFF  34D,35F
2A92:  MOVFF  34C,35E
2A96:  MOVFF  34B,35D
....................    header.AckNumber            = tack; 
2A9A:  MOVFF  352,364
2A9E:  MOVFF  351,363
2AA2:  MOVFF  350,362
2AA6:  MOVFF  34F,361
....................    header.Flags.bits.Reserved2 = 0; 
2AAA:  MOVLW  3F
2AAC:  MOVLB  3
2AAE:  ANDWF  x66,W
2AB0:  MOVWF  x66
....................    header.DataOffset.Reserved3 = 0; 
2AB2:  MOVLW  F0
2AB4:  ANDWF  x65,W
2AB6:  MOVWF  x65
....................    header.Flags.b              = flags; 
2AB8:  MOVFF  353,366
....................    // Receive window = MAC Free buffer size - TCP header (20) - IP header (20) 
....................    //                  - ETHERNET header (14 if using NIC) . 
....................    header.Window               = MACGetFreeRxSize(); 
2ABC:  MOVLB  0
2ABE:  BRA    2736
2AC0:  MOVFF  02,368
2AC4:  MOVFF  01,367
.................... #if !defined(STACK_USE_SLIP) 
....................    /* 
....................    * Limit one segment at a time from remote host. 
....................    * This limit increases overall throughput as remote host does not 
....................    * flood us with packets and later retry with significant delay. 
....................    */ 
....................    if ( header.Window >= MAC_RX_BUFFER_SIZE ) 
....................       header.Window = MAC_RX_BUFFER_SIZE; 
....................  
....................    else if ( header.Window > 54 ) 
....................    { 
....................       header.Window -= 54; 
....................    } 
....................    else 
....................       header.Window = 0; 
.................... #else 
....................    if ( header.Window > 40 ) 
2AC8:  MOVLB  3
2ACA:  MOVF   x68,F
2ACC:  BNZ   2AD4
2ACE:  MOVF   x67,W
2AD0:  SUBLW  28
2AD2:  BC    2ADE
....................    { 
....................       header.Window -= 40; 
2AD4:  MOVLW  28
2AD6:  SUBWF  x67,F
2AD8:  MOVLW  00
2ADA:  SUBWFB x68,F
....................    } 
....................    else 
2ADC:  BRA    2AE2
....................       header.Window = 0; 
2ADE:  CLRF   x68
2AE0:  CLRF   x67
.................... #endif 
....................  
....................    header.Checksum             = 0; 
2AE2:  CLRF   x6A
2AE4:  CLRF   x69
....................    header.UrgentPointer        = 0; 
2AE6:  CLRF   x6C
2AE8:  CLRF   x6B
....................  
....................    SwapTCPHeader(&header); 
2AEA:  MOVLW  03
2AEC:  MOVWF  x7E
2AEE:  MOVLW  59
2AF0:  MOVWF  x7D
2AF2:  MOVLB  0
2AF4:  CALL   21FC
....................  
....................    len += sizeof(header); 
2AF8:  MOVLW  14
2AFA:  MOVLB  3
2AFC:  ADDWF  x55,F
2AFE:  MOVLW  00
2B00:  ADDWFC x56,F
....................  
....................    if ( flags & SYN ) 
2B02:  BTFSS  x53.1
2B04:  BRA    2B24
....................    { 
....................       len += sizeof(options); 
2B06:  MOVLW  04
2B08:  ADDWF  x55,F
2B0A:  MOVLW  00
2B0C:  ADDWFC x56,F
....................       options.Kind = TCP_OPTIONS_MAX_SEG_SIZE; 
2B0E:  MOVLW  02
2B10:  MOVWF  x6D
....................       options.Length = 0x04; 
2B12:  MOVLW  04
2B14:  MOVWF  x6E
....................  
....................       // Load MSS in already swapped order. 
....................       options.MaxSegSize.v[0]  = (MAC_RX_BUFFER_SIZE >> 8); // 0x05; 
2B16:  MOVWF  x6F
....................       options.MaxSegSize.v[1]  = (MAC_RX_BUFFER_SIZE & 0xff); // 0xb4; 
2B18:  CLRF   x70
....................  
....................       header.DataOffset.Val   = (sizeof(header) + sizeof(options)) >> 2; 
2B1A:  MOVLW  0F
2B1C:  ANDWF  x65,W
2B1E:  IORLW  60
2B20:  MOVWF  x65
....................    } 
....................    else 
2B22:  BRA    2B2C
....................       header.DataOffset.Val   = sizeof(header) >> 2; 
2B24:  MOVLW  0F
2B26:  ANDWF  x65,W
2B28:  IORLW  50
2B2A:  MOVWF  x65
....................  
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress   = AppConfig.MyIPAddr; 
2B2C:  MOVFF  1A,374
2B30:  MOVFF  19,373
2B34:  MOVFF  18,372
2B38:  MOVFF  17,371
....................    pseudoHeader.DestAddress    = remote->IPAddr; 
2B3C:  MOVLW  06
2B3E:  ADDWF  x45,W
2B40:  MOVWF  FE9
2B42:  MOVLW  00
2B44:  ADDWFC x46,W
2B46:  MOVWF  FEA
2B48:  MOVFF  FEF,00
2B4C:  MOVFF  FEC,01
2B50:  MOVFF  FEC,02
2B54:  MOVFF  FEC,03
2B58:  MOVFF  03,378
2B5C:  MOVFF  02,377
2B60:  MOVFF  01,376
2B64:  MOVFF  00,375
....................    pseudoHeader.Zero           = 0x0; 
2B68:  CLRF   x79
....................    pseudoHeader.Protocol       = IP_PROT_TCP; 
2B6A:  MOVLW  06
2B6C:  MOVWF  x7A
....................    pseudoHeader.TCPLength      = len; 
2B6E:  MOVFF  356,37C
2B72:  MOVFF  355,37B
....................  
....................    SwapPseudoTCPHeader(pseudoHeader); 
2B76:  MOVFF  37C,39D
2B7A:  MOVFF  37B,39C
2B7E:  MOVLB  0
2B80:  CALL   1326
2B84:  MOVFF  02,37C
2B88:  MOVFF  01,37B
....................  
....................    header.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
2B8C:  MOVLW  03
2B8E:  MOVLB  3
2B90:  MOVWF  x7E
2B92:  MOVLW  71
2B94:  MOVFF  37E,380
2B98:  MOVWF  x7F
2B9A:  CLRF   x82
2B9C:  MOVLW  0C
2B9E:  MOVWF  x81
2BA0:  MOVLB  0
2BA2:  CALL   1F5E
2BA6:  MOVFF  01,369
2BAA:  MOVLB  3
2BAC:  COMF   x69,F
2BAE:  MOVFF  02,36A
2BB2:  COMF   x6A,F
....................    checkSum.Val = header.Checksum; 
2BB4:  MOVFF  36A,358
2BB8:  MOVFF  369,357
....................  
....................    // Write IP header. 
....................    IPPutHeader(remote, IP_PROT_TCP, len); 
2BBC:  MOVFF  346,37E
2BC0:  MOVFF  345,37D
2BC4:  MOVLW  06
2BC6:  MOVWF  x7F
2BC8:  MOVFF  356,381
2BCC:  MOVFF  355,380
2BD0:  MOVLB  0
2BD2:  RCALL  2914
....................    IPPutArray((BYTE*)&header, sizeof(header)); 
2BD4:  MOVLW  03
2BD6:  MOVLB  3
2BD8:  MOVWF  x7E
2BDA:  MOVLW  59
2BDC:  MOVFF  37E,3A2
2BE0:  MOVWF  xA1
2BE2:  CLRF   xA4
2BE4:  MOVLW  14
2BE6:  MOVWF  xA3
2BE8:  MOVLB  0
2BEA:  CALL   16F0
....................  
....................    if ( flags & SYN ) 
2BEE:  MOVLB  3
2BF0:  BTFSS  x53.1
2BF2:  BRA    2C0E
....................       IPPutArray((BYTE*)&options, sizeof(options)); 
2BF4:  MOVLW  03
2BF6:  MOVWF  x7E
2BF8:  MOVLW  6D
2BFA:  MOVFF  37E,3A2
2BFE:  MOVWF  xA1
2C00:  CLRF   xA4
2C02:  MOVLW  04
2C04:  MOVWF  xA3
2C06:  MOVLB  0
2C08:  CALL   16F0
2C0C:  MOVLB  3
....................  
....................    IPSetTxBuffer(buff, 0); 
2C0E:  MOVFF  354,396
2C12:  CLRF   x98
2C14:  MOVLW  14
2C16:  MOVWF  x97
2C18:  MOVLB  0
2C1A:  CALL   1648
....................  
....................    checkSum.Val = CalcIPBufferChecksum(len); 
2C1E:  MOVFF  356,37E
2C22:  MOVFF  355,37D
2C26:  CALL   2078
2C2A:  MOVFF  02,358
2C2E:  MOVFF  01,357
....................  
....................    // Update the checksum. 
....................    IPSetTxBuffer(buff, 16); 
2C32:  MOVFF  354,396
2C36:  MOVLB  3
2C38:  CLRF   x98
2C3A:  MOVLW  24
2C3C:  MOVWF  x97
2C3E:  MOVLB  0
2C40:  CALL   1648
....................    MACPut(checkSum.v[1]); 
2C44:  MOVFF  358,3A0
2C48:  CALL   16D2
....................    MACPut(checkSum.v[0]); 
2C4C:  MOVFF  357,3A0
2C50:  CALL   16D2
....................    MACSetTxBuffer(buff, 0); 
2C54:  MOVFF  354,396
2C58:  MOVLB  3
2C5A:  CLRF   x98
2C5C:  CLRF   x97
2C5E:  MOVLB  0
2C60:  CALL   1648
....................  
....................    MACFlush(); 
2C64:  CALL   17FC
2C68:  MOVLB  3
....................  
.................... #if !TCP_NO_WAIT_FOR_ACK /*&& !defined(DEBUG)*/ 
....................    // If we send the packet again, the remote node might think that we timed 
....................    // out and retransmitted.  It could thus immediately send back an ACK and 
....................    // dramatically improve throuput. 
....................    //while(!IPIsTxReady(TRUE)); 
....................    //MACFlush(); 
.................... #endif 
.................... } 
2C6A:  MOVLB  0
2C6C:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, 
....................  *                                      NODE_INFO* remote) 
....................  * 
....................  * PreCondition:    TCPInit() is already called 
....................  * 
....................  * Input:           h           - TCP Header to be matched against. 
....................  *                  remote      - Node who sent this header. 
....................  * 
....................  * Output:          A socket that matches with given header and remote 
....................  *                  node is searched. 
....................  *                  If such socket is found, its index is returned 
....................  *                  else INVALID_SOCKET is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, NODE_INFO *remote) 
.................... { 
....................    SOCKET_INFO *ps; 
....................    TCP_SOCKET s; 
....................    TCP_SOCKET partialMatch; 
....................  
....................    partialMatch = INVALID_SOCKET; 
*
2422:  MOVLW  FE
2424:  MOVLB  3
2426:  MOVWF  x27
....................  
....................    for ( s = 0; s < MAX_SOCKETS; s++ ) 
2428:  CLRF   x26
242A:  MOVF   x26,W
242C:  SUBLW  04
242E:  BTFSS  FD8.0
2430:  BRA    2526
....................    { 
....................       ps = &TCB[s]; 
2432:  MOVF   x26,W
2434:  MULLW  24
2436:  MOVF   FF3,W
2438:  CLRF   03
243A:  ADDLW  5E
243C:  MOVWF  01
243E:  MOVLW  00
2440:  ADDWFC 03,F
2442:  MOVFF  01,324
2446:  MOVFF  03,325
....................  
....................       if ( ps->smState != TCP_CLOSED ) 
244A:  MOVFF  324,FE9
244E:  MOVFF  325,FEA
2452:  MOVF   FEF,W
2454:  SUBLW  0A
2456:  BZ    2522
....................       { 
....................          if ( ps->localPort == h->DestPort ) 
2458:  MOVLW  0B
245A:  ADDWF  x24,W
245C:  MOVWF  FE9
245E:  MOVLW  00
2460:  ADDWFC x25,W
2462:  MOVWF  FEA
2464:  MOVFF  FEC,329
2468:  MOVF   FED,F
246A:  MOVFF  FEF,328
246E:  MOVLW  02
2470:  ADDWF  x20,W
2472:  MOVWF  FE9
2474:  MOVLW  00
2476:  ADDWFC x21,W
2478:  MOVWF  FEA
247A:  MOVFF  FEC,03
247E:  MOVF   FED,F
2480:  MOVF   FEF,W
2482:  SUBWF  x28,W
2484:  BNZ   2522
2486:  MOVF   03,W
2488:  SUBWF  x29,W
248A:  BNZ   2522
....................          { 
....................             if ( ps->smState == TCP_LISTEN ) 
248C:  MOVFF  324,FE9
2490:  MOVFF  325,FEA
2494:  MOVF   FEF,F
2496:  BNZ   249C
....................                partialMatch = s; 
2498:  MOVFF  326,327
....................  
....................             if ( ps->remotePort == h->SourcePort && 
....................                ps->remote.IPAddr.Val == remote->IPAddr.Val ) 
249C:  MOVLW  0D
249E:  ADDWF  x24,W
24A0:  MOVWF  FE9
24A2:  MOVLW  00
24A4:  ADDWFC x25,W
24A6:  MOVWF  FEA
24A8:  MOVFF  FEC,329
24AC:  MOVF   FED,F
24AE:  MOVFF  FEF,328
24B2:  MOVFF  320,FE9
24B6:  MOVFF  321,FEA
24BA:  MOVFF  FEC,03
24BE:  MOVF   FED,F
24C0:  MOVF   FEF,W
24C2:  SUBWF  x28,W
24C4:  BNZ   2522
24C6:  MOVF   03,W
24C8:  SUBWF  x29,W
24CA:  BNZ   2522
24CC:  MOVLW  07
24CE:  ADDWF  x24,W
24D0:  MOVWF  FE9
24D2:  MOVLW  00
24D4:  ADDWFC x25,W
24D6:  MOVWF  FEA
24D8:  MOVFF  FEF,328
24DC:  MOVFF  FEC,329
24E0:  MOVFF  FEC,32A
24E4:  MOVFF  FEC,32B
24E8:  MOVLW  06
24EA:  ADDWF  x22,W
24EC:  MOVWF  FE9
24EE:  MOVLW  00
24F0:  ADDWFC x23,W
24F2:  MOVWF  FEA
24F4:  MOVFF  FEF,00
24F8:  MOVFF  FEC,01
24FC:  MOVFF  FEC,02
2500:  MOVFF  FEC,03
2504:  MOVF   00,W
2506:  SUBWF  x28,W
2508:  BNZ   2522
250A:  MOVF   01,W
250C:  SUBWF  x29,W
250E:  BNZ   2522
2510:  MOVF   02,W
2512:  SUBWF  x2A,W
2514:  BNZ   2522
2516:  MOVF   03,W
2518:  SUBWF  x2B,W
251A:  BNZ   2522
....................             { 
....................                return s; 
251C:  MOVFF  326,01
2520:  BRA    25FA
....................             } 
....................          } 
....................       } 
....................    } 
2522:  INCF   x26,F
2524:  BRA    242A
....................  
....................    // We are not listening on this port 
....................    if(partialMatch == INVALID_SOCKET) 
2526:  MOVF   x27,W
2528:  SUBLW  FE
252A:  BNZ   2532
....................       return INVALID_SOCKET; 
252C:  MOVLW  FE
252E:  MOVWF  01
2530:  BRA    25FA
....................  
....................    // Copy the remote node IP/MAC address and source TCP port 
....................    // number into our TCB and return this socket to the caller 
....................    ps = &TCB[partialMatch]; 
2532:  MOVF   x27,W
2534:  MULLW  24
2536:  MOVF   FF3,W
2538:  CLRF   03
253A:  ADDLW  5E
253C:  MOVWF  01
253E:  MOVLW  00
2540:  ADDWFC 03,F
2542:  MOVFF  01,324
2546:  MOVFF  03,325
....................    memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote)); 
254A:  MOVLW  01
254C:  ADDWF  x24,W
254E:  MOVWF  x28
2550:  MOVLW  00
2552:  ADDWFC x25,W
2554:  MOVWF  x29
2556:  MOVWF  FEA
2558:  MOVFF  328,FE9
255C:  MOVFF  323,FE2
2560:  MOVFF  322,FE1
2564:  MOVLW  0A
2566:  MOVWF  01
2568:  MOVFF  FE6,FEE
256C:  DECFSZ 01,F
256E:  BRA    2568
....................    ps->remotePort          = h->SourcePort; 
2570:  MOVLW  0D
2572:  ADDWF  x24,W
2574:  MOVWF  01
2576:  MOVLW  00
2578:  ADDWFC x25,W
257A:  MOVFF  320,FE9
257E:  MOVFF  321,FEA
2582:  MOVFF  FEC,03
2586:  MOVF   FED,F
2588:  MOVFF  FEF,32A
258C:  MOVWF  FEA
258E:  MOVFF  01,FE9
2592:  MOVFF  03,FEC
2596:  MOVF   FED,F
2598:  MOVFF  32A,FEF
....................    ps->Flags.bIsGetReady   = FALSE; 
259C:  MOVLW  23
259E:  ADDWF  x24,W
25A0:  MOVWF  FE9
25A2:  MOVLW  00
25A4:  ADDWFC x25,W
25A6:  MOVWF  FEA
25A8:  BCF    FEF.3
....................    if(ps->TxBuffer != INVALID_BUFFER) 
25AA:  MOVLW  0F
25AC:  ADDWF  x24,W
25AE:  MOVWF  FE9
25B0:  MOVLW  00
25B2:  ADDWFC x25,W
25B4:  MOVWF  FEA
25B6:  INCFSZ FEF,W
25B8:  BRA    25BC
25BA:  BRA    25E8
....................    { 
....................       MACDiscardTx(ps->TxBuffer); 
25BC:  MOVLW  0F
25BE:  ADDWF  x24,W
25C0:  MOVWF  FE9
25C2:  MOVLW  00
25C4:  ADDWFC x25,W
25C6:  MOVWF  FEA
25C8:  MOVFF  FEF,328
25CC:  MOVFF  328,341
25D0:  MOVLB  0
25D2:  CALL   0004
....................       ps->TxBuffer        = INVALID_BUFFER; 
25D6:  MOVLW  0F
25D8:  MOVLB  3
25DA:  ADDWF  x24,W
25DC:  MOVWF  FE9
25DE:  MOVLW  00
25E0:  ADDWFC x25,W
25E2:  MOVWF  FEA
25E4:  MOVLW  FF
25E6:  MOVWF  FEF
....................    } 
....................    ps->Flags.bIsPutReady   = TRUE; 
25E8:  MOVLW  23
25EA:  ADDWF  x24,W
25EC:  MOVWF  FE9
25EE:  MOVLW  00
25F0:  ADDWFC x25,W
25F2:  MOVWF  FEA
25F4:  BSF    FEF.1
....................  
....................    return partialMatch; 
25F6:  MOVFF  327,01
.................... } 
25FA:  MOVLB  0
25FC:  GOTO   38BE (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapTCPHeader(TCP_HEADER* header) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           header      - TCP Header to be swapped. 
....................  * 
....................  * Output:          Given header is swapped. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapTCPHeader(TCP_HEADER* header) 
.................... { 
....................     header->SourcePort      = swaps(header->SourcePort); 
*
21FC:  MOVLB  3
21FE:  MOVFF  37D,01
2202:  MOVFF  37E,03
2206:  MOVFF  37D,37F
220A:  MOVFF  37E,380
220E:  MOVFF  37D,FE9
2212:  MOVFF  37E,FEA
2216:  MOVFF  FEC,382
221A:  MOVF   FED,F
221C:  MOVFF  FEF,381
2220:  MOVFF  382,39D
2224:  MOVFF  381,39C
2228:  MOVLB  0
222A:  CALL   1326
222E:  MOVFF  380,FEA
2232:  MOVFF  37F,FE9
2236:  MOVFF  02,FEC
223A:  MOVF   FED,F
223C:  MOVFF  01,FEF
....................     header->DestPort        = swaps(header->DestPort); 
2240:  MOVLW  02
2242:  MOVLB  3
2244:  ADDWF  x7D,W
2246:  MOVWF  01
2248:  MOVLW  00
224A:  ADDWFC x7E,W
224C:  MOVWF  03
224E:  MOVFF  01,37F
2252:  MOVWF  x80
2254:  MOVLW  02
2256:  ADDWF  x7D,W
2258:  MOVWF  FE9
225A:  MOVLW  00
225C:  ADDWFC x7E,W
225E:  MOVWF  FEA
2260:  MOVFF  FEC,382
2264:  MOVF   FED,F
2266:  MOVFF  FEF,381
226A:  MOVFF  382,39D
226E:  MOVFF  381,39C
2272:  MOVLB  0
2274:  CALL   1326
2278:  MOVFF  380,FEA
227C:  MOVFF  37F,FE9
2280:  MOVFF  02,FEC
2284:  MOVF   FED,F
2286:  MOVFF  01,FEF
....................     header->SeqNumber       = swapl(header->SeqNumber); 
228A:  MOVLW  04
228C:  MOVLB  3
228E:  ADDWF  x7D,W
2290:  MOVWF  01
2292:  MOVLW  00
2294:  ADDWFC x7E,W
2296:  MOVWF  03
2298:  MOVFF  01,37F
229C:  MOVWF  x80
229E:  MOVLW  04
22A0:  ADDWF  x7D,W
22A2:  MOVWF  FE9
22A4:  MOVLW  00
22A6:  ADDWFC x7E,W
22A8:  MOVWF  FEA
22AA:  MOVFF  FEF,381
22AE:  MOVFF  FEC,382
22B2:  MOVFF  FEC,383
22B6:  MOVFF  FEC,384
22BA:  MOVFF  384,388
22BE:  MOVFF  383,387
22C2:  MOVFF  382,386
22C6:  MOVFF  381,385
22CA:  MOVLB  0
22CC:  RCALL  21DA
22CE:  MOVFF  380,FEA
22D2:  MOVFF  37F,FE9
22D6:  MOVFF  00,FEF
22DA:  MOVFF  01,FEC
22DE:  MOVFF  02,FEC
22E2:  MOVFF  03,FEC
....................     header->AckNumber       = swapl(header->AckNumber); 
22E6:  MOVLW  08
22E8:  MOVLB  3
22EA:  ADDWF  x7D,W
22EC:  MOVWF  01
22EE:  MOVLW  00
22F0:  ADDWFC x7E,W
22F2:  MOVWF  03
22F4:  MOVFF  01,37F
22F8:  MOVWF  x80
22FA:  MOVLW  08
22FC:  ADDWF  x7D,W
22FE:  MOVWF  FE9
2300:  MOVLW  00
2302:  ADDWFC x7E,W
2304:  MOVWF  FEA
2306:  MOVFF  FEF,381
230A:  MOVFF  FEC,382
230E:  MOVFF  FEC,383
2312:  MOVFF  FEC,384
2316:  MOVFF  384,388
231A:  MOVFF  383,387
231E:  MOVFF  382,386
2322:  MOVFF  381,385
2326:  MOVLB  0
2328:  RCALL  21DA
232A:  MOVFF  380,FEA
232E:  MOVFF  37F,FE9
2332:  MOVFF  00,FEF
2336:  MOVFF  01,FEC
233A:  MOVFF  02,FEC
233E:  MOVFF  03,FEC
....................     header->Window          = swaps(header->Window); 
2342:  MOVLW  0E
2344:  MOVLB  3
2346:  ADDWF  x7D,W
2348:  MOVWF  01
234A:  MOVLW  00
234C:  ADDWFC x7E,W
234E:  MOVWF  03
2350:  MOVFF  01,37F
2354:  MOVWF  x80
2356:  MOVLW  0E
2358:  ADDWF  x7D,W
235A:  MOVWF  FE9
235C:  MOVLW  00
235E:  ADDWFC x7E,W
2360:  MOVWF  FEA
2362:  MOVFF  FEC,382
2366:  MOVF   FED,F
2368:  MOVFF  FEF,381
236C:  MOVFF  382,39D
2370:  MOVFF  381,39C
2374:  MOVLB  0
2376:  CALL   1326
237A:  MOVFF  380,FEA
237E:  MOVFF  37F,FE9
2382:  MOVFF  02,FEC
2386:  MOVF   FED,F
2388:  MOVFF  01,FEF
....................     header->Checksum        = swaps(header->Checksum); 
238C:  MOVLW  10
238E:  MOVLB  3
2390:  ADDWF  x7D,W
2392:  MOVWF  01
2394:  MOVLW  00
2396:  ADDWFC x7E,W
2398:  MOVWF  03
239A:  MOVFF  01,37F
239E:  MOVWF  x80
23A0:  MOVLW  10
23A2:  ADDWF  x7D,W
23A4:  MOVWF  FE9
23A6:  MOVLW  00
23A8:  ADDWFC x7E,W
23AA:  MOVWF  FEA
23AC:  MOVFF  FEC,382
23B0:  MOVF   FED,F
23B2:  MOVFF  FEF,381
23B6:  MOVFF  382,39D
23BA:  MOVFF  381,39C
23BE:  MOVLB  0
23C0:  CALL   1326
23C4:  MOVFF  380,FEA
23C8:  MOVFF  37F,FE9
23CC:  MOVFF  02,FEC
23D0:  MOVF   FED,F
23D2:  MOVFF  01,FEF
....................     header->UrgentPointer   = swaps(header->UrgentPointer); 
23D6:  MOVLW  12
23D8:  MOVLB  3
23DA:  ADDWF  x7D,W
23DC:  MOVWF  01
23DE:  MOVLW  00
23E0:  ADDWFC x7E,W
23E2:  MOVWF  03
23E4:  MOVFF  01,37F
23E8:  MOVWF  x80
23EA:  MOVLW  12
23EC:  ADDWF  x7D,W
23EE:  MOVWF  FE9
23F0:  MOVLW  00
23F2:  ADDWFC x7E,W
23F4:  MOVWF  FEA
23F6:  MOVFF  FEC,382
23FA:  MOVF   FED,F
23FC:  MOVFF  FEF,381
2400:  MOVFF  382,39D
2404:  MOVFF  381,39C
2408:  MOVLB  0
240A:  CALL   1326
240E:  MOVFF  380,FEA
2412:  MOVFF  37F,FE9
2416:  MOVFF  02,FEC
241A:  MOVF   FED,F
241C:  MOVFF  01,FEF
.................... } 
2420:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void CloseSocket(SOCKET_INFO* ps) 
....................  * 
....................  * PreCondition:    TCPInit() is already called 
....................  * 
....................  * Input:           ps  - Pointer to a socket info that is to be 
....................  *                          closed. 
....................  * 
....................  * Output:          Given socket information is reset and any 
....................  *                  buffer held by this socket is discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void CloseSocket(SOCKET_INFO* ps) 
.................... { 
....................    debug_tcp("\r\nTCP SOCKET CLOSED"); 
....................  
....................     if ( ps->TxBuffer != INVALID_BUFFER ) 
*
261A:  MOVLW  0F
261C:  MOVLB  3
261E:  ADDWF  x3E,W
2620:  MOVWF  FE9
2622:  MOVLW  00
2624:  ADDWFC x3F,W
2626:  MOVWF  FEA
2628:  INCFSZ FEF,W
262A:  BRA    262E
262C:  BRA    2668
....................     { 
....................         MACDiscardTx(ps->TxBuffer); 
262E:  MOVLW  0F
2630:  ADDWF  x3E,W
2632:  MOVWF  FE9
2634:  MOVLW  00
2636:  ADDWFC x3F,W
2638:  MOVWF  FEA
263A:  MOVFF  FEF,340
263E:  MOVFF  340,341
2642:  MOVLB  0
2644:  CALL   0004
....................         ps->TxBuffer            = INVALID_BUFFER; 
2648:  MOVLW  0F
264A:  MOVLB  3
264C:  ADDWF  x3E,W
264E:  MOVWF  FE9
2650:  MOVLW  00
2652:  ADDWFC x3F,W
2654:  MOVWF  FEA
2656:  MOVLW  FF
2658:  MOVWF  FEF
....................         ps->Flags.bIsPutReady   = TRUE; 
265A:  MOVLW  23
265C:  ADDWF  x3E,W
265E:  MOVWF  FE9
2660:  MOVLW  00
2662:  ADDWFC x3F,W
2664:  MOVWF  FEA
2666:  BSF    FEF.1
....................     } 
....................  
....................     ps->remote.IPAddr.Val = 0x00; 
2668:  MOVLW  07
266A:  ADDWF  x3E,W
266C:  MOVWF  FE9
266E:  MOVLW  00
2670:  ADDWFC x3F,W
2672:  MOVWF  FEA
2674:  MOVF   FEE,F
2676:  MOVF   FEE,F
2678:  CLRF   FEC
267A:  MOVF   FED,F
267C:  CLRF   FEF
267E:  MOVF   FED,F
2680:  CLRF   FEF
2682:  MOVF   FED,F
2684:  CLRF   FEF
....................     ps->remotePort = 0x00; 
2686:  MOVLW  0D
2688:  ADDWF  x3E,W
268A:  MOVWF  FE9
268C:  MOVLW  00
268E:  ADDWFC x3F,W
2690:  MOVWF  FEA
2692:  CLRF   FEC
2694:  MOVF   FED,F
2696:  CLRF   FEF
....................     if ( ps->Flags.bIsGetReady ) 
2698:  MOVLW  23
269A:  ADDWF  x3E,W
269C:  MOVWF  FE9
269E:  MOVLW  00
26A0:  ADDWFC x3F,W
26A2:  MOVWF  FEA
26A4:  BTFSS  FEF.3
26A6:  BRA    26B0
....................     { 
....................         MACDiscardRx(); 
26A8:  MOVLB  0
26AA:  CALL   1256
26AE:  MOVLB  3
....................     } 
....................     ps->Flags.bIsGetReady       = FALSE; 
26B0:  MOVLW  23
26B2:  ADDWF  x3E,W
26B4:  MOVWF  FE9
26B6:  MOVLW  00
26B8:  ADDWFC x3F,W
26BA:  MOVWF  FEA
26BC:  BCF    FEF.3
....................     ps->TimeOut                 = TCP_START_TIMEOUT_VAL; 
26BE:  MOVLW  21
26C0:  ADDWF  x3E,W
26C2:  MOVWF  FE9
26C4:  MOVLW  00
26C6:  ADDWFC x3F,W
26C8:  MOVWF  FEA
26CA:  CLRF   FEC
26CC:  MOVF   FED,F
26CE:  MOVLW  1E
26D0:  MOVWF  FEF
....................  
....................     ps->Flags.bIsTxInProgress   = FALSE; 
26D2:  MOVLW  23
26D4:  ADDWF  x3E,W
26D6:  MOVWF  FE9
26D8:  MOVLW  00
26DA:  ADDWFC x3F,W
26DC:  MOVWF  FEA
26DE:  BCF    FEF.4
....................  
....................     if ( ps->Flags.bServer ) 
26E0:  MOVLW  23
26E2:  ADDWF  x3E,W
26E4:  MOVWF  FE9
26E6:  MOVLW  00
26E8:  ADDWFC x3F,W
26EA:  MOVWF  FEA
26EC:  BTFSS  FEF.0
26EE:  BRA    26FC
....................     { 
....................         ps->smState = TCP_LISTEN; 
26F0:  MOVFF  33E,FE9
26F4:  MOVFF  33F,FEA
26F8:  CLRF   FEF
....................     } 
....................     else 
26FA:  BRA    2708
....................     { 
....................         ps->smState = TCP_CLOSED; 
26FC:  MOVFF  33E,FE9
2700:  MOVFF  33F,FEA
2704:  MOVLW  0A
2706:  MOVWF  FEF
....................     } 
....................  
....................    ps->TxCount = 0; 
2708:  MOVLW  10
270A:  ADDWF  x3E,W
270C:  MOVWF  FE9
270E:  MOVLW  00
2710:  ADDWFC x3F,W
2712:  MOVWF  FEA
2714:  CLRF   FEC
2716:  MOVF   FED,F
2718:  CLRF   FEF
....................  
....................     return; 
.................... } 
271A:  MOVLB  0
271C:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        static void HandleTCPSeg(TCP_SOCKET s, 
.................... *                                      NODE_INFO *remote, 
.................... *                                      TCP_HEADER* h, 
.................... *                                      WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPProcess() is the caller. 
.................... * 
.................... * Input:           s           - Socket that owns this segment 
.................... *                  remote      - Remote node info 
.................... *                  h           - TCP Header 
.................... *                  len         - Total buffer length. 
.................... * 
.................... * Output:          TCP FSM is executed on given socket with 
.................... *                  given TCP segment. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... static void HandleTCPSeg(TCP_SOCKET s, 
....................                    NODE_INFO *remote, 
....................                    TCP_HEADER *h, 
....................                    WORD len) 
.................... { 
....................    DWORD ack; 
....................    DWORD seq; 
....................    DWORD prevAck, prevSeq; 
....................    SOCKET_INFO *ps; 
....................    BYTE flags; 
....................    //BYTE debugLastState; 
....................    signed int32 temp; 
....................  
....................    ps = &TCB[s]; 
*
2C6E:  MOVLB  3
2C70:  MOVF   x20,W
2C72:  MULLW  24
2C74:  MOVF   FF3,W
2C76:  CLRF   03
2C78:  ADDLW  5E
2C7A:  MOVWF  01
2C7C:  MOVLW  00
2C7E:  ADDWFC 03,F
2C80:  MOVFF  01,337
2C84:  MOVFF  03,338
....................    //debugLastState = TCB[s].smState; 
....................  
....................    flags = 0x00; 
2C88:  CLRF   x39
....................  
....................    // Clear timeout info 
....................    ps->RetryCount  = 0; 
2C8A:  MOVLW  1E
2C8C:  ADDWF  x37,W
2C8E:  MOVWF  FE9
2C90:  MOVLW  00
2C92:  ADDWFC x38,W
2C94:  MOVWF  FEA
2C96:  CLRF   FEF
....................    ps->startTick   = TickGet(); 
2C98:  MOVLW  1F
2C9A:  ADDWF  x37,W
2C9C:  MOVWF  01
2C9E:  MOVLW  00
2CA0:  ADDWFC x38,W
2CA2:  MOVWF  03
2CA4:  MOVFF  01,33E
2CA8:  MOVWF  x3F
2CAA:  MOVLB  0
2CAC:  RCALL  2600
2CAE:  MOVFF  33F,FEA
2CB2:  MOVFF  33E,FE9
2CB6:  MOVFF  02,FEC
2CBA:  MOVF   FED,F
2CBC:  MOVFF  01,FEF
....................    ps->TimeOut = TCP_START_TIMEOUT_VAL; 
2CC0:  MOVLW  21
2CC2:  MOVLB  3
2CC4:  ADDWF  x37,W
2CC6:  MOVWF  FE9
2CC8:  MOVLW  00
2CCA:  ADDWFC x38,W
2CCC:  MOVWF  FEA
2CCE:  CLRF   FEC
2CD0:  MOVF   FED,F
2CD2:  MOVLW  1E
2CD4:  MOVWF  FEF
....................  
....................    debug_tcp("\r\nTCP IN <= SP:%LX DP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X\r\n", 
....................       h->SourcePort, 
....................       h->DestPort, 
....................       h->SeqNumber, 
....................       h->AckNumber, 
....................       len, 
....................       h->Flags 
....................    ); 
....................  
....................  
....................    // Reset FSM, if RST is received. 
....................    if(h->Flags.bits.flagRST) 
2CD6:  MOVLW  0D
2CD8:  ADDWF  x23,W
2CDA:  MOVWF  FE9
2CDC:  MOVLW  00
2CDE:  ADDWFC x24,W
2CE0:  MOVWF  FEA
2CE2:  BTFSS  FEF.2
2CE4:  BRA    2D22
....................    { 
....................       MACDiscardRx(); 
2CE6:  MOVLB  0
2CE8:  CALL   1256
....................       ps->smState = ps->Flags.bServer ? TCP_LISTEN : TCP_SYN_SENT; 
2CEC:  MOVLB  3
2CEE:  MOVFF  337,01
2CF2:  MOVFF  338,03
2CF6:  MOVFF  337,33E
2CFA:  MOVFF  338,33F
2CFE:  MOVLW  23
2D00:  ADDWF  x37,W
2D02:  MOVWF  FE9
2D04:  MOVLW  00
2D06:  ADDWFC x38,W
2D08:  MOVWF  FEA
2D0A:  BTFSS  FEF.0
2D0C:  BRA    2D12
2D0E:  MOVLW  00
2D10:  BRA    2D14
2D12:  MOVLW  01
2D14:  MOVFF  33F,FEA
2D18:  MOVFF  33E,FE9
2D1C:  MOVWF  FEF
....................       return; 
2D1E:  GOTO   373A
....................    } 
....................  
....................    seq = ps->SND_SEQ; 
2D22:  MOVLW  16
2D24:  ADDWF  x37,W
2D26:  MOVWF  FE9
2D28:  MOVLW  00
2D2A:  ADDWFC x38,W
2D2C:  MOVWF  FEA
2D2E:  MOVFF  FEF,00
2D32:  MOVFF  FEC,01
2D36:  MOVFF  FEC,02
2D3A:  MOVFF  FEC,03
2D3E:  MOVFF  03,32E
2D42:  MOVFF  02,32D
2D46:  MOVFF  01,32C
2D4A:  MOVFF  00,32B
....................  
....................    temp = (signed int32)h->Window - ((signed int32)seq - (signed int32)h->AckNumber) - (signed int32)ps->TxCount; 
2D4E:  MOVLW  0E
2D50:  ADDWF  x23,W
2D52:  MOVWF  FE9
2D54:  MOVLW  00
2D56:  ADDWFC x24,W
2D58:  MOVWF  FEA
2D5A:  MOVFF  FEC,03
2D5E:  MOVF   FED,F
2D60:  MOVFF  FEF,33E
2D64:  MOVFF  03,33F
2D68:  CLRF   x40
2D6A:  CLRF   x41
2D6C:  MOVLW  08
2D6E:  ADDWF  x23,W
2D70:  MOVWF  FE9
2D72:  MOVLW  00
2D74:  ADDWFC x24,W
2D76:  MOVWF  FEA
2D78:  MOVFF  FEF,00
2D7C:  MOVFF  FEC,01
2D80:  MOVFF  FEC,02
2D84:  MOVFF  FEC,03
2D88:  MOVF   00,W
2D8A:  SUBWF  x2B,W
2D8C:  MOVWF  00
2D8E:  MOVF   01,W
2D90:  SUBWFB x2C,W
2D92:  MOVWF  01
2D94:  MOVF   02,W
2D96:  SUBWFB x2D,W
2D98:  MOVWF  02
2D9A:  MOVF   03,W
2D9C:  SUBWFB x2E,W
2D9E:  MOVWF  03
2DA0:  MOVF   00,W
2DA2:  SUBWF  x3E,F
2DA4:  MOVF   01,W
2DA6:  SUBWFB x3F,F
2DA8:  MOVF   02,W
2DAA:  SUBWFB x40,F
2DAC:  MOVF   03,W
2DAE:  SUBWFB x41,F
2DB0:  MOVLW  10
2DB2:  ADDWF  x37,W
2DB4:  MOVWF  FE9
2DB6:  MOVLW  00
2DB8:  ADDWFC x38,W
2DBA:  MOVWF  FEA
2DBC:  MOVFF  FEC,03
2DC0:  MOVF   FED,F
2DC2:  MOVFF  FEF,00
2DC6:  MOVFF  03,01
2DCA:  CLRF   02
2DCC:  CLRF   03
2DCE:  MOVF   00,W
2DD0:  SUBWF  x3E,W
2DD2:  MOVWF  x3A
2DD4:  MOVF   01,W
2DD6:  SUBWFB x3F,W
2DD8:  MOVWF  x3B
2DDA:  MOVF   02,W
2DDC:  SUBWFB x40,W
2DDE:  MOVWF  x3C
2DE0:  MOVF   03,W
2DE2:  SUBWFB x41,W
2DE4:  MOVWF  x3D
....................    if(temp < 0) 
2DE6:  BTFSC  x3D.7
2DE8:  BRA    2DEC
2DEA:  BRA    2E00
....................    { 
....................       ps->RemoteWindow = 0; 
2DEC:  MOVLW  14
2DEE:  ADDWF  x37,W
2DF0:  MOVWF  FE9
2DF2:  MOVLW  00
2DF4:  ADDWFC x38,W
2DF6:  MOVWF  FEA
2DF8:  CLRF   FEC
2DFA:  MOVF   FED,F
2DFC:  CLRF   FEF
....................       debug_tcp("\r\nRW1 => %LX, res=%LX W=%LX S=%LX A=%LX C=%LX\r\n", 
....................             ps->RemoteWindow, 
....................             temp, 
....................             h->Window, 
....................             seq, 
....................             h->AckNumber, 
....................             ps->TxCount 
....................          ); 
....................    } 
....................    else 
2DFE:  BRA    2E14
....................    { 
....................       ps->RemoteWindow = ack; 
2E00:  MOVLW  14
2E02:  ADDWF  x37,W
2E04:  MOVWF  FE9
2E06:  MOVLW  00
2E08:  ADDWFC x38,W
2E0A:  MOVWF  FEA
2E0C:  MOVFF  327,FEF
2E10:  MOVFF  328,FEC
....................       debug_tcp("\r\nRW2 => %LX\r\n", ps->RemoteWindow); 
....................    } 
....................  
....................    // Handle TCP_SYN_SENT state 
....................    // The TCP_SYN_SENT state occurs when an application 
....................    // calls TCPConnect().  After an initial SYN is sent, 
....................    // we expect a SYN + ACK before establishing the 
....................    // connection. 
....................    if(ps->smState == TCP_SYN_SENT) 
2E14:  MOVFF  337,FE9
2E18:  MOVFF  338,FEA
2E1C:  DECFSZ FEF,W
2E1E:  BRA    2F9C
....................    { 
....................       // Check if this is a SYN packet.  Unsynchronized, we cannot 
....................       // handle any other packet types. 
....................       if(!h->Flags.bits.flagSYN) 
2E20:  MOVLW  0D
2E22:  ADDWF  x23,W
2E24:  MOVWF  FE9
2E26:  MOVLW  00
2E28:  ADDWFC x24,W
2E2A:  MOVWF  FEA
2E2C:  BTFSC  FEF.1
2E2E:  BRA    2E54
....................       { 
....................          MACDiscardRx(); 
2E30:  MOVLB  0
2E32:  CALL   1256
....................  
....................          // Send out a RESET if the remote node thinks a connection is already established 
....................           if(h->Flags.bits.flagACK) 
2E36:  MOVLW  0D
2E38:  MOVLB  3
2E3A:  ADDWF  x23,W
2E3C:  MOVWF  FE9
2E3E:  MOVLW  00
2E40:  ADDWFC x24,W
2E42:  MOVWF  FEA
2E44:  BTFSS  FEF.4
2E46:  BRA    2E50
....................           { 
....................             flags = RST; 
2E48:  MOVLW  04
2E4A:  MOVWF  x39
....................             goto SendTCPControlPacket; 
2E4C:  GOTO   36C2
....................            } 
....................  
....................          return; 
2E50:  GOTO   373A
....................       } 
....................  
....................       // We now have a sequence number for the remote node 
....................       ps->SND_ACK = h->SeqNumber + len + 1; 
2E54:  MOVLW  1A
2E56:  ADDWF  x37,W
2E58:  MOVWF  01
2E5A:  MOVLW  00
2E5C:  ADDWFC x38,W
2E5E:  MOVFF  01,33E
2E62:  MOVWF  x3F
2E64:  MOVLW  04
2E66:  ADDWF  x23,W
2E68:  MOVWF  FE9
2E6A:  MOVLW  00
2E6C:  ADDWFC x24,W
2E6E:  MOVWF  FEA
2E70:  MOVFF  FEF,340
2E74:  MOVFF  FEC,341
2E78:  MOVFF  FEC,342
2E7C:  MOVFF  FEC,343
2E80:  MOVF   x25,W
2E82:  ADDWF  x40,F
2E84:  MOVF   x26,W
2E86:  ADDWFC x41,F
2E88:  MOVLW  00
2E8A:  ADDWFC x42,F
2E8C:  ADDWFC x43,F
2E8E:  MOVLW  01
2E90:  ADDWF  x40,W
2E92:  MOVWF  00
2E94:  MOVLW  00
2E96:  ADDWFC x41,W
2E98:  MOVWF  01
2E9A:  MOVLW  00
2E9C:  ADDWFC x42,W
2E9E:  MOVWF  02
2EA0:  MOVLW  00
2EA2:  ADDWFC x43,W
2EA4:  MOVFF  33F,FEA
2EA8:  MOVFF  33E,FE9
2EAC:  MOVFF  00,FEF
2EB0:  MOVFF  01,FEC
2EB4:  MOVFF  02,FEC
2EB8:  MOVWF  FEC
....................       ack = ps->SND_ACK; 
2EBA:  MOVLW  1A
2EBC:  ADDWF  x37,W
2EBE:  MOVWF  FE9
2EC0:  MOVLW  00
2EC2:  ADDWFC x38,W
2EC4:  MOVWF  FEA
2EC6:  MOVFF  FEF,00
2ECA:  MOVFF  FEC,01
2ECE:  MOVFF  FEC,02
2ED2:  MOVFF  FEC,03
2ED6:  MOVFF  03,32A
2EDA:  MOVFF  02,329
2EDE:  MOVFF  01,328
2EE2:  MOVFF  00,327
....................  
....................       // If there is no ACK, we must go to TCP_SYN_RECEIVED.  With an ACK, 
....................       // we can establish the connection now. 
....................       if(!h->Flags.bits.flagACK) 
2EE6:  MOVLW  0D
2EE8:  ADDWF  x23,W
2EEA:  MOVWF  FE9
2EEC:  MOVLW  00
2EEE:  ADDWFC x24,W
2EF0:  MOVWF  FEA
2EF2:  BTFSC  FEF.4
2EF4:  BRA    2F12
....................       { 
....................          ps->smState = TCP_SYN_RECEIVED; 
2EF6:  MOVFF  337,FE9
2EFA:  MOVFF  338,FEA
2EFE:  MOVLW  02
2F00:  MOVWF  FEF
....................          MACDiscardRx(); 
2F02:  MOVLB  0
2F04:  CALL   1256
....................          // Send out a SYN+ACK for simultaneous connection open 
....................          flags = SYN | ACK; 
2F08:  MOVLW  12
2F0A:  MOVLB  3
2F0C:  MOVWF  x39
....................          goto SendTCPControlPacket; 
2F0E:  GOTO   36C2
....................       } 
....................  
....................       // We received SYN+ACK, establish the connection now 
....................       ps->smState = TCP_ESTABLISHED; 
2F12:  MOVFF  337,FE9
2F16:  MOVFF  338,FEA
2F1A:  MOVLW  03
2F1C:  MOVWF  FEF
....................       // Send out an ACK 
....................       flags = ACK; 
2F1E:  MOVLW  10
2F20:  MOVWF  x39
....................  
....................       ps->RemoteWindow = h->Window; 
2F22:  MOVLW  14
2F24:  ADDWF  x37,W
2F26:  MOVWF  01
2F28:  MOVLW  00
2F2A:  ADDWFC x38,W
2F2C:  MOVWF  03
2F2E:  MOVWF  x3F
2F30:  MOVLW  0E
2F32:  ADDWF  x23,W
2F34:  MOVWF  FE9
2F36:  MOVLW  00
2F38:  ADDWFC x24,W
2F3A:  MOVWF  FEA
2F3C:  MOVFF  FEC,03
2F40:  MOVF   FED,F
2F42:  MOVFF  FEF,340
2F46:  MOVFF  33F,FEA
2F4A:  MOVFF  01,FE9
2F4E:  MOVFF  03,FEC
2F52:  MOVF   FED,F
2F54:  MOVFF  340,FEF
....................       debug_tcp("\r\nRW3 => %LX\r\n", ps->RemoteWindow); 
....................  
....................       // Check for application data and make it 
....................       // available, if present 
....................       if(len) 
2F58:  MOVF   x25,W
2F5A:  IORWF  x26,W
2F5C:  BZ    2F92
....................       { 
....................          ps->Flags.bIsGetReady   = TRUE; 
2F5E:  MOVLW  23
2F60:  ADDWF  x37,W
2F62:  MOVWF  FE9
2F64:  MOVLW  00
2F66:  ADDWFC x38,W
2F68:  MOVWF  FEA
2F6A:  BSF    FEF.3
....................          ps->RxCount             = len; 
2F6C:  MOVLW  12
2F6E:  ADDWF  x37,W
2F70:  MOVWF  FE9
2F72:  MOVLW  00
2F74:  ADDWFC x38,W
2F76:  MOVWF  FEA
2F78:  MOVFF  326,FEC
2F7C:  MOVF   FED,F
2F7E:  MOVFF  325,FEF
....................          ps->Flags.bFirstRead    = TRUE; 
2F82:  MOVLW  23
2F84:  ADDWF  x37,W
2F86:  MOVWF  FE9
2F88:  MOVLW  00
2F8A:  ADDWFC x38,W
2F8C:  MOVWF  FEA
2F8E:  BSF    FEF.2
....................       } 
....................       else   // No application data in this packet 
2F90:  BRA    2F9A
....................       { 
....................          MACDiscardRx(); 
2F92:  MOVLB  0
2F94:  CALL   1256
2F98:  MOVLB  3
....................       } 
....................       goto SendTCPControlPacket; 
2F9A:  BRA    36C2
....................    } 
....................  
....................    // Handle TCP_LISTEN state 
....................    if(ps->smState == TCP_LISTEN ) 
2F9C:  MOVFF  337,FE9
2FA0:  MOVFF  338,FEA
2FA4:  MOVF   FEF,F
2FA6:  BTFSS  FD8.2
2FA8:  BRA    3132
....................    { 
....................       MACDiscardRx(); 
2FAA:  MOVLB  0
2FAC:  CALL   1256
....................  
....................       // Send a RST if this isn't a SYN packet 
....................       if(!h->Flags.bits.flagSYN) 
2FB0:  MOVLW  0D
2FB2:  MOVLB  3
2FB4:  ADDWF  x23,W
2FB6:  MOVWF  FE9
2FB8:  MOVLW  00
2FBA:  ADDWFC x24,W
2FBC:  MOVWF  FEA
2FBE:  BTFSC  FEF.1
2FC0:  BRA    2FC8
....................       { 
....................          flags = RST; 
2FC2:  MOVLW  04
2FC4:  MOVWF  x39
....................          goto SendTCPControlPacket; 
2FC6:  BRA    36C2
....................       } 
....................  
....................       ps->SND_ACK = h->SeqNumber + len + 1; 
2FC8:  MOVLW  1A
2FCA:  ADDWF  x37,W
2FCC:  MOVWF  01
2FCE:  MOVLW  00
2FD0:  ADDWFC x38,W
2FD2:  MOVFF  01,33E
2FD6:  MOVWF  x3F
2FD8:  MOVLW  04
2FDA:  ADDWF  x23,W
2FDC:  MOVWF  FE9
2FDE:  MOVLW  00
2FE0:  ADDWFC x24,W
2FE2:  MOVWF  FEA
2FE4:  MOVFF  FEF,340
2FE8:  MOVFF  FEC,341
2FEC:  MOVFF  FEC,342
2FF0:  MOVFF  FEC,343
2FF4:  MOVF   x25,W
2FF6:  ADDWF  x40,F
2FF8:  MOVF   x26,W
2FFA:  ADDWFC x41,F
2FFC:  MOVLW  00
2FFE:  ADDWFC x42,F
3000:  ADDWFC x43,F
3002:  MOVLW  01
3004:  ADDWF  x40,W
3006:  MOVWF  00
3008:  MOVLW  00
300A:  ADDWFC x41,W
300C:  MOVWF  01
300E:  MOVLW  00
3010:  ADDWFC x42,W
3012:  MOVWF  02
3014:  MOVLW  00
3016:  ADDWFC x43,W
3018:  MOVFF  33F,FEA
301C:  MOVFF  33E,FE9
3020:  MOVFF  00,FEF
3024:  MOVFF  01,FEC
3028:  MOVFF  02,FEC
302C:  MOVWF  FEC
....................       ps->RemoteWindow = h->Window; 
302E:  MOVLW  14
3030:  ADDWF  x37,W
3032:  MOVWF  01
3034:  MOVLW  00
3036:  ADDWFC x38,W
3038:  MOVWF  03
303A:  MOVWF  x3F
303C:  MOVLW  0E
303E:  ADDWF  x23,W
3040:  MOVWF  FE9
3042:  MOVLW  00
3044:  ADDWFC x24,W
3046:  MOVWF  FEA
3048:  MOVFF  FEC,03
304C:  MOVF   FED,F
304E:  MOVFF  FEF,340
3052:  MOVFF  33F,FEA
3056:  MOVFF  01,FE9
305A:  MOVFF  03,FEC
305E:  MOVF   FED,F
3060:  MOVFF  340,FEF
....................       debug_tcp("\r\nRW4 => %LX\r\n", ps->RemoteWindow); 
....................  
....................       // This socket has received connection request (SYN). 
....................       // Remember calling node, assign next segment seq. number 
....................       // for this potential connection. 
....................       memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote)); 
3064:  MOVLW  01
3066:  ADDWF  x37,W
3068:  MOVWF  x3E
306A:  MOVLW  00
306C:  ADDWFC x38,W
306E:  MOVWF  x3F
3070:  MOVWF  FEA
3072:  MOVFF  33E,FE9
3076:  MOVFF  322,FE2
307A:  MOVFF  321,FE1
307E:  MOVLW  0A
3080:  MOVWF  01
3082:  MOVFF  FE6,FEE
3086:  DECFSZ 01,F
3088:  BRA    3082
....................       ps->remotePort = h->SourcePort; 
308A:  MOVLW  0D
308C:  ADDWF  x37,W
308E:  MOVWF  01
3090:  MOVLW  00
3092:  ADDWFC x38,W
3094:  MOVFF  323,FE9
3098:  MOVFF  324,FEA
309C:  MOVFF  FEC,03
30A0:  MOVF   FED,F
30A2:  MOVFF  FEF,340
30A6:  MOVWF  FEA
30A8:  MOVFF  01,FE9
30AC:  MOVFF  03,FEC
30B0:  MOVF   FED,F
30B2:  MOVFF  340,FEF
....................  
....................       // Grant connection request. 
....................       ps->smState = TCP_SYN_RECEIVED; 
30B6:  MOVFF  337,FE9
30BA:  MOVFF  338,FEA
30BE:  MOVLW  02
30C0:  MOVWF  FEF
....................       seq = ps->SND_SEQ++; 
30C2:  MOVLW  16
30C4:  ADDWF  x37,W
30C6:  MOVWF  FE9
30C8:  MOVLW  00
30CA:  ADDWFC x38,W
30CC:  MOVWF  FEA
30CE:  MOVF   FEE,F
30D0:  MOVF   FEE,F
30D2:  MOVF   FEE,F
30D4:  MOVFF  FED,03
30D8:  MOVFF  FED,02
30DC:  MOVFF  FED,01
30E0:  MOVFF  FEF,00
30E4:  MOVLW  01
30E6:  ADDWF  FEE,F
30E8:  MOVLW  00
30EA:  ADDWFC FEE,F
30EC:  ADDWFC FEE,F
30EE:  ADDWFC FED,F
30F0:  MOVFF  03,32E
30F4:  MOVFF  02,32D
30F8:  MOVFF  01,32C
30FC:  MOVFF  00,32B
....................       ack =  ps->SND_ACK; 
3100:  MOVLW  1A
3102:  ADDWF  x37,W
3104:  MOVWF  FE9
3106:  MOVLW  00
3108:  ADDWFC x38,W
310A:  MOVWF  FEA
310C:  MOVFF  FEF,00
3110:  MOVFF  FEC,01
3114:  MOVFF  FEC,02
3118:  MOVFF  FEC,03
311C:  MOVFF  03,32A
3120:  MOVFF  02,329
3124:  MOVFF  01,328
3128:  MOVFF  00,327
....................       flags = SYN | ACK; 
312C:  MOVLW  12
312E:  MOVWF  x39
....................       goto SendTCPControlPacket; 
3130:  BRA    36C2
....................    } 
....................  
....................  
....................    // Remember current seq and ack for our connection so that if 
....................    // we have to silently discard this packet, we can go back to 
....................    // previous ack and seq numbers. 
....................    prevAck = ps->SND_ACK; 
3132:  MOVLW  1A
3134:  ADDWF  x37,W
3136:  MOVWF  FE9
3138:  MOVLW  00
313A:  ADDWFC x38,W
313C:  MOVWF  FEA
313E:  MOVFF  FEF,00
3142:  MOVFF  FEC,01
3146:  MOVFF  FEC,02
314A:  MOVFF  FEC,03
314E:  MOVFF  03,332
3152:  MOVFF  02,331
3156:  MOVFF  01,330
315A:  MOVFF  00,32F
....................    prevSeq = ps->SND_SEQ; 
315E:  MOVLW  16
3160:  ADDWF  x37,W
3162:  MOVWF  FE9
3164:  MOVLW  00
3166:  ADDWFC x38,W
3168:  MOVWF  FEA
316A:  MOVFF  FEF,00
316E:  MOVFF  FEC,01
3172:  MOVFF  FEC,02
3176:  MOVFF  FEC,03
317A:  MOVFF  03,336
317E:  MOVFF  02,335
3182:  MOVFF  01,334
3186:  MOVFF  00,333
....................  
....................    ack = h->SeqNumber; 
318A:  MOVLW  04
318C:  ADDWF  x23,W
318E:  MOVWF  FE9
3190:  MOVLW  00
3192:  ADDWFC x24,W
3194:  MOVWF  FEA
3196:  MOVFF  FEF,00
319A:  MOVFF  FEC,01
319E:  MOVFF  FEC,02
31A2:  MOVFF  FEC,03
31A6:  MOVFF  03,32A
31AA:  MOVFF  02,329
31AE:  MOVFF  01,328
31B2:  MOVFF  00,327
....................    ack += (DWORD)len; 
31B6:  CLRF   02
31B8:  CLRF   03
31BA:  MOVF   x25,W
31BC:  ADDWF  x27,F
31BE:  MOVF   x26,W
31C0:  ADDWFC x28,F
31C2:  MOVF   02,W
31C4:  ADDWFC x29,F
31C6:  MOVF   03,W
31C8:  ADDWFC x2A,F
....................    seq = ps->SND_SEQ; 
31CA:  MOVLW  16
31CC:  ADDWF  x37,W
31CE:  MOVWF  FE9
31D0:  MOVLW  00
31D2:  ADDWFC x38,W
31D4:  MOVWF  FEA
31D6:  MOVFF  FEF,00
31DA:  MOVFF  FEC,01
31DE:  MOVFF  FEC,02
31E2:  MOVFF  FEC,03
31E6:  MOVFF  03,32E
31EA:  MOVFF  02,32D
31EE:  MOVFF  01,32C
31F2:  MOVFF  00,32B
....................  
....................    // State is something other than TCP_LISTEN, handle it. 
....................    { 
....................       // Check to see if the incomming sequence number is what 
....................       // we expect (last transmitted ACK value).  Throw this packet 
....................       // away if it is wrong. 
....................       if(h->SeqNumber == prevAck) 
31F6:  MOVLW  04
31F8:  ADDWF  x23,W
31FA:  MOVWF  FE9
31FC:  MOVLW  00
31FE:  ADDWFC x24,W
3200:  MOVWF  FEA
3202:  MOVFF  FEF,33E
3206:  MOVFF  FEC,33F
320A:  MOVFF  FEC,340
320E:  MOVFF  FEC,341
3212:  MOVF   x2F,W
3214:  SUBWF  x3E,W
3216:  BTFSS  FD8.2
3218:  BRA    36A6
321A:  MOVF   x30,W
321C:  SUBWF  x3F,W
321E:  BTFSS  FD8.2
3220:  BRA    36A6
3222:  MOVF   x31,W
3224:  SUBWF  x40,W
3226:  BTFSS  FD8.2
3228:  BRA    36A6
322A:  MOVF   x32,W
322C:  SUBWF  x41,W
322E:  BTFSS  FD8.2
3230:  BRA    36A6
....................       { 
....................          // After receiving a SYNchronization request, we expect an 
....................          // ACK to our transmitted SYN 
....................          if(ps->smState == TCP_SYN_RECEIVED) 
3232:  MOVFF  337,FE9
3236:  MOVFF  338,FEA
323A:  MOVF   FEF,W
323C:  SUBLW  02
323E:  BNZ   32C6
....................          { 
....................             if(h->Flags.bits.flagACK) 
3240:  MOVLW  0D
3242:  ADDWF  x23,W
3244:  MOVWF  FE9
3246:  MOVLW  00
3248:  ADDWFC x24,W
324A:  MOVWF  FEA
324C:  BTFSS  FEF.4
324E:  BRA    32BC
....................             { 
....................                // ACK received as expected, this connection is 
....................                // now established 
....................                ps->SND_ACK = ack; 
3250:  MOVLW  1A
3252:  ADDWF  x37,W
3254:  MOVWF  FE9
3256:  MOVLW  00
3258:  ADDWFC x38,W
325A:  MOVWF  FEA
325C:  MOVFF  327,FEF
3260:  MOVFF  328,FEC
3264:  MOVFF  329,FEC
3268:  MOVFF  32A,FEC
....................                ps->smState = TCP_ESTABLISHED; 
326C:  MOVFF  337,FE9
3270:  MOVFF  338,FEA
3274:  MOVLW  03
3276:  MOVWF  FEF
....................  
....................                // Check if this first packet has application data 
....................                // in it.  Make it available if so. 
....................                if(len) 
3278:  MOVF   x25,W
327A:  IORWF  x26,W
327C:  BZ    32B2
....................                { 
....................                   ps->Flags.bIsGetReady   = TRUE; 
327E:  MOVLW  23
3280:  ADDWF  x37,W
3282:  MOVWF  FE9
3284:  MOVLW  00
3286:  ADDWFC x38,W
3288:  MOVWF  FEA
328A:  BSF    FEF.3
....................                   ps->RxCount             = len; 
328C:  MOVLW  12
328E:  ADDWF  x37,W
3290:  MOVWF  FE9
3292:  MOVLW  00
3294:  ADDWFC x38,W
3296:  MOVWF  FEA
3298:  MOVFF  326,FEC
329C:  MOVF   FED,F
329E:  MOVFF  325,FEF
....................                   ps->Flags.bFirstRead    = TRUE; 
32A2:  MOVLW  23
32A4:  ADDWF  x37,W
32A6:  MOVWF  FE9
32A8:  MOVLW  00
32AA:  ADDWFC x38,W
32AC:  MOVWF  FEA
32AE:  BSF    FEF.2
....................                } 
....................                else 
32B0:  BRA    32BA
....................                   MACDiscardRx(); 
32B2:  MOVLB  0
32B4:  CALL   1256
32B8:  MOVLB  3
....................             } 
....................             else   // No ACK to our SYN 
32BA:  BRA    32C4
....................             { 
....................                MACDiscardRx(); 
32BC:  MOVLB  0
32BE:  CALL   1256
32C2:  MOVLB  3
....................             } 
....................          } 
....................          // Connection is established, closing, or otherwise 
....................          else 
32C4:  BRA    36A4
....................          { 
....................  
....................             // Save the seq+len value of the packet for our future 
....................             // ACK transmission, and so out of sequence packets 
....................             // can be detected in the future. 
....................             ps->SND_ACK = ack; 
32C6:  MOVLW  1A
32C8:  ADDWF  x37,W
32CA:  MOVWF  FE9
32CC:  MOVLW  00
32CE:  ADDWFC x38,W
32D0:  MOVWF  FEA
32D2:  MOVFF  327,FEF
32D6:  MOVFF  328,FEC
32DA:  MOVFF  329,FEC
32DE:  MOVFF  32A,FEC
....................  
....................             // Handle packets received while connection established. 
....................             if(ps->smState == TCP_ESTABLISHED) 
32E2:  MOVFF  337,FE9
32E6:  MOVFF  338,FEA
32EA:  MOVF   FEF,W
32EC:  SUBLW  03
32EE:  BTFSS  FD8.2
32F0:  BRA    34B6
....................             { 
....................                // If this packet has the ACK set, mark all 
....................                // previous TX packets as no longer needed for 
....................                // possible retransmission. 
....................                // TODO: Make this more sophisticated so that partial ACKs due to fragmentation are handled correctly.  i.e. Keep a real output stream buffer with slidable window capability. 
....................                if(h->Flags.bits.flagACK && !ps->Flags.bIsPutReady) 
32F2:  MOVLW  0D
32F4:  ADDWF  x23,W
32F6:  MOVWF  FE9
32F8:  MOVLW  00
32FA:  ADDWFC x24,W
32FC:  MOVWF  FEA
32FE:  BTFSS  FEF.4
3300:  BRA    335E
3302:  MOVLW  23
3304:  ADDWF  x37,W
3306:  MOVWF  FE9
3308:  MOVLW  00
330A:  ADDWFC x38,W
330C:  MOVWF  FEA
330E:  BTFSC  FEF.1
3310:  BRA    335E
....................                { 
....................                   if(ps->TxBuffer != INVALID_BUFFER) 
3312:  MOVLW  0F
3314:  ADDWF  x37,W
3316:  MOVWF  FE9
3318:  MOVLW  00
331A:  ADDWFC x38,W
331C:  MOVWF  FEA
331E:  INCFSZ FEF,W
3320:  BRA    3324
3322:  BRA    335E
....................                   { 
....................                      MACDiscardTx(ps->TxBuffer); 
3324:  MOVLW  0F
3326:  ADDWF  x37,W
3328:  MOVWF  FE9
332A:  MOVLW  00
332C:  ADDWFC x38,W
332E:  MOVWF  FEA
3330:  MOVFF  FEF,33E
3334:  MOVFF  33E,341
3338:  MOVLB  0
333A:  CALL   0004
....................                      ps->TxBuffer            = INVALID_BUFFER; 
333E:  MOVLW  0F
3340:  MOVLB  3
3342:  ADDWF  x37,W
3344:  MOVWF  FE9
3346:  MOVLW  00
3348:  ADDWFC x38,W
334A:  MOVWF  FEA
334C:  MOVLW  FF
334E:  MOVWF  FEF
....................                      ps->Flags.bIsPutReady   = TRUE; 
3350:  MOVLW  23
3352:  ADDWF  x37,W
3354:  MOVWF  FE9
3356:  MOVLW  00
3358:  ADDWFC x38,W
335A:  MOVWF  FEA
335C:  BSF    FEF.1
....................                   } 
....................                } 
....................  
....................                // Check if the remote node is closing the connection 
....................                if(h->Flags.bits.flagFIN) 
335E:  MOVLW  0D
3360:  ADDWF  x23,W
3362:  MOVWF  FE9
3364:  MOVLW  00
3366:  ADDWFC x24,W
3368:  MOVWF  FEA
336A:  BTFSS  FEF.0
336C:  BRA    341E
....................                { 
....................                   //DebugPrint("|"); 
....................                   flags = FIN | ACK; 
336E:  MOVLW  11
3370:  MOVWF  x39
....................                   seq = ps->SND_SEQ++; 
3372:  MOVLW  16
3374:  ADDWF  x37,W
3376:  MOVWF  FE9
3378:  MOVLW  00
337A:  ADDWFC x38,W
337C:  MOVWF  FEA
337E:  MOVF   FEE,F
3380:  MOVF   FEE,F
3382:  MOVF   FEE,F
3384:  MOVFF  FED,03
3388:  MOVFF  FED,02
338C:  MOVFF  FED,01
3390:  MOVFF  FEF,00
3394:  MOVLW  01
3396:  ADDWF  FEE,F
3398:  MOVLW  00
339A:  ADDWFC FEE,F
339C:  ADDWFC FEE,F
339E:  ADDWFC FED,F
33A0:  MOVFF  03,32E
33A4:  MOVFF  02,32D
33A8:  MOVFF  01,32C
33AC:  MOVFF  00,32B
....................                   //ack = ++ps->SND_ACK;   /////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
33B0:  MOVLW  1A
33B2:  ADDWF  x37,W
33B4:  MOVWF  FE9
33B6:  MOVLW  00
33B8:  ADDWFC x38,W
33BA:  MOVWF  FEA
33BC:  MOVLW  01
33BE:  ADDWF  FEF,W
33C0:  MOVWF  00
33C2:  MOVLW  00
33C4:  ADDWFC FEC,W
33C6:  MOVWF  01
33C8:  MOVLW  00
33CA:  ADDWFC FEC,W
33CC:  MOVWF  02
33CE:  MOVLW  00
33D0:  ADDWFC FEC,W
33D2:  MOVF   FED,F
33D4:  MOVF   FED,F
33D6:  MOVF   FED,F
33D8:  MOVFF  00,FEF
33DC:  MOVFF  01,FEC
33E0:  MOVFF  02,FEC
33E4:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
33E6:  MOVLW  1A
33E8:  ADDWF  x37,W
33EA:  MOVWF  FE9
33EC:  MOVLW  00
33EE:  ADDWFC x38,W
33F0:  MOVWF  FEA
33F2:  MOVFF  FEF,00
33F6:  MOVFF  FEC,01
33FA:  MOVFF  FEC,02
33FE:  MOVFF  FEC,03
3402:  MOVFF  03,32A
3406:  MOVFF  02,329
340A:  MOVFF  01,328
340E:  MOVFF  00,327
....................                   ps->smState = TCP_LAST_ACK; 
3412:  MOVFF  337,FE9
3416:  MOVFF  338,FEA
341A:  MOVLW  09
341C:  MOVWF  FEF
....................                } 
....................  
....................                // Check if there is any application data in 
....................                // this packet. 
....................                if(len) 
341E:  MOVF   x25,W
3420:  IORWF  x26,W
3422:  BZ    34AC
....................                { 
....................                   // There is data.  Make it available if we 
....................                   // don't already have data available. 
....................                   if(!ps->Flags.bIsGetReady) 
3424:  MOVLW  23
3426:  ADDWF  x37,W
3428:  MOVWF  FE9
342A:  MOVLW  00
342C:  ADDWFC x38,W
342E:  MOVWF  FEA
3430:  BTFSC  FEF.3
3432:  BRA    346A
....................                   { 
....................                      ps->Flags.bIsGetReady   = TRUE; 
3434:  MOVLW  23
3436:  ADDWF  x37,W
3438:  MOVWF  FE9
343A:  MOVLW  00
343C:  ADDWFC x38,W
343E:  MOVWF  FEA
3440:  BSF    FEF.3
....................                      ps->RxCount             = len; 
3442:  MOVLW  12
3444:  ADDWF  x37,W
3446:  MOVWF  FE9
3448:  MOVLW  00
344A:  ADDWFC x38,W
344C:  MOVWF  FEA
344E:  MOVFF  326,FEC
3452:  MOVF   FED,F
3454:  MOVFF  325,FEF
....................                      ps->Flags.bFirstRead    = TRUE; 
3458:  MOVLW  23
345A:  ADDWF  x37,W
345C:  MOVWF  FE9
345E:  MOVLW  00
3460:  ADDWFC x38,W
3462:  MOVWF  FEA
3464:  BSF    FEF.2
....................  
....................                      // 4/1/02 
....................                      flags |= ACK; 
3466:  BSF    x39.4
....................                   } 
....................                   // There is data, but we cannot handle it at this time. 
....................                   else 
3468:  BRA    34AA
....................                   { 
....................                      //DebugPrint("D"); 
....................                      // Since we cannot accept this packet, 
....................                      // restore to previous seq and ack. 
....................                      // and do not send anything back. 
....................                      // Host has to resend this packet when 
....................                      // we are ready. 
....................                      ps->SND_SEQ = prevSeq; 
346A:  MOVLW  16
346C:  ADDWF  x37,W
346E:  MOVWF  FE9
3470:  MOVLW  00
3472:  ADDWFC x38,W
3474:  MOVWF  FEA
3476:  MOVFF  333,FEF
347A:  MOVFF  334,FEC
347E:  MOVFF  335,FEC
3482:  MOVFF  336,FEC
....................                      ps->SND_ACK = prevAck; 
3486:  MOVLW  1A
3488:  ADDWF  x37,W
348A:  MOVWF  FE9
348C:  MOVLW  00
348E:  ADDWFC x38,W
3490:  MOVWF  FEA
3492:  MOVFF  32F,FEF
3496:  MOVFF  330,FEC
349A:  MOVFF  331,FEC
349E:  MOVFF  332,FEC
....................  
....................                      MACDiscardRx(); 
34A2:  MOVLB  0
34A4:  CALL   1256
34A8:  MOVLB  3
....................                   } 
....................                } 
....................                // There is no data in this packet, and thus it 
....................                // can be thrown away. 
....................                else 
34AA:  BRA    34B4
....................                { 
....................                   MACDiscardRx(); 
34AC:  MOVLB  0
34AE:  CALL   1256
34B2:  MOVLB  3
....................                } 
....................             } 
....................             // Connection is not established; check if we've sent 
....................             // a FIN and expect our last ACK 
....................             else if(ps->smState == TCP_LAST_ACK) 
34B4:  BRA    36A4
34B6:  MOVFF  337,FE9
34BA:  MOVFF  338,FEA
34BE:  MOVF   FEF,W
34C0:  SUBLW  09
34C2:  BNZ   34EE
....................             { 
....................                MACDiscardRx(); 
34C4:  MOVLB  0
34C6:  CALL   1256
....................  
....................                if(h->Flags.bits.flagACK) 
34CA:  MOVLW  0D
34CC:  MOVLB  3
34CE:  ADDWF  x23,W
34D0:  MOVWF  FE9
34D2:  MOVLW  00
34D4:  ADDWFC x24,W
34D6:  MOVWF  FEA
34D8:  BTFSS  FEF.4
34DA:  BRA    34EC
....................                { 
....................                   CloseSocket(ps); 
34DC:  MOVFF  338,33F
34E0:  MOVFF  337,33E
34E4:  MOVLB  0
34E6:  CALL   261A
34EA:  MOVLB  3
....................                } 
....................             } 
....................             else if(ps->smState == TCP_FIN_WAIT_1) 
34EC:  BRA    36A4
34EE:  MOVFF  337,FE9
34F2:  MOVFF  338,FEA
34F6:  MOVF   FEF,W
34F8:  SUBLW  04
34FA:  BNZ   35D0
....................             { 
....................                MACDiscardRx(); 
34FC:  MOVLB  0
34FE:  CALL   1256
....................  
....................                if(h->Flags.bits.flagFIN) 
3502:  MOVLW  0D
3504:  MOVLB  3
3506:  ADDWF  x23,W
3508:  MOVWF  FE9
350A:  MOVLW  00
350C:  ADDWFC x24,W
350E:  MOVWF  FEA
3510:  BTFSS  FEF.0
3512:  BRA    35AE
....................                { 
....................                   flags = ACK; 
3514:  MOVLW  10
3516:  MOVWF  x39
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
3518:  MOVLW  1A
351A:  ADDWF  x37,W
351C:  MOVWF  FE9
351E:  MOVLW  00
3520:  ADDWFC x38,W
3522:  MOVWF  FEA
3524:  MOVLW  01
3526:  ADDWF  FEF,W
3528:  MOVWF  00
352A:  MOVLW  00
352C:  ADDWFC FEC,W
352E:  MOVWF  01
3530:  MOVLW  00
3532:  ADDWFC FEC,W
3534:  MOVWF  02
3536:  MOVLW  00
3538:  ADDWFC FEC,W
353A:  MOVF   FED,F
353C:  MOVF   FED,F
353E:  MOVF   FED,F
3540:  MOVFF  00,FEF
3544:  MOVFF  01,FEC
3548:  MOVFF  02,FEC
354C:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
354E:  MOVLW  1A
3550:  ADDWF  x37,W
3552:  MOVWF  FE9
3554:  MOVLW  00
3556:  ADDWFC x38,W
3558:  MOVWF  FEA
355A:  MOVFF  FEF,00
355E:  MOVFF  FEC,01
3562:  MOVFF  FEC,02
3566:  MOVFF  FEC,03
356A:  MOVFF  03,32A
356E:  MOVFF  02,329
3572:  MOVFF  01,328
3576:  MOVFF  00,327
....................                   if(h->Flags.bits.flagACK) 
357A:  MOVLW  0D
357C:  ADDWF  x23,W
357E:  MOVWF  FE9
3580:  MOVLW  00
3582:  ADDWFC x24,W
3584:  MOVWF  FEA
3586:  BTFSS  FEF.4
3588:  BRA    359C
....................                   { 
....................                      CloseSocket(ps); 
358A:  MOVFF  338,33F
358E:  MOVFF  337,33E
3592:  MOVLB  0
3594:  CALL   261A
....................                   } 
....................                   else 
3598:  BRA    35AA
359A:  MOVLB  3
....................                   { 
....................                      ps->smState = TCP_CLOSING; 
359C:  MOVFF  337,FE9
35A0:  MOVFF  338,FEA
35A4:  MOVLW  06
35A6:  MOVWF  FEF
35A8:  MOVLB  0
....................                   } 
....................                } 
....................                else if(h->Flags.bits.flagACK) 
35AA:  BRA    35CC
35AC:  MOVLB  3
35AE:  MOVLW  0D
35B0:  ADDWF  x23,W
35B2:  MOVWF  FE9
35B4:  MOVLW  00
35B6:  ADDWFC x24,W
35B8:  MOVWF  FEA
35BA:  BTFSS  FEF.4
35BC:  BRA    35CA
....................                { 
....................                   ps->smState = TCP_FIN_WAIT_2; 
35BE:  MOVFF  337,FE9
35C2:  MOVFF  338,FEA
35C6:  MOVLW  05
35C8:  MOVWF  FEF
35CA:  MOVLB  0
....................                } 
....................             } 
....................             else if(ps->smState == TCP_FIN_WAIT_2) 
35CC:  BRA    36A2
35CE:  MOVLB  3
35D0:  MOVFF  337,FE9
35D4:  MOVFF  338,FEA
35D8:  MOVF   FEF,W
35DA:  SUBLW  05
35DC:  BNZ   366E
....................             { 
....................                MACDiscardRx(); 
35DE:  MOVLB  0
35E0:  CALL   1256
....................  
....................                if(h->Flags.bits.flagFIN) 
35E4:  MOVLW  0D
35E6:  MOVLB  3
35E8:  ADDWF  x23,W
35EA:  MOVWF  FE9
35EC:  MOVLW  00
35EE:  ADDWFC x24,W
35F0:  MOVWF  FEA
35F2:  BTFSS  FEF.0
35F4:  BRA    366C
....................                { 
....................                   flags = ACK; 
35F6:  MOVLW  10
35F8:  MOVWF  x39
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
35FA:  MOVLW  1A
35FC:  ADDWF  x37,W
35FE:  MOVWF  FE9
3600:  MOVLW  00
3602:  ADDWFC x38,W
3604:  MOVWF  FEA
3606:  MOVLW  01
3608:  ADDWF  FEF,W
360A:  MOVWF  00
360C:  MOVLW  00
360E:  ADDWFC FEC,W
3610:  MOVWF  01
3612:  MOVLW  00
3614:  ADDWFC FEC,W
3616:  MOVWF  02
3618:  MOVLW  00
361A:  ADDWFC FEC,W
361C:  MOVF   FED,F
361E:  MOVF   FED,F
3620:  MOVF   FED,F
3622:  MOVFF  00,FEF
3626:  MOVFF  01,FEC
362A:  MOVFF  02,FEC
362E:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
3630:  MOVLW  1A
3632:  ADDWF  x37,W
3634:  MOVWF  FE9
3636:  MOVLW  00
3638:  ADDWFC x38,W
363A:  MOVWF  FEA
363C:  MOVFF  FEF,00
3640:  MOVFF  FEC,01
3644:  MOVFF  FEC,02
3648:  MOVFF  FEC,03
364C:  MOVFF  03,32A
3650:  MOVFF  02,329
3654:  MOVFF  01,328
3658:  MOVFF  00,327
....................                   CloseSocket(ps); 
365C:  MOVFF  338,33F
3660:  MOVFF  337,33E
3664:  MOVLB  0
3666:  CALL   261A
366A:  MOVLB  3
....................                } 
....................             } 
....................             else if ( ps->smState == TCP_CLOSING ) 
366C:  BRA    36A4
366E:  MOVFF  337,FE9
3672:  MOVFF  338,FEA
3676:  MOVF   FEF,W
3678:  SUBLW  06
367A:  BNZ   36A4
....................             { 
....................                MACDiscardRx(); 
367C:  MOVLB  0
367E:  CALL   1256
....................  
....................                if ( h->Flags.bits.flagACK ) 
3682:  MOVLW  0D
3684:  MOVLB  3
3686:  ADDWF  x23,W
3688:  MOVWF  FE9
368A:  MOVLW  00
368C:  ADDWFC x24,W
368E:  MOVWF  FEA
3690:  BTFSS  FEF.4
3692:  BRA    36A4
....................                { 
....................                   CloseSocket(ps); 
3694:  MOVFF  338,33F
3698:  MOVFF  337,33E
369C:  MOVLB  0
369E:  CALL   261A
36A2:  MOVLB  3
....................                } 
....................             } 
....................          } 
....................       } 
....................       // This packet's sequence number does not match what we were 
....................       // expecting (the last value we ACKed).  Throw this packet 
....................       // away.  This may happen if packets are delivered out of order. 
....................       // Not enough memory is available on our PIC or Ethernet 
....................       // controller to implement a robust stream reconstruction 
....................       // buffer.  As a result, the remote node will just have to 
....................       // retransmit its packets starting with the proper sequence number. 
....................       else 
36A4:  BRA    36C2
....................       { 
....................          MACDiscardRx(); 
36A6:  MOVLB  0
36A8:  CALL   1256
....................  
....................          // Send a new ACK out in case if the previous one was lost 
....................          // (ACKs aren't ACKed).  This is required to prevent an 
....................          // unlikely but possible situation which would cause the 
....................          // connection to time out if the ACK was lost and the 
....................          // remote node keeps sending us older data than we are 
....................          // expecting. 
....................          flags = ACK; 
36AC:  MOVLW  10
36AE:  MOVLB  3
36B0:  MOVWF  x39
....................          ack = prevAck; 
36B2:  MOVFF  332,32A
36B6:  MOVFF  331,329
36BA:  MOVFF  330,328
36BE:  MOVFF  32F,327
....................       } 
....................    } 
....................  
.................... SendTCPControlPacket: 
....................    if(flags) 
36C2:  MOVF   x39,F
36C4:  BZ    373A
....................    { 
....................       SendTCP(remote, 
....................          h->DestPort, 
....................          h->SourcePort, 
....................          seq, 
....................          ack, 
....................          flags); 
36C6:  MOVLW  02
36C8:  ADDWF  x23,W
36CA:  MOVWF  FE9
36CC:  MOVLW  00
36CE:  ADDWFC x24,W
36D0:  MOVWF  FEA
36D2:  MOVFF  FEC,33F
36D6:  MOVF   FED,F
36D8:  MOVFF  FEF,33E
36DC:  MOVFF  323,FE9
36E0:  MOVFF  324,FEA
36E4:  MOVFF  FEC,341
36E8:  MOVF   FED,F
36EA:  MOVFF  FEF,340
36EE:  MOVFF  322,346
36F2:  MOVFF  321,345
36F6:  MOVFF  33F,348
36FA:  MOVFF  33E,347
36FE:  MOVFF  341,34A
3702:  MOVFF  340,349
3706:  MOVFF  32E,34E
370A:  MOVFF  32D,34D
370E:  MOVFF  32C,34C
3712:  MOVFF  32B,34B
3716:  MOVFF  32A,352
371A:  MOVFF  329,351
371E:  MOVFF  328,350
3722:  MOVFF  327,34F
3726:  MOVFF  339,353
372A:  MOVLW  FF
372C:  MOVWF  x54
372E:  CLRF   x56
3730:  CLRF   x55
3732:  MOVLB  0
3734:  CALL   2A40
3738:  MOVLB  3
....................    } 
....................  
....................    /*if (debugLastState != ps->smState) 
....................    { 
....................       debug_tcp("\r\nHANDLE TCP SEG %U - ", s); 
....................       DebugTCPDisplayState(debugLastState); 
....................       debug_tcp(" -> "); 
....................       DebugTCPDisplayState(ps->smState); 
....................    }*/ 
.................... } 
373A:  MOVLB  0
373C:  GOTO   38EC (RETURN)
....................  
.................... #endif 
....................  
.................... #if STACK_USE_ICMP 
....................    #include "tcpip/icmp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.C 
....................  * Dependencies:    ICMP.h 
....................  *                  string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/30/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/29/04 SwapICMPPacket() no longer static 
....................  * Howard Schlunder      9/9/04   Added ENC28J60 DMA checksum support 
....................  * Howard Schlunder      1/5/06   Increased DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/icmp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    07/13/06 Increased MAX_ICMP_DATA to 64 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ICMP_H 
.................... #define ICMP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... // Windows ping uses 32 bytes, while MAC uses 56 bytes. 
.................... //#define MAX_ICMP_DATA       (32) 
.................... #define MAX_ICMP_DATA       (64) 
....................  
.................... #define MAX_ICMP_DATA_LEN   (MAX_ICMP_DATA) 
....................  
....................  
.................... typedef enum _ICMP_CODE 
.................... { 
....................     ICMP_ECHO_REPLY = 0, 
....................     ICMP_ECHO_REQUEST = 8 
.................... } ICMP_CODE, ICMP_REQUESTS; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPIsTxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is ready 
....................  *                  FALSE if transmit buffer is not ready 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define ICMPIsTxReady()     MACIsTxReady(TRUE) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #define debug_icmp 
.................... //#define debug_icmp   debug_printf 
....................  
.................... //#define MAX_ICMP_DATA       32 //moved to icmp.h 
....................  
.................... /* 
....................  * ICMP packet definition 
....................  */ 
.................... typedef struct _ICMP_PACKET 
.................... { 
....................     BYTE    Type; 
....................     BYTE    Code; 
....................     WORD    Checksum; 
....................     WORD    Identifier; 
....................     WORD    SequenceNumber; 
....................     BYTE    Data[MAX_ICMP_DATA]; 
.................... } ICMP_PACKET; 
.................... #define ICMP_HEADER_SIZE    (sizeof(ICMP_PACKET) - MAX_ICMP_DATA) 
....................  
.................... static void SwapICMPPacket(ICMP_PACKET* p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq) 
.................... { 
....................     ICMP_PACKET packet; 
....................     WORD CalcChecksum; 
....................     WORD ReceivedChecksum; 
.................... #if !defined(MCHP_MAC) 
....................     WORD checksums[2]; 
.................... #endif 
....................  
.................... //    debug_icmp("\r\nICMP GET "); 
....................  
....................     // Obtain the ICMP Header 
....................     MACGetArray((BYTE*)&packet, ICMP_HEADER_SIZE); 
*
39DE:  MOVLW  03
39E0:  MOVLB  3
39E2:  MOVWF  x4D
39E4:  CLRF   x4C
39E6:  MOVWF  x8C
39E8:  MOVFF  34C,38B
39EC:  CLRF   x8E
39EE:  MOVLW  08
39F0:  MOVWF  x8D
39F2:  MOVLB  0
39F4:  CALL   12C2
....................  
....................  
.................... #if defined(MCHP_MAC) 
....................    // Calculate the checksum using the Microchip MAC's DMA module 
....................    // The checksum data includes the precomputed checksum in the 
....................    // header, so a valid packet will always have a checksum of 
....................    // 0x0000 if the packet is not disturbed. 
....................    ReceivedChecksum = 0x0000; 
39F8:  MOVLB  3
39FA:  CLRF   x4B
39FC:  CLRF   x4A
....................    CalcChecksum = MACCalcRxChecksum(0+sizeof(IP_HEADER), *len); 
39FE:  MOVFF  2FB,03
3A02:  MOVFF  2FA,FE9
3A06:  MOVFF  2FB,FEA
3A0A:  MOVFF  FEF,34C
3A0E:  MOVLB  3
3A10:  CLRF   x4E
3A12:  MOVLW  14
3A14:  MOVWF  x4D
3A16:  CLRF   x50
3A18:  MOVFF  34C,34F
3A1C:  MOVLB  0
3A1E:  CALL   1C22
3A22:  MOVFF  02,349
3A26:  MOVFF  01,348
.................... #endif 
....................  
....................    // Obtain the ICMP data payload 
....................     *len -= ICMP_HEADER_SIZE; 
3A2A:  MOVLB  2
3A2C:  MOVFF  2FA,FE9
3A30:  MOVFF  2FB,FEA
3A34:  MOVLW  08
3A36:  SUBWF  FEF,W
3A38:  MOVWF  FEF
....................     MACGetArray(data, *len); 
3A3A:  MOVFF  2FB,03
3A3E:  MOVFF  2FA,FE9
3A42:  MOVFF  2FB,FEA
3A46:  MOVFF  FEF,34C
3A4A:  MOVFF  2F9,38C
3A4E:  MOVFF  2F8,38B
3A52:  MOVLB  3
3A54:  CLRF   x8E
3A56:  MOVFF  34C,38D
3A5A:  MOVLB  0
3A5C:  CALL   12C2
....................  
....................  
.................... #if !defined(MCHP_MAC) 
....................    // Calculte the checksum in local memory without hardware help 
....................     ReceivedChecksum = packet.Checksum; 
....................     packet.Checksum = 0; 
....................  
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&packet, ICMP_HEADER_SIZE); 
....................     checksums[1] = ~CalcIPChecksum(data, *len); 
....................  
....................     CalcChecksum = CalcIPChecksum((BYTE*)checksums, 2 * sizeof(WORD)); 
.................... #endif 
....................  
....................     SwapICMPPacket(&packet); 
3A60:  MOVLW  03
3A62:  MOVLB  3
3A64:  MOVWF  x4D
3A66:  CLRF   x4C
3A68:  MOVLB  0
3A6A:  RCALL  38FE
....................  
....................     *code = packet.Type; 
3A6C:  MOVLB  2
3A6E:  MOVFF  2F6,FE9
3A72:  MOVFF  2F7,FEA
3A76:  MOVFF  300,FEF
....................     *id = packet.Identifier; 
3A7A:  MOVFF  2FC,FE9
3A7E:  MOVFF  2FD,FEA
3A82:  MOVFF  305,FEC
3A86:  MOVF   FED,F
3A88:  MOVFF  304,FEF
....................     *seq = packet.SequenceNumber; 
3A8C:  MOVFF  2FE,FE9
3A90:  MOVFF  2FF,FEA
3A94:  MOVFF  307,FEC
3A98:  MOVF   FED,F
3A9A:  MOVFF  306,FEF
....................  
.................... //    debug_icmp("%U", CalcChecksum == ReceivedChecksum); 
....................  
....................     return ( CalcChecksum == ReceivedChecksum ); 
3A9E:  MOVLB  3
3AA0:  MOVF   x4A,W
3AA2:  SUBWF  x48,W
3AA4:  BNZ   3AAC
3AA6:  MOVF   x4B,W
3AA8:  SUBWF  x49,W
3AAA:  BZ    3AB0
3AAC:  MOVLW  00
3AAE:  BRA    3AB2
3AB0:  MOVLW  01
3AB2:  MOVWF  01
.................... } 
3AB4:  MOVLB  0
3AB6:  GOTO   710C (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq) 
.................... { 
....................     ICMP_PACKET   packet; 
....................     WORD ICMPLen; 
....................    BUFFER MyTxBuffer; 
....................    MyTxBuffer = MACGetTxBuffer(TRUE); 
3ABA:  MOVLW  01
3ABC:  MOVLB  3
3ABE:  MOVWF  x7D
3AC0:  MOVLB  0
3AC2:  CALL   162C
3AC6:  MOVFF  01,348
....................  
....................    // Abort if there is no where in the Ethernet controller to 
....................    // store this packet. 
....................    if(MyTxBuffer == INVALID_BUFFER) 
3ACA:  MOVLB  3
3ACC:  INCFSZ x48,W
3ACE:  BRA    3AD2
....................       return; 
3AD0:  BRA    3BD2
....................  
....................    IPSetTxBuffer(MyTxBuffer, 0); 
3AD2:  MOVFF  348,396
3AD6:  CLRF   x98
3AD8:  MOVLW  14
3ADA:  MOVWF  x97
3ADC:  MOVLB  0
3ADE:  CALL   1648
....................  
....................  
....................    ICMPLen = ICMP_HEADER_SIZE + (WORD)len; 
3AE2:  CLRF   03
3AE4:  MOVLB  2
3AE6:  MOVF   xF9,W
3AE8:  ADDLW  08
3AEA:  MOVLB  3
3AEC:  MOVWF  x46
3AEE:  MOVLW  00
3AF0:  ADDWFC 03,W
3AF2:  MOVWF  x47
....................  
....................     packet.Code             = 0; 
3AF4:  MOVLB  2
3AF6:  CLRF   xFF
....................     packet.Type             = code; 
3AF8:  MOVFF  2F6,2FE
....................     packet.Checksum         = 0; 
3AFC:  MOVLB  3
3AFE:  CLRF   x01
3B00:  CLRF   x00
....................     packet.Identifier       = id; 
3B02:  MOVFF  2FB,303
3B06:  MOVFF  2FA,302
....................     packet.SequenceNumber   = seq; 
3B0A:  MOVFF  2FD,305
3B0E:  MOVFF  2FC,304
....................  
....................     memcpy((void*)packet.Data, (void*)data, len); 
3B12:  MOVLW  03
3B14:  MOVWF  FEA
3B16:  MOVLW  06
3B18:  MOVWF  FE9
3B1A:  MOVFF  2F8,FE2
3B1E:  MOVFF  2F7,FE1
3B22:  MOVLB  2
3B24:  MOVF   xF9,W
3B26:  MOVWF  01
3B28:  BZ    3B32
3B2A:  MOVFF  FE6,FEE
3B2E:  DECFSZ 01,F
3B30:  BRA    3B2A
....................  
....................     SwapICMPPacket(&packet); 
3B32:  MOVLW  02
3B34:  MOVLB  3
3B36:  MOVWF  x4D
3B38:  MOVLW  FE
3B3A:  MOVWF  x4C
3B3C:  MOVLB  0
3B3E:  RCALL  38FE
....................  
.................... #if !defined(MCHP_MAC) 
....................     packet.Checksum         = CalcIPChecksum((BYTE*)&packet, 
....................                                     ICMPLen); 
.................... #endif 
....................  
....................     IPPutHeader(remote, 
....................                 IP_PROT_ICMP, 
....................                 (WORD)(ICMP_HEADER_SIZE + len)); 
3B40:  MOVLW  08
3B42:  MOVLB  2
3B44:  ADDWF  xF9,W
3B46:  MOVLB  3
3B48:  CLRF   x4A
3B4A:  MOVWF  x49
3B4C:  MOVFF  2F5,37E
3B50:  MOVFF  2F4,37D
3B54:  MOVLW  01
3B56:  MOVWF  x7F
3B58:  MOVFF  34A,381
3B5C:  MOVFF  349,380
3B60:  MOVLB  0
3B62:  CALL   2914
....................  
....................     IPPutArray((BYTE*)&packet, ICMPLen); 
3B66:  MOVLW  02
3B68:  MOVLB  3
3B6A:  MOVWF  x4A
3B6C:  MOVLW  FE
3B6E:  MOVFF  34A,3A2
3B72:  MOVWF  xA1
3B74:  MOVFF  347,3A4
3B78:  MOVFF  346,3A3
3B7C:  MOVLB  0
3B7E:  CALL   16F0
....................  
.................... #if defined(MCHP_MAC) 
....................     // Calculate and write the ICMP checksum using the Microchip MAC's DMA 
....................    packet.Checksum = MACCalcTxChecksum(sizeof(IP_HEADER), ICMPLen); 
3B82:  MOVLB  3
3B84:  CLRF   x97
3B86:  MOVLW  14
3B88:  MOVWF  x96
3B8A:  MOVFF  347,399
3B8E:  MOVFF  346,398
3B92:  MOVLB  0
3B94:  CALL   284C
3B98:  MOVFF  02,301
3B9C:  MOVFF  01,300
....................    IPSetTxBuffer(MyTxBuffer, 2); 
3BA0:  MOVFF  348,396
3BA4:  MOVLB  3
3BA6:  CLRF   x98
3BA8:  MOVLW  16
3BAA:  MOVWF  x97
3BAC:  MOVLB  0
3BAE:  CALL   1648
....................    MACPutArray((BYTE*)&packet.Checksum, 2); 
3BB2:  MOVLW  03
3BB4:  MOVLB  3
3BB6:  MOVWF  x4A
3BB8:  CLRF   x49
3BBA:  MOVWF  xA2
3BBC:  MOVFF  349,3A1
3BC0:  CLRF   xA4
3BC2:  MOVLW  02
3BC4:  MOVWF  xA3
3BC6:  MOVLB  0
3BC8:  CALL   16F0
.................... #endif 
....................  
....................  
....................     MACFlush(); 
3BCC:  CALL   17FC
3BD0:  MOVLB  3
.................... } 
3BD2:  MOVLB  0
3BD4:  GOTO   7166 (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        void SwapICMPPacket(ICMP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p - ICMP packet header 
....................  * 
....................  * Output:          ICMP packet is swapped 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void SwapICMPPacket(ICMP_PACKET* p) 
.................... { 
....................     p->Identifier           = swaps(p->Identifier); 
*
38FE:  MOVLW  04
3900:  MOVLB  3
3902:  ADDWF  x4C,W
3904:  MOVWF  01
3906:  MOVLW  00
3908:  ADDWFC x4D,W
390A:  MOVWF  03
390C:  MOVFF  01,34E
3910:  MOVWF  x4F
3912:  MOVLW  04
3914:  ADDWF  x4C,W
3916:  MOVWF  FE9
3918:  MOVLW  00
391A:  ADDWFC x4D,W
391C:  MOVWF  FEA
391E:  MOVFF  FEC,351
3922:  MOVF   FED,F
3924:  MOVFF  FEF,350
3928:  MOVFF  351,39D
392C:  MOVFF  350,39C
3930:  MOVLB  0
3932:  CALL   1326
3936:  MOVFF  34F,FEA
393A:  MOVFF  34E,FE9
393E:  MOVFF  02,FEC
3942:  MOVF   FED,F
3944:  MOVFF  01,FEF
....................     p->SequenceNumber       = swaps(p->SequenceNumber); 
3948:  MOVLW  06
394A:  MOVLB  3
394C:  ADDWF  x4C,W
394E:  MOVWF  01
3950:  MOVLW  00
3952:  ADDWFC x4D,W
3954:  MOVWF  03
3956:  MOVFF  01,34E
395A:  MOVWF  x4F
395C:  MOVLW  06
395E:  ADDWF  x4C,W
3960:  MOVWF  FE9
3962:  MOVLW  00
3964:  ADDWFC x4D,W
3966:  MOVWF  FEA
3968:  MOVFF  FEC,351
396C:  MOVF   FED,F
396E:  MOVFF  FEF,350
3972:  MOVFF  351,39D
3976:  MOVFF  350,39C
397A:  MOVLB  0
397C:  CALL   1326
3980:  MOVFF  34F,FEA
3984:  MOVFF  34E,FE9
3988:  MOVFF  02,FEC
398C:  MOVF   FED,F
398E:  MOVFF  01,FEF
....................     p->Checksum             = swaps(p->Checksum); 
3992:  MOVLW  02
3994:  MOVLB  3
3996:  ADDWF  x4C,W
3998:  MOVWF  01
399A:  MOVLW  00
399C:  ADDWFC x4D,W
399E:  MOVWF  03
39A0:  MOVFF  01,34E
39A4:  MOVWF  x4F
39A6:  MOVLW  02
39A8:  ADDWF  x4C,W
39AA:  MOVWF  FE9
39AC:  MOVLW  00
39AE:  ADDWFC x4D,W
39B0:  MOVWF  FEA
39B2:  MOVFF  FEC,351
39B6:  MOVF   FED,F
39B8:  MOVFF  FEF,350
39BC:  MOVFF  351,39D
39C0:  MOVFF  350,39C
39C4:  MOVLB  0
39C6:  CALL   1326
39CA:  MOVFF  34F,FEA
39CE:  MOVFF  34E,FE9
39D2:  MOVFF  02,FEC
39D6:  MOVF   FED,F
39D8:  MOVFF  01,FEF
.................... } 
39DC:  RETLW  00
....................  
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................    #include "tcpip/udp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    #include "tcpip/dhcp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    #include "tcpip/telnet2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
....................    #include "tcpip/arptsk.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.c 
....................  * Dependencies:    compiler.h 
....................  *                  string.h 
....................  *                  ARP.h 
....................  *                  ARPTsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A macdiscardrx() added to arpprocess() to handle times when an eth packet with arp has padding bytes at the end 
....................  * Darren Rook (CCS)    06/28/04 ArpInit clears cache like in 2.20 
....................  * Darren Rook (CCS)    06/29/04 smArp, Cache no longer static 
....................  * Darren Rook (CCS)    07/12/06 MACDiscardRx spelled wrong (case) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  *                               I am assuming STACK_CLIENT_MODE is TRUE for ARP. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/arptsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ARP_TSK_H 
.................... #define ARP_TSK_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define debug_arptask 
.................... //#define debug_arptask   debug_printf 
....................  
.................... /* 
....................  * ARP Task FSM States 
....................  */ 
.................... typedef enum _ARP_STATE 
.................... { 
....................     SM_ARP_IDLE, 
....................     SM_ARP_REPLY 
.................... } ARP_STATE; 
....................  
....................  
.................... /* 
....................  * This ARP task caches one ARP response. 
....................  */ 
.................... static ARP_STATE smARP; 
....................  
.................... static NODE_INFO Cache; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void) 
.................... { 
....................     smARP = SM_ARP_IDLE; 
*
0D6E:  BCF    57.1
....................  
....................     Cache.MACAddr.v[0] = 0xff; 
0D70:  MOVLW  FF
0D72:  MOVLB  1
0D74:  MOVWF  x14
....................     Cache.MACAddr.v[1] = 0xff; 
0D76:  MOVWF  x15
....................     Cache.MACAddr.v[2] = 0xff; 
0D78:  MOVWF  x16
....................     Cache.MACAddr.v[3] = 0xff; 
0D7A:  MOVWF  x17
....................     Cache.MACAddr.v[4] = 0xff; 
0D7C:  MOVWF  x18
....................     Cache.MACAddr.v[5] = 0xff; 
0D7E:  MOVWF  x19
....................  
....................     Cache.IPAddr.Val = 0x0; 
0D80:  CLRF   x1D
0D82:  CLRF   x1C
0D84:  CLRF   x1B
0D86:  CLRF   x1A
.................... } 
0D88:  MOVLB  0
0D8A:  GOTO   1176 (RETURN)
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void) 
.................... { 
....................     NODE_INFO remoteNode; 
....................     BYTE opCode; 
....................  
....................     switch(smARP) 
....................     { 
*
1B88:  MOVLW  00
1B8A:  BTFSC  57.1
1B8C:  MOVLW  01
1B8E:  XORLW  00
1B90:  BZ    1B94
1B92:  BRA    1BF6
....................     case SM_ARP_IDLE: 
....................         if ( !ARPGet(&remoteNode, &opCode) ) 
1B94:  MOVLW  02
1B96:  MOVLB  3
1B98:  MOVWF  x00
1B9A:  MOVLW  F4
1B9C:  MOVLB  2
1B9E:  MOVWF  xFF
1BA0:  MOVLW  02
1BA2:  MOVLB  3
1BA4:  MOVWF  x02
1BA6:  MOVLW  FE
1BA8:  MOVWF  x01
1BAA:  MOVLB  0
1BAC:  BRA    1548
1BAE:  MOVF   01,F
1BB0:  BNZ   1BB4
....................             break; 
1BB2:  BRA    1C1A
....................  
....................          //dsr add 071204 
....................          //dsr fix 071206 
....................          MACDiscardRx(); 
1BB4:  CALL   1256
....................  
....................         if ( opCode == ARP_REPLY ) 
1BB8:  MOVLB  2
1BBA:  MOVF   xFE,F
1BBC:  BNZ   1BF2
....................         { 
.................... 			Cache.MACAddr = remoteNode.MACAddr; 
1BBE:  MOVLW  01
1BC0:  MOVWF  FEA
1BC2:  MOVLW  14
1BC4:  MOVWF  FE9
1BC6:  MOVLW  02
1BC8:  MOVWF  FE2
1BCA:  MOVLW  F4
1BCC:  MOVWF  FE1
1BCE:  MOVLW  06
1BD0:  MOVWF  01
1BD2:  MOVFF  FE6,FEE
1BD6:  DECFSZ 01,F
1BD8:  BRA    1BD2
....................             Cache.IPAddr.Val = remoteNode.IPAddr.Val; 
1BDA:  MOVFF  2FD,11D
1BDE:  MOVFF  2FC,11C
1BE2:  MOVFF  2FB,11B
1BE6:  MOVFF  2FA,11A
....................             break; 
1BEA:  MOVLB  0
1BEC:  BRA    1C1A
....................         } 
....................         else 
1BEE:  BRA    1BF6
1BF0:  MOVLB  2
....................             smARP = SM_ARP_REPLY; 
1BF2:  BSF    57.1
1BF4:  MOVLB  0
....................  
....................     default: 
.................... 		if(ARPPut(&remoteNode, ARP_REPLY)) 
1BF6:  MOVLW  02
1BF8:  MOVLB  3
1BFA:  MOVWF  x00
1BFC:  MOVLW  F4
1BFE:  MOVLB  2
1C00:  MOVWF  xFF
1C02:  MOVLB  3
1C04:  CLRF   x01
1C06:  MOVLB  0
1C08:  BRA    19F0
1C0A:  MOVF   01,F
1C0C:  BZ    1C12
.................... 		{ 
.................... 			smARP = SM_ARP_IDLE; 
1C0E:  BCF    57.1
.................... 		} 
....................         else 
1C10:  BRA    1C18
....................             return FALSE; 
1C12:  MOVLW  00
1C14:  MOVWF  01
1C16:  BRA    1C1E
....................         break; 
1C18:  BRA    1C1A
....................  
....................     } 
....................     return TRUE; 
1C1A:  MOVLW  01
1C1C:  MOVWF  01
.................... } 
1C1E:  GOTO   7030 (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    MACIsTxReady(TRUE) returns TRUE 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr) 
.................... { 
....................     NODE_INFO remoteNode; 
....................  
....................     remoteNode.IPAddr = *IPAddr; 
....................  
....................     ARPPut(&remoteNode, ARP_REQUEST); 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr) 
.................... { 
....................     if(Cache.IPAddr.Val == IPAddr->Val || Cache.IPAddr.Val == AppConfig.MyGateway.Val) 
....................     { 
....................         *MACAddr = Cache.MACAddr; 
....................         return TRUE; 
....................     } 
....................     return FALSE; 
.................... } 
....................  
....................  
....................  
....................    #include "tcpip/arp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.c 
....................  * Dependencies:    string.h 
....................  *                  stacktsk.h 
....................  *                  helpers.h 
....................  *                  arp.h 
....................  *                  mac.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... #include "tcpip/mac.h" 
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #define debug_arp 
.................... //#define debug_arp debug_printf 
....................  
.................... // ARP Operation codes. 
.................... #define ARP_OPERATION_REQ       0x01u 
.................... #define ARP_OPERATION_RESP      0x02u 
....................  
.................... // ETHERNET packet type as defined by IEEE 802.3 
.................... #define HW_ETHERNET             (0x0001u) 
.................... #define ARP_IP                  (0x0800u) 
....................  
....................  
....................  
.................... // ARP packet 
.................... typedef struct _ARP_PACKET 
.................... { 
....................     WORD        HardwareType; 
....................     WORD        Protocol; 
....................     BYTE        MACAddrLen; 
....................     BYTE        ProtocolLen; 
....................     WORD        Operation; 
....................     MAC_ADDR    SenderMACAddr; 
....................     IP_ADDR     SenderIPAddr; 
....................     MAC_ADDR    TargetMACAddr; 
....................     IP_ADDR     TargetIPAddr; 
.................... } ARP_PACKET; 
....................  
.................... // Helper function 
.................... static void SwapARPPacket(ARP_PACKET *p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int1 ARPGet(NODE_INFO *remote, int8 *opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
....................     //MACGetArray((int8*)&packet, sizeof(packet)); 
....................     MACGetArray(&packet, sizeof(ARP_PACKET)); 
*
1548:  MOVLW  03
154A:  MOVLB  3
154C:  MOVWF  x8C
154E:  MOVWF  x8B
1550:  CLRF   x8E
1552:  MOVLW  1C
1554:  MOVWF  x8D
1556:  MOVLB  0
1558:  RCALL  12C2
....................  
....................     MACDiscardRx(); 
155A:  RCALL  1256
....................  
....................     SwapARPPacket(&packet); 
155C:  MOVLW  03
155E:  MOVLB  3
1560:  MOVWF  x21
1562:  MOVWF  x20
1564:  MOVLB  0
1566:  RCALL  1474
....................  
....................    //debug_arp("\r\nARP: HW:%LX PR:%LX ML:%U PL:%U O:%LX TI:%U.%U.%U.%U FI:%U.%U.%U.%U", 
....................      // packet.HardwareType, packet.Protocol, packet.MACAddrLen, packet.ProtocolLen, 
....................      // packet.Operation, packet.TargetIPAddr.v[0],packet.TargetIPAddr.v[1], 
....................      // packet.TargetIPAddr.v[2],packet.TargetIPAddr.v[3], 
....................      // packet.SenderIPAddr.v[0],packet.SenderIPAddr.v[1],packet.SenderIPAddr.v[2],packet.SenderIPAddr.v[3]); 
....................  
....................     if ( packet.HardwareType != HW_ETHERNET     || 
....................          packet.MACAddrLen != sizeof(MAC_ADDR)  || 
....................          packet.ProtocolLen != sizeof(IP_ADDR) ) 
1568:  MOVLB  3
156A:  DECFSZ x03,W
156C:  BRA    157E
156E:  MOVF   x04,F
1570:  BNZ   157E
1572:  MOVF   x07,W
1574:  SUBLW  06
1576:  BNZ   157E
1578:  MOVF   x08,W
157A:  SUBLW  04
157C:  BZ    1584
....................          return FALSE; 
157E:  MOVLW  00
1580:  MOVWF  01
1582:  BRA    1626
....................  
....................     if ( packet.Operation == ARP_OPERATION_RESP ) 
1584:  MOVF   x09,W
1586:  SUBLW  02
1588:  BNZ   159A
158A:  MOVF   x0A,F
158C:  BNZ   159A
....................         *opCode = ARP_REPLY; 
158E:  MOVFF  301,FE9
1592:  MOVFF  302,FEA
1596:  CLRF   FEF
....................     else if ( packet.Operation == ARP_OPERATION_REQ ) 
1598:  BRA    15C2
159A:  DECFSZ x09,W
159C:  BRA    15B0
159E:  MOVF   x0A,F
15A0:  BNZ   15B0
....................         *opCode = ARP_REQUEST; 
15A2:  MOVFF  301,FE9
15A6:  MOVFF  302,FEA
15AA:  MOVLW  01
15AC:  MOVWF  FEF
....................     else 
15AE:  BRA    15C2
....................     { 
....................         *opCode = ARP_UNKNOWN; 
15B0:  MOVFF  301,FE9
15B4:  MOVFF  302,FEA
15B8:  MOVLW  02
15BA:  MOVWF  FEF
....................         return FALSE; 
15BC:  MOVLW  00
15BE:  MOVWF  01
15C0:  BRA    1626
....................     } 
....................  
....................     if(packet.TargetIPAddr.Val == AppConfig.MyIPAddr.Val) 
15C2:  MOVF   17,W
15C4:  SUBWF  x1B,W
15C6:  BNZ   1620
15C8:  MOVF   18,W
15CA:  SUBWF  x1C,W
15CC:  BNZ   1620
15CE:  MOVF   19,W
15D0:  SUBWF  x1D,W
15D2:  BNZ   1620
15D4:  MOVF   1A,W
15D6:  SUBWF  x1E,W
15D8:  BNZ   1620
....................     { 
....................         remote->MACAddr     = packet.SenderMACAddr; 
15DA:  MOVFF  2FF,FE9
15DE:  MOVLB  3
15E0:  MOVFF  300,FEA
15E4:  MOVLW  03
15E6:  MOVWF  FE2
15E8:  MOVLW  0B
15EA:  MOVWF  FE1
15EC:  MOVLW  06
15EE:  MOVWF  01
15F0:  MOVFF  FE6,FEE
15F4:  DECFSZ 01,F
15F6:  BRA    15F0
....................         remote->IPAddr      = packet.SenderIPAddr; 
15F8:  MOVLW  06
15FA:  MOVLB  2
15FC:  ADDWF  xFF,W
15FE:  MOVWF  FE9
1600:  MOVLW  00
1602:  MOVLB  3
1604:  ADDWFC x00,W
1606:  MOVWF  FEA
1608:  MOVFF  311,FEF
160C:  MOVFF  312,FEC
1610:  MOVFF  313,FEC
1614:  MOVFF  314,FEC
....................         return TRUE; 
1618:  MOVLW  01
161A:  MOVWF  01
161C:  BRA    1626
....................     } 
....................     else 
161E:  BRA    1626
....................         return FALSE; 
1620:  MOVLW  00
1622:  MOVWF  01
1624:  BRA    1626
.................... } 
1626:  MOVLB  0
1628:  GOTO   1BAE (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          TRUE - The ARP packet was generated properly 
....................  *               FALSE - Unable to allocate a TX buffer 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
....................    BUFFER MyTxBuffer; 
....................    MyTxBuffer = MACGetTxBuffer(TRUE); 
*
19F0:  MOVLW  01
19F2:  MOVLB  3
19F4:  MOVWF  x7D
19F6:  MOVLB  0
19F8:  RCALL  162C
19FA:  MOVFF  01,31E
....................     
....................    // Do not respond if there is no room to generate the ARP reply 
....................    if(MyTxBuffer == INVALID_BUFFER) 
19FE:  MOVLB  3
1A00:  INCFSZ x1E,W
1A02:  BRA    1A0A
....................       return FALSE; 
1A04:  MOVLW  00
1A06:  MOVWF  01
1A08:  BRA    1B82
....................  
....................    MACSetTxBuffer(MyTxBuffer, 0); 
1A0A:  MOVFF  31E,396
1A0E:  CLRF   x98
1A10:  CLRF   x97
1A12:  MOVLB  0
1A14:  RCALL  1648
....................     
....................     
....................     packet.HardwareType             = HW_ETHERNET; 
1A16:  MOVLB  3
1A18:  CLRF   x03
1A1A:  MOVLW  01
1A1C:  MOVWF  x02
....................     packet.Protocol                 = ARP_IP; 
1A1E:  MOVLW  08
1A20:  MOVWF  x05
1A22:  CLRF   x04
....................     packet.MACAddrLen               = sizeof(MAC_ADDR); 
1A24:  MOVLW  06
1A26:  MOVWF  x06
....................     packet.ProtocolLen              = sizeof(IP_ADDR); 
1A28:  MOVLW  04
1A2A:  MOVWF  x07
....................  
....................     if ( opCode == ARP_REQUEST ) 
1A2C:  DECFSZ x01,W
1A2E:  BRA    1A46
....................     { 
....................         packet.Operation            = ARP_OPERATION_REQ; 
1A30:  CLRF   x09
1A32:  MOVLW  01
1A34:  MOVWF  x08
....................         packet.TargetMACAddr.v[0]   = 0xff; 
1A36:  MOVLW  FF
1A38:  MOVWF  x14
....................         packet.TargetMACAddr.v[1]   = 0xff; 
1A3A:  MOVWF  x15
....................         packet.TargetMACAddr.v[2]   = 0xff; 
1A3C:  MOVWF  x16
....................         packet.TargetMACAddr.v[3]   = 0xff; 
1A3E:  MOVWF  x17
....................         packet.TargetMACAddr.v[4]   = 0xff; 
1A40:  MOVWF  x18
....................         packet.TargetMACAddr.v[5]   = 0xff; 
1A42:  MOVWF  x19
....................     } 
....................     else 
1A44:  BRA    1A76
....................     { 
....................         packet.Operation            = ARP_OPERATION_RESP; 
1A46:  CLRF   x09
1A48:  MOVLW  02
1A4A:  MOVWF  x08
....................         packet.TargetMACAddr        = remote->MACAddr; 
1A4C:  MOVLB  3
1A4E:  MOVFF  300,03
1A52:  MOVFF  2FF,31F
1A56:  MOVFF  300,320
1A5A:  MOVLW  03
1A5C:  MOVWF  FEA
1A5E:  MOVLW  14
1A60:  MOVWF  FE9
1A62:  MOVFF  300,FE2
1A66:  MOVFF  2FF,FE1
1A6A:  MOVLW  06
1A6C:  MOVWF  01
1A6E:  MOVFF  FE6,FEE
1A72:  DECFSZ 01,F
1A74:  BRA    1A6E
....................     } 
....................  
....................     packet.SenderMACAddr = AppConfig.MyMACAddr; 
1A76:  MOVLW  03
1A78:  MOVWF  FEA
1A7A:  MOVLW  0A
1A7C:  MOVWF  FE9
1A7E:  CLRF   FE2
1A80:  MOVLW  1B
1A82:  MOVWF  FE1
1A84:  MOVLW  06
1A86:  MOVWF  01
1A88:  MOVFF  FE6,FEE
1A8C:  DECFSZ 01,F
1A8E:  BRA    1A88
....................     packet.SenderIPAddr  = AppConfig.MyIPAddr; 
1A90:  MOVFF  1A,313
1A94:  MOVFF  19,312
1A98:  MOVFF  18,311
1A9C:  MOVFF  17,310
....................  
....................  
....................     // Check to see if target is on same subnet, if not, find Gateway MAC. 
....................     // Once we get Gateway MAC, all access to remote host will go through Gateway. 
....................     if((packet.SenderIPAddr.Val ^ remote->IPAddr.Val) & AppConfig.MyMask.Val) 
1AA0:  MOVLW  06
1AA2:  MOVLB  2
1AA4:  ADDWF  xFF,W
1AA6:  MOVWF  FE9
1AA8:  MOVLW  00
1AAA:  MOVLB  3
1AAC:  ADDWFC x00,W
1AAE:  MOVWF  FEA
1AB0:  MOVFF  FEF,00
1AB4:  MOVFF  FEC,01
1AB8:  MOVFF  FEC,02
1ABC:  MOVFF  FEC,03
1AC0:  MOVF   00,W
1AC2:  XORWF  x10,W
1AC4:  MOVWF  x1F
1AC6:  MOVF   01,W
1AC8:  XORWF  x11,W
1ACA:  MOVWF  x20
1ACC:  MOVF   02,W
1ACE:  XORWF  x12,W
1AD0:  MOVWF  x21
1AD2:  MOVF   03,W
1AD4:  XORWF  x13,W
1AD6:  MOVWF  x22
1AD8:  MOVF   x1F,W
1ADA:  ANDWF  21,W
1ADC:  MOVWF  00
1ADE:  MOVF   x20,W
1AE0:  ANDWF  22,W
1AE2:  MOVWF  01
1AE4:  MOVF   x21,W
1AE6:  ANDWF  23,W
1AE8:  MOVWF  02
1AEA:  MOVF   x22,W
1AEC:  ANDWF  24,W
1AEE:  MOVWF  03
1AF0:  MOVF   00,F
1AF2:  BNZ   1B00
1AF4:  MOVF   01,F
1AF6:  BNZ   1B00
1AF8:  MOVF   02,F
1AFA:  BNZ   1B00
1AFC:  MOVF   03,F
1AFE:  BZ    1B12
....................     { 
....................       packet.TargetIPAddr = AppConfig.MyGateway; 
1B00:  MOVFF  28,31D
1B04:  MOVFF  27,31C
1B08:  MOVFF  26,31B
1B0C:  MOVFF  25,31A
....................     } 
....................     else 
1B10:  BRA    1B42
....................         packet.TargetIPAddr             = remote->IPAddr; 
1B12:  MOVLW  06
1B14:  MOVLB  2
1B16:  ADDWF  xFF,W
1B18:  MOVWF  FE9
1B1A:  MOVLW  00
1B1C:  MOVLB  3
1B1E:  ADDWFC x00,W
1B20:  MOVWF  FEA
1B22:  MOVFF  FEF,00
1B26:  MOVFF  FEC,01
1B2A:  MOVFF  FEC,02
1B2E:  MOVFF  FEC,03
1B32:  MOVFF  03,31D
1B36:  MOVFF  02,31C
1B3A:  MOVFF  01,31B
1B3E:  MOVFF  00,31A
....................  
....................     SwapARPPacket(&packet); 
1B42:  MOVLW  03
1B44:  MOVWF  x21
1B46:  MOVLW  02
1B48:  MOVWF  x20
1B4A:  MOVLB  0
1B4C:  RCALL  1474
....................  
....................     MACPutHeader(&packet.TargetMACAddr, MAC_ARP, sizeof(packet)); 
1B4E:  MOVLW  03
1B50:  MOVLB  3
1B52:  MOVWF  x9B
1B54:  MOVLW  14
1B56:  MOVWF  x9A
1B58:  MOVLW  06
1B5A:  MOVWF  x9C
1B5C:  CLRF   x9E
1B5E:  MOVLW  1C
1B60:  MOVWF  x9D
1B62:  MOVLB  0
1B64:  RCALL  173E
....................  
....................     //MACPutArray((int8*)&packet, sizeof(packet)); 
....................     MACPutArray(&packet, sizeof(ARP_PACKET)); 
1B66:  MOVLW  03
1B68:  MOVLB  3
1B6A:  MOVWF  xA2
1B6C:  MOVLW  02
1B6E:  MOVWF  xA1
1B70:  CLRF   xA4
1B72:  MOVLW  1C
1B74:  MOVWF  xA3
1B76:  MOVLB  0
1B78:  RCALL  16F0
....................  
....................     MACFlush(); 
1B7A:  RCALL  17FC
....................     
....................    return TRUE; 
1B7C:  MOVLW  01
1B7E:  MOVWF  01
1B80:  MOVLB  3
.................... } 
1B82:  MOVLB  0
1B84:  GOTO   1C0A (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapARPPacket(ARP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p   - ARP packet to be swapped. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapARPPacket(ARP_PACKET *p) 
.................... { 
....................     p->HardwareType     = swaps(p->HardwareType); 
*
1474:  MOVLB  3
1476:  MOVFF  320,01
147A:  MOVFF  321,03
147E:  MOVFF  320,322
1482:  MOVFF  321,323
1486:  MOVFF  320,FE9
148A:  MOVFF  321,FEA
148E:  MOVFF  FEC,325
1492:  MOVF   FED,F
1494:  MOVFF  FEF,324
1498:  MOVFF  325,39D
149C:  MOVFF  324,39C
14A0:  MOVLB  0
14A2:  RCALL  1326
14A4:  MOVFF  323,FEA
14A8:  MOVFF  322,FE9
14AC:  MOVFF  02,FEC
14B0:  MOVF   FED,F
14B2:  MOVFF  01,FEF
....................     p->Protocol         = swaps(p->Protocol); 
14B6:  MOVLW  02
14B8:  MOVLB  3
14BA:  ADDWF  x20,W
14BC:  MOVWF  01
14BE:  MOVLW  00
14C0:  ADDWFC x21,W
14C2:  MOVWF  03
14C4:  MOVFF  01,322
14C8:  MOVWF  x23
14CA:  MOVLW  02
14CC:  ADDWF  x20,W
14CE:  MOVWF  FE9
14D0:  MOVLW  00
14D2:  ADDWFC x21,W
14D4:  MOVWF  FEA
14D6:  MOVFF  FEC,325
14DA:  MOVF   FED,F
14DC:  MOVFF  FEF,324
14E0:  MOVFF  325,39D
14E4:  MOVFF  324,39C
14E8:  MOVLB  0
14EA:  RCALL  1326
14EC:  MOVFF  323,FEA
14F0:  MOVFF  322,FE9
14F4:  MOVFF  02,FEC
14F8:  MOVF   FED,F
14FA:  MOVFF  01,FEF
....................     p->Operation        = swaps(p->Operation); 
14FE:  MOVLW  06
1500:  MOVLB  3
1502:  ADDWF  x20,W
1504:  MOVWF  01
1506:  MOVLW  00
1508:  ADDWFC x21,W
150A:  MOVWF  03
150C:  MOVFF  01,322
1510:  MOVWF  x23
1512:  MOVLW  06
1514:  ADDWF  x20,W
1516:  MOVWF  FE9
1518:  MOVLW  00
151A:  ADDWFC x21,W
151C:  MOVWF  FEA
151E:  MOVFF  FEC,325
1522:  MOVF   FED,F
1524:  MOVFF  FEF,324
1528:  MOVFF  325,39D
152C:  MOVFF  324,39C
1530:  MOVLB  0
1532:  RCALL  1326
1534:  MOVFF  323,FEA
1538:  MOVFF  322,FE9
153C:  MOVFF  02,FEC
1540:  MOVF   FED,F
1542:  MOVFF  01,FEF
.................... } 
1546:  RETLW  00
....................  
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    #include "tcpip/http.c" 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///                              HTTP.C 
.................... /// 
.................... /// Simple webserver for the Microchip TCP/IP stack. 
.................... /// NOTE: THIS IS A DIFFERENT HTTP.C THAN WHAT MICROCHIP PROVIDES 
.................... /// 
.................... /// **** CONFIGURATION **** 
.................... /// 
.................... /// STACK_USE_HTTP - Define this to be true before you include stacktsk.c 
.................... ///        in your application.  Defining this to be true will cause 
.................... ///        the stack to include the HTTP portion and execute the init 
.................... ///        and process any HTTP tasks. 
.................... /// 
.................... /// HTTP_PORT - The TCP/IP port the HTTP server will listen to for HTTP 
.................... ///        connections. 
.................... /// 
.................... /// HTTP_NUM_SOCKETS - Number of sockets the stack will open for the 
.................... ///        HTTP server.  You probably will be fine with just 1.  The 
.................... ///        more sockets you use the more RAM is used to hold buffers 
.................... ///        and state configuration. 
.................... /// 
.................... /// HTTP_GET_PARAM_MAX_SIZE - This defines the maximum size of several 
.................... ///        buffers.  This limits the size of your GET or POST requests 
.................... ///        and all CGI POST data: 
.................... ///            If using GET, then max amount of cgi data is this value 
.................... ///            minus everything else on the initial GET command (which 
.................... ///            also includes the filename).  I believe the max specified 
.................... ///            by W3C is 255. 
.................... ///            If using POST, then this is the maximum size for one 
.................... ///            key=value pair (including the '=' sign). 
.................... ///        These values do not inlude any escape characters. 
.................... /// 
.................... /// HTTP_USE_CHUNKS - Set to TRUE to make the HTTP server 1.1 compliant 
.................... ///      and will use Transfer-Encoding: chunked.  Default is FALSE. 
.................... /// 
.................... /// HTTP_USE_DOUBLE_ESCAPE - If your HTTP pages need more escape 
.................... ///      chars, set this to TRUE.  When set to TRUE your HTTP pages have 
.................... ///      two escape characters after the %.  An example of each: 
.................... ///         If FALSE: %A 
.................... ///         If TRUE: %0A 
.................... /// 
.................... /// HTTP_USE_CONTENT_TYPE - Set to TRUE if your http_get_page() has a third 
.................... ///      parameter which is the content-type of the requested page. 
.................... /// 
.................... /// **** HOW IT WORKS **** 
.................... /// 
.................... /// The TCP/IP stack will open sockets to the desired ports.  It will 
.................... /// then listen for GET or POST requests.  When it gets a GET or POST 
.................... /// request it passes the page request to the callback function 
.................... /// http_get_page() which then returns 0 if the page doesn't exist, or 
.................... /// a pointer to the constant memory area that holds the page in program 
.................... /// memory.  If it was a POST request it waits until the HTTP header is 
.................... /// done and then saves the POST data into a buffer, and passes the 
.................... /// buffer to the callback function http_exec_cgi().  http_exec_cgi() will 
.................... /// parse the CGI post data and act upon it.  When done, the HTTP 
.................... /// server then responds by sending the page.  If the page is to have 
.................... /// variable data, it can be represented by an escape code - %0 or %1 
.................... /// for example.  When the HTTP stack sees such an escape code it calls 
.................... /// the callback function http_format_char() to format the escape code 
.................... /// into the needed variable data (such as ADC readings).  After the 
.................... /// HTTP stack is done sending the request it will close the port. 
.................... /// If the page didn't exist in program memory it will send a 404 File 
.................... /// not found error.  If there was a problem/timeout parsing the request 
.................... /// the HTTP stack will send a 500 Internal Server Error response. 
.................... /// 
.................... /// **** CALL BACK FUNCTIONS **** 
.................... /// 
.................... /// Your main application must provide the following callback functions to 
.................... /// fill application dependent needs: 
.................... /// 
.................... /// http_get_page(char *file); 
.................... ///    If HTTP_USE_CONTENT_TYPE is FALSE, this is the proper prototype.  Else, 
.................... ///    if HTTP_USE_CONTENT_TYPE is TRUE then see the next paragraph. 
.................... ///    A call-back function provided by your application that finds the 
.................... ///    required file.  If the file exists, returns address to page in 
.................... ///    program memory.  If it doesn't exist, returns 0. 
.................... /// 
.................... /// http_get_page(char *file_str, int32 *retAddress, char *retStr); 
.................... ///    If HTTP_USE_CONTENT_TYPE is TRUE, this is the proper prototype.  Else, 
.................... ///    if HTTP_USE_CONTENT_TYPE is FALSE then see the previous paragraph. 
.................... ///    A call-back function provided by your application that finds the 
.................... ///    required file.  If the file exists, saves value to retAddress.  If 
.................... ///    the file doesn't exist, will save 0 to retAddress.  retStr is the 
.................... ///    content-type (text/html, text/xml, etc). 
.................... /// 
.................... /// http_exec_cgi(int32 file, char *key, char *val); 
.................... ///    A call-back function provided by your application that processes incoming 
.................... ///    CGI commands.  key and val are the incoming key=val CGI pairs.  file is 
.................... ///    the file address as returned by http_get_page(). 
.................... /// 
.................... /// int http_format_char(int32 file, char id, char *str, int8 max_ret); 
.................... ///    Given an escaped character in the program memory HTTP file, convert to 
.................... ///    variable data.  id is the escaped character, *str is where to save the 
.................... ///    result.  max_ret is the maximum amount of bytes you can save to *str. 
.................... ///    Returns the number of bytes written to *str.  file is 
.................... ///    the file address as returned by http_get_page(). 
.................... /// 
.................... /// **** LIMITATIONS **** 
.................... /// 
.................... /// When creating web pages with forms, keep your form names (keys) simple 
.................... /// because the HTTP stack does not format the escape characters.  For example, 
.................... /// when sending "Pass+Word" the HTTP client will parse it out as "Pass%2bWord". 
.................... /// The HTTP stack will correctly parse out the escape chars when retrieving 
.................... /// the value, but not the key.  Therefore keep your keys simple. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// * Author         Date           Comment 
.................... /// *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... /// 
.................... /// * Darren Rook    Oct 05 2006    Bug fix involving POST 
.................... /// 
.................... /// * Darren Rook    Summer 2006    Large parts of this rewritten to fix 
.................... ///                                 many bugs.  The biggest bug is that 
.................... ///                                 it can send pages and receive CGI that 
.................... ///                                 is larger than 1 TCP packet.  Also 
.................... ///                                 added the HTTP_USE_CHUNKS, 
.................... ///                                 HTTP_USE_DOUBLE_ESCAPE and 
.................... ///                                 HTTP_USE_CONTENT_TYPE paremeters. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #include "tcpip/http.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                     /// 
.................... ///                              HTTP.H                                 /// 
.................... ///                                                                     /// 
.................... /// Simple webserver for the Microchip TCP/IP stack.                    /// 
.................... /// NOTE: THIS IS A DIFFERENT HTTP.H THAN WHAT MICROCHIP PROVIDES       /// 
.................... ///                                                                     /// 
.................... /// See HTTP.C for documenation                                         /// 
.................... ///                                                                     /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef HTTP_USE_CHUNKS 
.................... #define HTTP_USE_CHUNKS   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_DOUBLE_ESCAPE 
.................... #define HTTP_USE_DOUBLE_ESCAPE   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_CONTENT_TYPE 
.................... #define HTTP_USE_CONTENT_TYPE   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_PORT 
.................... #define HTTP_PORT             80 
.................... #endif 
....................  
.................... #ifndef HTTP_NUM_SOCKETS 
.................... #define HTTP_NUM_SOCKETS      1 
.................... #endif 
....................  
.................... #ifndef HTTP_GET_PARAM_MAX_SIZE 
.................... #define HTTP_GET_PARAM_MAX_SIZE  254 
.................... #endif 
....................  
.................... void HTTP_Init(void); 
.................... void HTTP_Task(void); 
....................  
.................... //**** CALLBACKS START ******/// 
....................  
.................... /// the following three functions are callbacks and 
.................... /// must be written in your main application!!!  see the documentation above 
.................... /// for more help. 
....................  
.................... #if HTTP_USE_CONTENT_TYPE 
....................  void http_get_page(char *file_str, int32 *retAddress, char *retStr); 
.................... #else 
....................  int32 http_get_page(char *file_str); 
.................... #endif 
....................  
.................... int8 http_format_char(int32 file, char id, char *str, int8 max_ret); 
.................... void http_exec_cgi(int32 file, char *key, char *val); 
....................  
.................... //**** CALLBACKS END ******/// 
....................  
....................  
.................... //#define debug_http   debug_printf 
.................... #define debug_http(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u) 
....................  
.................... const char http_404_error[]="<HTML><BODY><H1>404 Error</H1><HR><P>File Not found.</BODY></HTML>"; 
.................... const char http_500_error[]="<HTML><BODY><H1>500 Error</H1><HR><P>Internal Server Error</BODY></HTML>"; 
....................  
.................... //key=val pair string, & delimited 
.................... void http_parse_cgi_str(int32 file, char *cgistr); 
....................  
.................... int8 http_socket[HTTP_NUM_SOCKETS]={INVALID_SOCKET}; 
....................  
.................... enum { 
....................    HTTP_DISABLED = 0xFF, 
....................    HTTP_IGNORE, 
....................    HTTP_LISTEN_WAIT, 
....................    HTTP_CONNECTED, 
....................    HTTP_GET_HEADERS, 
....................    HTTP_GET_POST, 
....................    HTTP_GET_POST_CONTINUE, 
....................    HTTP_SEND_RESPONSE, 
....................    HTTP_SEND_RESPONSE_CONTINUE, 
....................    HTTP_CLOSE, 
....................    HTTP_CLOSE_WAITING, 
....................    HTTP_CLOSED 
.................... } http_state[HTTP_NUM_SOCKETS]={HTTP_IGNORE}; 
....................  
.................... //strips out any escape characters that the HTTP client may have inserted. 
.................... // (+ is replaced with space) 
.................... // (%xx is replaced with character representation of xx) 
.................... char * http_escape_chars(char *str) 
.................... { 
....................    char *ostr; 
....................    char new[3]; 
....................    char c; 
....................    char val; 
....................  
....................    new[2]=0; 
*
4942:  MOVLB  3
4944:  CLRF   x13
....................  
....................    ostr = str; 
4946:  MOVFF  30E,310
494A:  MOVFF  30D,30F
....................  
....................    while((c=*str) != 0) 
....................    { 
494E:  MOVFF  30E,03
4952:  MOVFF  30D,FE9
4956:  MOVFF  30E,FEA
495A:  MOVFF  FEF,314
495E:  MOVF   x14,F
4960:  BZ    4A22
....................       if (c=='+') 
4962:  MOVF   x14,W
4964:  SUBLW  2B
4966:  BNZ   4980
....................          *str++=' '; 
4968:  MOVFF  30E,03
496C:  MOVF   x0D,W
496E:  INCF   x0D,F
4970:  BTFSC  FD8.2
4972:  INCF   x0E,F
4974:  MOVWF  FE9
4976:  MOVFF  03,FEA
497A:  MOVLW  20
497C:  MOVWF  FEF
....................       else if (c=='%') 
497E:  BRA    4A1E
4980:  MOVF   x14,W
4982:  SUBLW  25
4984:  BNZ   4A18
....................       { 
....................          memcpy(new, str + 1, 2); 
4986:  MOVLW  01
4988:  ADDWF  x0D,W
498A:  MOVWF  x16
498C:  MOVLW  00
498E:  ADDWFC x0E,W
4990:  MOVWF  x17
4992:  MOVLW  03
4994:  MOVWF  FEA
4996:  MOVLW  11
4998:  MOVWF  FE9
499A:  MOVFF  317,FE2
499E:  MOVFF  316,FE1
49A2:  MOVLW  02
49A4:  MOVWF  01
49A6:  MOVFF  FE6,FEE
49AA:  DECFSZ 01,F
49AC:  BRA    49A6
....................          val = strtoul(new, 0, 16); 
49AE:  MOVLW  03
49B0:  MOVWF  x17
49B2:  MOVLW  11
49B4:  MOVWF  x16
49B6:  CLRF   x19
49B8:  CLRF   x18
49BA:  MOVLW  10
49BC:  MOVWF  x1A
49BE:  MOVLB  0
49C0:  BRA    44D2
49C2:  MOVFF  01,315
....................          *str++ = val; 
49C6:  MOVLB  3
49C8:  MOVFF  30E,03
49CC:  MOVF   x0D,W
49CE:  INCF   x0D,F
49D0:  BTFSC  FD8.2
49D2:  INCF   x0E,F
49D4:  MOVWF  FE9
49D6:  MOVFF  03,FEA
49DA:  MOVFF  315,FEF
....................          memmove(str, str + 2, strlen(str) - 1); 
49DE:  MOVLW  02
49E0:  ADDWF  x0D,W
49E2:  MOVWF  x16
49E4:  MOVLW  00
49E6:  ADDWFC x0E,W
49E8:  MOVWF  x17
49EA:  MOVFF  30E,32C
49EE:  MOVFF  30D,32B
49F2:  MOVLB  0
49F4:  RCALL  483E
49F6:  MOVLW  01
49F8:  SUBWF  01,W
49FA:  MOVLB  3
49FC:  MOVWF  x18
49FE:  MOVFF  30E,31A
4A02:  MOVFF  30D,319
4A06:  MOVFF  317,31C
4A0A:  MOVFF  316,31B
4A0E:  MOVWF  x1D
4A10:  MOVLB  0
4A12:  BRA    4878
....................       } 
....................       else 
4A14:  BRA    4A1E
4A16:  MOVLB  3
....................          str++; 
4A18:  INCF   x0D,F
4A1A:  BTFSC  FD8.2
4A1C:  INCF   x0E,F
....................    } 
4A1E:  MOVLB  3
4A20:  BRA    494E
....................  
....................    return(ostr); 
4A22:  MOVFF  30F,01
4A26:  MOVFF  310,02
.................... } 
4A2A:  MOVLB  0
4A2C:  RETLW  00
....................  
.................... void http_parse_cgi_string(int32 file, char *ptr) 
.................... { 
....................    char *pKey, *pValue, c; 
....................  
....................    pKey=ptr; 
*
4FAE:  MOVFF  307,309
4FB2:  MOVFF  306,308
....................    pValue=0; 
4FB6:  MOVLB  3
4FB8:  CLRF   x0B
4FBA:  CLRF   x0A
....................  
....................    while(TRUE) 
....................    { 
....................       c = *ptr; 
4FBC:  MOVFF  306,FE9
4FC0:  MOVFF  307,FEA
4FC4:  MOVFF  FEF,30C
....................       if ((c=='&') || (c==0)) 
4FC8:  MOVF   x0C,W
4FCA:  SUBLW  26
4FCC:  BZ    4FD2
4FCE:  MOVF   x0C,F
4FD0:  BNZ   502E
....................       { 
....................          *ptr=0; 
4FD2:  MOVFF  306,FE9
4FD6:  MOVFF  307,FEA
4FDA:  CLRF   FEF
....................          http_escape_chars(pKey); 
4FDC:  MOVFF  309,30E
4FE0:  MOVFF  308,30D
4FE4:  MOVLB  0
4FE6:  RCALL  4942
....................          http_escape_chars(pValue); 
4FE8:  MOVFF  30B,30E
4FEC:  MOVFF  30A,30D
4FF0:  RCALL  4942
....................          http_exec_cgi(file, pKey, pValue); 
4FF2:  MOVFF  305,310
4FF6:  MOVFF  304,30F
4FFA:  MOVFF  303,30E
4FFE:  MOVFF  302,30D
5002:  MOVFF  309,312
5006:  MOVFF  308,311
500A:  MOVFF  30B,314
500E:  MOVFF  30A,313
5012:  BRA    4EBA
....................          pKey=ptr+1; 
5014:  MOVLW  01
5016:  MOVLB  3
5018:  ADDWF  x06,W
501A:  MOVWF  x08
501C:  MOVLW  00
501E:  ADDWFC x07,W
5020:  MOVWF  x09
....................          pValue=0; 
5022:  CLRF   x0B
5024:  CLRF   x0A
....................          if (c==0) 
5026:  MOVF   x0C,F
5028:  BNZ   502C
....................             break; 
502A:  BRA    5052
....................       } 
....................       else if (c=='=') 
502C:  BRA    504A
502E:  MOVF   x0C,W
5030:  SUBLW  3D
5032:  BNZ   504A
....................       { 
....................          *ptr=0; 
5034:  MOVFF  306,FE9
5038:  MOVFF  307,FEA
503C:  CLRF   FEF
....................          pValue=ptr+1; 
503E:  MOVLW  01
5040:  ADDWF  x06,W
5042:  MOVWF  x0A
5044:  MOVLW  00
5046:  ADDWFC x07,W
5048:  MOVWF  x0B
....................       } 
....................       ptr++; 
504A:  INCF   x06,F
504C:  BTFSC  FD8.2
504E:  INCF   x07,F
....................    } 
5050:  BRA    4FBC
.................... } 
5052:  MOVLB  0
5054:  RETLW  00
....................  
.................... int8 _httpPutcSocket; 
....................  
.................... #define tcp_http_tx_left()  TCPPutAvailable(_httpPutcSocket) 
....................  
.................... void set_tcp_http_putc(int8 newSocket) 
.................... { 
....................    _httpPutcSocket=newSocket; 
*
5362:  MOVFF  30C,121
.................... } 
5366:  GOTO   5F10 (RETURN)
....................  
.................... int tcp_http_putc(char c) 
.................... { 
....................    return(TCPPut(_httpPutcSocket,c)); 
*
567E:  MOVFF  121,32B
5682:  MOVFF  32A,32C
5686:  BRA    5534
5688:  MOVF   01,W
.................... } 
568A:  RETLW  00
....................  
.................... int32 lastHTTPPutConstPos[HTTP_NUM_SOCKETS]; 
.................... char * lastHTTPPutVarPos[HTTP_NUM_SOCKETS]; 
....................  
.................... #if HTTP_USE_CHUNKS 
.................... void TCPPutFileChunkStart(int16 count) 
.................... { 
....................    printf(tcp_http_putc, "%04LX\r\n", count); 
.................... } 
....................  
.................... void TCPPutFileChunkStop(void) 
.................... { 
....................    tcp_http_putc('\r'); 
....................    tcp_http_putc('\n'); 
.................... } 
.................... #else 
....................  #define TCPPutFileChunkStart(x) 
....................  #define TCPPutFileChunkStop() 
.................... #endif 
....................  
.................... typedef enum 
.................... { 
....................    TCP_PUT_CONST_EC_FINISH = 0, 
....................    TCP_PUT_CONST_EC_CONTINUE, 
....................    TCP_PUT_CONST_EC_ESCAPE 
.................... } TCP_PUT_CONST_EC; 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // TCPPutFileVarChunk(ptr) 
.................... // 
.................... // send a chunked response from ram 
.................... // 
.................... // ptr - data to send (well be sent as an http/1.1 chunk).  It will be updated 
.................... //          with the continue position before exit. 
.................... // 
.................... // Returns a status code: 
.................... //    TCP_PUT_CONST_EC_FINISH - The whole chunk was completed 
.................... //    TCP_PUT_CONST_EC_CONTINUE - The chunk needs to be continued 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //TCP_PUT_CONST_EC TCPPutFileVarChunk(char **retPtr) 
.................... //because of a compiler error i had to make this double pointer an int16, when 
.................... //it should be a char. 
.................... TCP_PUT_CONST_EC TCPPutFileVarChunk(int16 **retPtr) 
.................... { 
....................    int16 txLeft, n; 
....................    char *ptr, ec; 
....................  
....................    ptr=*retPtr; 
*
58B6:  MOVLB  3
58B8:  MOVFF  30E,FE9
58BC:  MOVFF  30F,FEA
58C0:  MOVFF  FEC,03
58C4:  MOVF   FED,F
58C6:  MOVFF  FEF,314
58CA:  MOVFF  03,315
....................  
....................    n=strlen(ptr); 
58CE:  MOVFF  315,32C
58D2:  MOVFF  314,32B
58D6:  MOVLB  0
58D8:  CALL   483E
58DC:  MOVLB  3
58DE:  CLRF   x13
58E0:  MOVFF  01,312
....................  
....................    if (!n) 
58E4:  MOVF   x12,W
58E6:  IORWF  x13,W
58E8:  BNZ   58F0
....................       return(TCP_PUT_CONST_EC_FINISH); 
58EA:  MOVLW  00
58EC:  MOVWF  01
58EE:  BRA    5974
....................  
....................    txLeft = tcp_http_tx_left(); 
58F0:  MOVFF  121,31A
58F4:  MOVLB  0
58F6:  RCALL  57BA
58F8:  MOVFF  02,311
58FC:  MOVFF  01,310
....................  
....................   #if HTTP_USE_CHUNKS 
....................    if (txLeft > 8) 
....................       txLeft -= 8;   //save space for 2x CRLF and 4 chars 
....................    else 
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
....................   #else 
....................    if (!txLeft) 
5900:  MOVLB  3
5902:  MOVF   x10,W
5904:  IORWF  x11,W
5906:  BNZ   590E
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
5908:  MOVLW  01
590A:  MOVWF  01
590C:  BRA    5974
....................   #endif 
....................  
....................    if (n > txLeft) 
590E:  MOVF   x11,W
5910:  SUBWF  x13,W
5912:  BNC   5922
5914:  BNZ   591C
5916:  MOVF   x12,W
5918:  SUBWF  x10,W
591A:  BC    5922
....................    { 
....................       ec = TCP_PUT_CONST_EC_CONTINUE; 
591C:  MOVLW  01
591E:  MOVWF  x16
....................    } 
....................    else 
5920:  BRA    592C
....................    { 
....................       txLeft = n; 
5922:  MOVFF  313,311
5926:  MOVFF  312,310
....................       ec = TCP_PUT_CONST_EC_FINISH; 
592A:  CLRF   x16
....................    } 
....................  
....................    TCPPutFileChunkStart(txLeft); 
....................  
....................    while (txLeft--) 
....................    { 
592C:  MOVFF  311,03
5930:  MOVF   x10,W
5932:  BTFSC  FD8.2
5934:  DECF   x11,F
5936:  DECF   x10,F
5938:  IORWF  03,W
593A:  BZ    595E
....................       tcp_http_putc(*ptr++); 
593C:  MOVFF  315,03
5940:  MOVF   x14,W
5942:  INCF   x14,F
5944:  BTFSC  FD8.2
5946:  INCF   x15,F
5948:  MOVWF  FE9
594A:  MOVFF  03,FEA
594E:  MOVFF  FEF,317
5952:  MOVFF  317,32A
5956:  MOVLB  0
5958:  RCALL  567E
....................    } 
595A:  MOVLB  3
595C:  BRA    592C
....................  
....................    TCPPutFileChunkStop(); 
....................  
....................    *retPtr=ptr; 
595E:  MOVFF  30E,FE9
5962:  MOVFF  30F,FEA
5966:  MOVFF  315,FEC
596A:  MOVF   FED,F
596C:  MOVFF  314,FEF
....................  
....................    return(ec); 
5970:  MOVFF  316,01
.................... } 
5974:  MOVLB  0
5976:  RETLW  00
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // TCPPutFileParseConst(addy, n, doSend) 
.................... // 
.................... // Reads file from Const memory.  Stops when it reaches an escape sequence, 
.................... // n chars or an end of file 
.................... // 
.................... // addy - data to read (well be sent as an http/1.1 chunk).  This address 
.................... //        will be updated for the next call. 
.................... // 
.................... // n - max number of chars to read from file.  will save the total number 
.................... //    of chars passed to this pointer. 
.................... // 
.................... // doSend - if TRUE, then send data to TCP socket 
.................... // 
.................... // returns the last char read 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... char TCPPutFileParseConst(int32 *retAddy, int16 *n, int8 doSend) 
.................... { 
*
5996:  MOVLB  3
5998:  CLRF   x22
599A:  CLRF   x21
599C:  BSF    x29.0
....................    char stopC, checkC; 
....................    int16 fileSize = 0, max; 
....................    int32 addy; 
....................    int1 premature = TRUE; 
....................  
....................    max = *n; 
599E:  MOVFF  31C,FE9
59A2:  MOVFF  31D,FEA
59A6:  MOVFF  FEC,03
59AA:  MOVF   FED,F
59AC:  MOVFF  FEF,323
59B0:  MOVFF  03,324
....................    addy = *retAddy; 
59B4:  MOVFF  31A,FE9
59B8:  MOVFF  31B,FEA
59BC:  MOVFF  FEF,00
59C0:  MOVFF  FEC,01
59C4:  MOVFF  FEC,02
59C8:  MOVFF  FEC,03
59CC:  MOVFF  03,328
59D0:  MOVFF  02,327
59D4:  MOVFF  01,326
59D8:  MOVFF  00,325
....................  
....................    while (TRUE) 
....................    { 
....................       read_program_memory(addy++, &stopC, 1); 
59DC:  MOVFF  328,03
59E0:  MOVFF  327,02
59E4:  MOVFF  326,01
59E8:  MOVFF  325,00
59EC:  MOVLW  01
59EE:  ADDWF  x25,F
59F0:  BTFSC  FD8.0
59F2:  INCF   x26,F
59F4:  BTFSC  FD8.2
59F6:  INCF   x27,F
59F8:  BTFSC  FD8.2
59FA:  INCF   x28,F
59FC:  MOVFF  03,32D
5A00:  MOVFF  02,32C
5A04:  MOVFF  01,32B
5A08:  MOVFF  00,32A
5A0C:  MOVFF  02,FF8
5A10:  MOVFF  01,FF7
5A14:  MOVFF  00,FF6
5A18:  MOVLW  03
5A1A:  MOVWF  FEA
5A1C:  MOVLW  1F
5A1E:  MOVWF  FE9
5A20:  CLRF   x2F
5A22:  MOVLW  01
5A24:  MOVWF  x2E
5A26:  MOVLB  0
5A28:  RCALL  5978
....................       if (stopC == '%') 
5A2A:  MOVLB  3
5A2C:  MOVF   x1F,W
5A2E:  SUBLW  25
5A30:  BNZ   5AB4
....................       { 
....................          read_program_memory(addy++, &checkC, 1); 
5A32:  MOVFF  328,03
5A36:  MOVFF  327,02
5A3A:  MOVFF  326,01
5A3E:  MOVFF  325,00
5A42:  MOVLW  01
5A44:  ADDWF  x25,F
5A46:  BTFSC  FD8.0
5A48:  INCF   x26,F
5A4A:  BTFSC  FD8.2
5A4C:  INCF   x27,F
5A4E:  BTFSC  FD8.2
5A50:  INCF   x28,F
5A52:  MOVFF  03,32D
5A56:  MOVFF  02,32C
5A5A:  MOVFF  01,32B
5A5E:  MOVFF  00,32A
5A62:  MOVFF  02,FF8
5A66:  MOVFF  01,FF7
5A6A:  MOVFF  00,FF6
5A6E:  MOVLW  03
5A70:  MOVWF  FEA
5A72:  MOVLW  20
5A74:  MOVWF  FE9
5A76:  CLRF   x2F
5A78:  MOVLW  01
5A7A:  MOVWF  x2E
5A7C:  MOVLB  0
5A7E:  RCALL  5978
....................          if (checkC == '%') 
5A80:  MOVLB  3
5A82:  MOVF   x20,W
5A84:  SUBLW  25
5A86:  BNZ   5AB0
....................          { 
....................             if (fileSize < max) 
5A88:  MOVF   x22,W
5A8A:  SUBWF  x24,W
5A8C:  BNC   5AAC
5A8E:  BNZ   5A96
5A90:  MOVF   x23,W
5A92:  SUBWF  x21,W
5A94:  BC    5AAC
....................             { 
....................                if (doSend) 
5A96:  MOVF   x1E,F
5A98:  BZ    5AA4
....................                   tcp_http_putc('%'); 
5A9A:  MOVLW  25
5A9C:  MOVWF  x2A
5A9E:  MOVLB  0
5AA0:  RCALL  567E
5AA2:  MOVLB  3
....................                fileSize++; 
5AA4:  INCF   x21,F
5AA6:  BTFSC  FD8.2
5AA8:  INCF   x22,F
....................             } 
....................             else 
5AAA:  BRA    5AAE
....................                break; 
5AAC:  BRA    5AE6
....................          } 
....................          else 
5AAE:  BRA    5AB2
....................             break;   //ESCAPE 
5AB0:  BRA    5AE6
....................       } 
....................       else if (stopC) 
5AB2:  BRA    5AE4
5AB4:  MOVF   x1F,F
5AB6:  BZ    5AE0
....................       { 
....................          if (fileSize < max) 
5AB8:  MOVF   x22,W
5ABA:  SUBWF  x24,W
5ABC:  BNC   5ADC
5ABE:  BNZ   5AC6
5AC0:  MOVF   x23,W
5AC2:  SUBWF  x21,W
5AC4:  BC    5ADC
....................          { 
....................             if (doSend) 
5AC6:  MOVF   x1E,F
5AC8:  BZ    5AD4
....................                tcp_http_putc(stopC); 
5ACA:  MOVFF  31F,32A
5ACE:  MOVLB  0
5AD0:  RCALL  567E
5AD2:  MOVLB  3
....................             fileSize++; 
5AD4:  INCF   x21,F
5AD6:  BTFSC  FD8.2
5AD8:  INCF   x22,F
....................          } 
....................          else 
5ADA:  BRA    5ADE
....................             break; 
5ADC:  BRA    5AE6
....................       } 
....................       else 
5ADE:  BRA    5AE4
....................       { 
....................          premature = FALSE; 
5AE0:  BCF    x29.0
....................          break;   //EOF (stopC == 0) 
5AE2:  BRA    5AE6
....................       } 
....................    } 
5AE4:  BRA    59DC
....................  
....................    if (premature) 
5AE6:  BTFSS  x29.0
5AE8:  BRA    5AFA
....................       addy--; 
5AEA:  MOVLW  FF
5AEC:  ADDWF  x25,F
5AEE:  BTFSS  FD8.0
5AF0:  ADDWF  x26,F
5AF2:  BTFSS  FD8.0
5AF4:  ADDWF  x27,F
5AF6:  BTFSS  FD8.0
5AF8:  ADDWF  x28,F
....................  
....................    *n = fileSize; 
5AFA:  MOVFF  31C,FE9
5AFE:  MOVFF  31D,FEA
5B02:  MOVFF  322,FEC
5B06:  MOVF   FED,F
5B08:  MOVFF  321,FEF
....................    *retAddy = addy; 
5B0C:  MOVFF  31A,FE9
5B10:  MOVFF  31B,FEA
5B14:  MOVFF  325,FEF
5B18:  MOVFF  326,FEC
5B1C:  MOVFF  327,FEC
5B20:  MOVFF  328,FEC
....................  
....................    return(stopC); 
5B24:  MOVFF  31F,01
.................... } 
5B28:  MOVLB  0
5B2A:  RETLW  00
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // TCPPutFileConstChunk(*addy) 
.................... // 
.................... // send a chunked response from constant memory 
.................... // 
.................... // addy - data to send (well be sent as an http/1.1 chunk).  This address 
.................... //        will be updated for the next call. 
.................... // 
.................... // returns a response: 
.................... //    TCP_PUT_CONST_EC_CONTINUE: we ran out of space to put more data, continue 
.................... //                            from this position on next call. 
.................... //    TCP_PUT_CONST_EC_ESCAPE:   an escape character 
.................... //    TCP_PUT_CONST_EC_FINISH:   we finished reading the chunk, end of file. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... TCP_PUT_CONST_EC TCPPutFileConstChunk(int32 *retAddy) 
.................... { 
5B2C:  MOVLB  3
5B2E:  CLRF   x16
5B30:  CLRF   x15
....................    char stopC; 
....................    int32 addy; 
....................    int16 fileSize = 0, txLeft; 
....................    TCP_PUT_CONST_EC ec; 
....................  
....................    txLeft = tcp_http_tx_left(); 
5B32:  MOVFF  121,31A
5B36:  MOVLB  0
5B38:  RCALL  57BA
5B3A:  MOVFF  02,318
5B3E:  MOVFF  01,317
....................  
....................  #if HTTP_USE_CHUNKS 
....................    if (txLeft > 8) 
....................       txLeft -= 8;   //save space for 2x CRLF and 4 chars 
....................    else 
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
....................  #else 
....................    if (!txLeft) 
5B42:  MOVLB  3
5B44:  MOVF   x17,W
5B46:  IORWF  x18,W
5B48:  BNZ   5B50
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
5B4A:  MOVLW  01
5B4C:  MOVWF  01
5B4E:  BRA    5BFE
....................  #endif 
....................  
....................    addy = *retAddy; 
5B50:  MOVFF  30E,FE9
5B54:  MOVFF  30F,FEA
5B58:  MOVFF  FEF,00
5B5C:  MOVFF  FEC,01
5B60:  MOVFF  FEC,02
5B64:  MOVFF  FEC,03
5B68:  MOVFF  03,314
5B6C:  MOVFF  02,313
5B70:  MOVFF  01,312
5B74:  MOVFF  00,311
....................  
....................    fileSize = 0xFFFF; 
5B78:  MOVLW  FF
5B7A:  MOVWF  x16
5B7C:  MOVWF  x15
....................    stopC = TCPPutFileParseConst(&addy, &fileSize, FALSE); 
5B7E:  MOVLW  03
5B80:  MOVWF  x1B
5B82:  MOVLW  11
5B84:  MOVWF  x1A
5B86:  MOVLW  03
5B88:  MOVWF  x1D
5B8A:  MOVLW  15
5B8C:  MOVWF  x1C
5B8E:  CLRF   x1E
5B90:  MOVLB  0
5B92:  RCALL  5996
5B94:  MOVFF  01,310
....................  
....................    if (!fileSize && (stopC!='%')) 
5B98:  MOVLB  3
5B9A:  MOVF   x15,W
5B9C:  IORWF  x16,W
5B9E:  BNZ   5BAC
5BA0:  MOVF   x10,W
5BA2:  SUBLW  25
5BA4:  BZ    5BAC
....................       return(TCP_PUT_CONST_EC_FINISH); 
5BA6:  MOVLW  00
5BA8:  MOVWF  01
5BAA:  BRA    5BFE
....................  
....................    //TODO: optimize 
....................    if (fileSize > txLeft) 
5BAC:  MOVF   x18,W
5BAE:  SUBWF  x16,W
5BB0:  BNC   5BC8
5BB2:  BNZ   5BBA
5BB4:  MOVF   x15,W
5BB6:  SUBWF  x17,W
5BB8:  BC    5BC8
....................    { 
....................       fileSize = txLeft; 
5BBA:  MOVFF  318,316
5BBE:  MOVFF  317,315
.................... //      if (stopC == '%') 
.................... //         ec = TCP_PUT_CONST_EC_ESCAPE; 
.................... //      else 
....................          ec = TCP_PUT_CONST_EC_CONTINUE; 
5BC2:  MOVLW  01
5BC4:  MOVWF  x19
....................    } 
....................    else 
5BC6:  BRA    5BE0
....................    { 
....................       if (stopC == '%') 
5BC8:  MOVF   x10,W
5BCA:  SUBLW  25
5BCC:  BNZ   5BD4
....................          ec = TCP_PUT_CONST_EC_ESCAPE; 
5BCE:  MOVLW  02
5BD0:  MOVWF  x19
....................       else if (stopC) 
5BD2:  BRA    5BE0
5BD4:  MOVF   x10,F
5BD6:  BZ    5BDE
....................          ec = TCP_PUT_CONST_EC_CONTINUE; 
5BD8:  MOVLW  01
5BDA:  MOVWF  x19
....................       else 
5BDC:  BRA    5BE0
....................          ec = TCP_PUT_CONST_EC_FINISH; 
5BDE:  CLRF   x19
....................    } 
....................  
....................    TCPPutFileChunkStart(fileSize); 
....................  
....................    TCPPutFileParseConst(retAddy, &fileSize, TRUE); 
5BE0:  MOVFF  30F,31B
5BE4:  MOVFF  30E,31A
5BE8:  MOVLW  03
5BEA:  MOVWF  x1D
5BEC:  MOVLW  15
5BEE:  MOVWF  x1C
5BF0:  MOVLW  01
5BF2:  MOVWF  x1E
5BF4:  MOVLB  0
5BF6:  RCALL  5996
....................  
....................    TCPPutFileChunkStop(); 
....................  
....................    return(ec); 
5BF8:  MOVLB  3
5BFA:  MOVFF  319,01
.................... } 
5BFE:  MOVLB  0
5C00:  GOTO   60E4 (RETURN)
....................  
.................... int TCPPutFileConstGetEscape(int32 addy) 
.................... { 
.................... #if HTTP_USE_DOUBLE_ESCAPE 
....................    char str[3]; 
....................    int ret; 
....................  
....................    read_program_memory(addy, &str[0], 2); 
....................    str[2] = 0; 
....................    ret = strtol(str, 0, 16); 
.................... #else 
....................    char ret; 
....................    read_program_memory(addy, &ret, 1); 
5C04:  MOVFF  312,FF8
5C08:  MOVFF  311,FF7
5C0C:  MOVFF  310,FF6
5C10:  MOVLW  03
5C12:  MOVWF  FEA
5C14:  MOVLW  14
5C16:  MOVWF  FE9
5C18:  MOVLB  3
5C1A:  CLRF   x2F
5C1C:  MOVLW  01
5C1E:  MOVWF  x2E
5C20:  MOVLB  0
5C22:  RCALL  5978
.................... #endif 
....................  
....................    return(ret); 
5C24:  MOVLB  3
5C26:  MOVFF  314,01
.................... } 
5C2A:  MOVLB  0
5C2C:  GOTO   6128 (RETURN)
....................  
.................... int1 tcp_http_put_file(int8 which, int16 errorCode, int32 file, char *contentType) 
.................... { 
....................    static char str[40]; 
....................    int8 socket; 
....................    char ec; 
....................    int escaped; 
....................  
....................    static enum 
....................    { 
....................       HTTP_PUT_FILE_INIT = 0, 
....................       HTTP_PUT_FILE_CONTINUE, 
....................       HTTP_PUT_FILE_CHUNK_END, 
....................       HTTP_PUT_FILE_DONE 
....................    } status; 
....................  
....................    socket=http_socket[which]; 
*
5EF2:  CLRF   03
5EF4:  MOVLB  3
5EF6:  MOVF   x00,W
5EF8:  ADDLW  1E
5EFA:  MOVWF  FE9
5EFC:  MOVLW  01
5EFE:  ADDWFC 03,W
5F00:  MOVWF  FEA
5F02:  MOVFF  FEF,309
....................  
....................    set_tcp_http_putc(socket); 
5F06:  MOVFF  309,30C
5F0A:  MOVLB  0
5F0C:  GOTO   5362
....................  
....................    if (lastHTTPPutConstPos[which] == 0) 
5F10:  MOVLB  3
5F12:  MOVF   x00,W
5F14:  MULLW  04
5F16:  MOVF   FF3,W
5F18:  CLRF   03
5F1A:  ADDLW  22
5F1C:  MOVWF  FE9
5F1E:  MOVLW  01
5F20:  ADDWFC 03,W
5F22:  MOVWF  FEA
5F24:  MOVFF  FEF,30C
5F28:  MOVFF  FEC,30D
5F2C:  MOVFF  FEC,30E
5F30:  MOVFF  FEC,30F
5F34:  MOVF   x0C,F
5F36:  BTFSS  FD8.2
5F38:  BRA    6072
5F3A:  MOVF   x0D,F
5F3C:  BTFSS  FD8.2
5F3E:  BRA    6072
5F40:  MOVF   x0E,F
5F42:  BTFSS  FD8.2
5F44:  BRA    6072
5F46:  MOVF   x0F,F
5F48:  BTFSS  FD8.2
5F4A:  BRA    6072
....................    { 
....................       lastHTTPPutVarPos[which] = 0; 
5F4C:  BCF    FD8.0
5F4E:  RLCF   x00,W
5F50:  CLRF   03
5F52:  ADDLW  26
5F54:  MOVWF  FE9
5F56:  MOVLW  01
5F58:  ADDWFC 03,W
5F5A:  MOVWF  FEA
5F5C:  CLRF   FEC
5F5E:  MOVF   FED,F
5F60:  CLRF   FEF
....................       lastHTTPPutConstPos[which] = file; 
5F62:  MOVF   x00,W
5F64:  MULLW  04
5F66:  MOVF   FF3,W
5F68:  CLRF   03
5F6A:  ADDLW  22
5F6C:  MOVWF  FE9
5F6E:  MOVLW  01
5F70:  ADDWFC 03,W
5F72:  MOVWF  FEA
5F74:  MOVFF  303,FEF
5F78:  MOVFF  304,FEC
5F7C:  MOVFF  305,FEC
5F80:  MOVFF  306,FEC
....................       status = HTTP_PUT_FILE_CONTINUE; 
5F84:  MOVLW  01
5F86:  MOVLB  1
5F88:  MOVWF  x50
....................  
....................     #if HTTP_USE_CHUNKS 
....................       printf(tcp_http_putc,"HTTP/1.1 %LU ", errorCode); 
....................     #else 
....................       printf(tcp_http_putc,"HTTP/1.0 %LU ", errorCode); 
5F8A:  MOVLW  62
5F8C:  MOVWF  FF6
5F8E:  MOVLW  01
5F90:  MOVWF  FF7
5F92:  MOVLW  09
5F94:  MOVLB  3
5F96:  MOVWF  x0C
5F98:  MOVLB  0
5F9A:  GOTO   568C
5F9E:  MOVLW  10
5FA0:  MOVWF  FE9
5FA2:  MOVFF  302,30D
5FA6:  MOVFF  301,30C
5FAA:  GOTO   56B6
5FAE:  MOVLW  20
5FB0:  MOVLB  3
5FB2:  MOVWF  x2A
5FB4:  MOVLB  0
5FB6:  CALL   567E
....................     #endif 
....................  
....................       switch(errorCode) 
....................       { 
5FBA:  MOVLB  3
5FBC:  MOVF   x01,W
5FBE:  MOVWF  00
5FC0:  MOVF   x02,W
5FC2:  MOVWF  03
5FC4:  MOVF   03,W
5FC6:  BNZ   5FD2
5FC8:  MOVLW  C8
5FCA:  SUBWF  00,W
5FCC:  MOVLB  0
5FCE:  BZ    5FF4
5FD0:  MOVLB  3
5FD2:  MOVLW  01
5FD4:  SUBWF  03,W
5FD6:  BNZ   5FE2
5FD8:  MOVLW  94
5FDA:  SUBWF  00,W
5FDC:  MOVLB  0
5FDE:  BZ    600E
5FE0:  MOVLB  3
5FE2:  MOVLW  01
5FE4:  SUBWF  03,W
5FE6:  BNZ   5FF2
5FE8:  MOVLW  F4
5FEA:  SUBWF  00,W
5FEC:  MOVLB  0
5FEE:  BZ    601C
5FF0:  MOVLB  3
5FF2:  BRA    602A
....................          case 200: 
....................             printf(tcp_http_putc,"OK"); 
5FF4:  MOVLW  4F
5FF6:  MOVLB  3
5FF8:  MOVWF  x2A
5FFA:  MOVLB  0
5FFC:  CALL   567E
6000:  MOVLW  4B
6002:  MOVLB  3
6004:  MOVWF  x2A
6006:  MOVLB  0
6008:  CALL   567E
....................             break; 
600C:  BRA    602E
....................          case 404: 
....................             printf(tcp_http_putc,"Not found"); 
600E:  MOVLW  70
6010:  MOVWF  FF6
6012:  MOVLW  01
6014:  MOVWF  FF7
6016:  CALL   5774
....................             break; 
601A:  BRA    602E
....................          case 500: 
....................             printf(tcp_http_putc,"Server Error"); 
601C:  MOVLW  7A
601E:  MOVWF  FF6
6020:  MOVLW  01
6022:  MOVWF  FF7
6024:  CALL   5774
....................             break; 
6028:  BRA    602E
....................          default: 
....................             break; 
602A:  MOVLB  0
602C:  BRA    602E
....................       } 
....................  
....................       printf(tcp_http_putc, "\r\nContent-Type: "); 
602E:  MOVLW  88
6030:  MOVWF  FF6
6032:  MOVLW  01
6034:  MOVWF  FF7
6036:  CALL   5774
....................       if (contentType) 
603A:  MOVLB  3
603C:  MOVF   x07,W
603E:  IORWF  x08,W
6040:  BZ    6056
....................          printf(tcp_http_putc, "%s", contentType); 
6042:  MOVFF  308,FEA
6046:  MOVFF  307,FE9
604A:  MOVLB  0
604C:  GOTO   5794
....................       else 
6050:  MOVLB  0
6052:  BRA    6064
6054:  MOVLB  3
....................          printf(tcp_http_putc,"text/html"); 
6056:  MOVLW  9A
6058:  MOVWF  FF6
605A:  MOVLW  01
605C:  MOVWF  FF7
605E:  MOVLB  0
6060:  CALL   5774
....................  
....................     #if HTTP_USE_CHUNKS 
....................       printf(tcp_http_putc, "\r\nConnection: close"); 
....................       printf(tcp_http_putc, "\r\nTransfer-Encoding: chunked"); 
....................     #endif 
....................  
....................       printf(tcp_http_putc, "\r\n\r\n"); 
6064:  MOVLW  A4
6066:  MOVWF  FF6
6068:  MOVLW  01
606A:  MOVWF  FF7
606C:  CALL   5774
6070:  MOVLB  3
....................    } 
....................  
....................    if (lastHTTPPutVarPos[which]) 
6072:  BCF    FD8.0
6074:  RLCF   x00,W
6076:  CLRF   03
6078:  ADDLW  26
607A:  MOVWF  FE9
607C:  MOVLW  01
607E:  ADDWFC 03,W
6080:  MOVWF  FEA
6082:  MOVF   FEF,F
6084:  BZ    60B8
....................    { 
....................       TCPPutFileVarChunk(&lastHTTPPutVarPos[which]); 
6086:  BCF    FD8.0
6088:  RLCF   x00,W
608A:  CLRF   03
608C:  ADDLW  26
608E:  MOVWF  x0C
6090:  MOVLW  01
6092:  ADDWFC 03,W
6094:  MOVWF  x0D
6096:  MOVWF  x0F
6098:  MOVFF  30C,30E
609C:  MOVLB  0
609E:  RCALL  58B6
....................       lastHTTPPutVarPos[which] = 0; 
60A0:  BCF    FD8.0
60A2:  MOVLB  3
60A4:  RLCF   x00,W
60A6:  CLRF   03
60A8:  ADDLW  26
60AA:  MOVWF  FE9
60AC:  MOVLW  01
60AE:  ADDWFC 03,W
60B0:  MOVWF  FEA
60B2:  CLRF   FEC
60B4:  MOVF   FED,F
60B6:  CLRF   FEF
....................    } 
....................  
....................    if (status == HTTP_PUT_FILE_CONTINUE) 
60B8:  MOVLB  1
60BA:  DECFSZ x50,W
60BC:  BRA    61FE
....................    { 
....................       do { 
....................          ec = TCPPutFileConstChunk(&lastHTTPPutConstPos[which]); 
60BE:  MOVLB  3
60C0:  MOVF   x00,W
60C2:  MULLW  04
60C4:  MOVF   FF3,W
60C6:  CLRF   03
60C8:  ADDLW  22
60CA:  MOVWF  01
60CC:  MOVLW  01
60CE:  ADDWFC 03,F
60D0:  MOVFF  01,30C
60D4:  MOVFF  03,30D
60D8:  MOVFF  03,30F
60DC:  MOVFF  01,30E
60E0:  MOVLB  0
60E2:  BRA    5B2C
60E4:  MOVFF  01,30A
....................  
....................          if (ec == TCP_PUT_CONST_EC_ESCAPE) 
60E8:  MOVLB  3
60EA:  MOVF   x0A,W
60EC:  SUBLW  02
60EE:  BTFSS  FD8.2
60F0:  BRA    61EC
....................          { 
....................             escaped = TCPPutFileConstGetEscape(lastHTTPPutConstPos[which]); 
60F2:  MOVF   x00,W
60F4:  MULLW  04
60F6:  MOVF   FF3,W
60F8:  CLRF   03
60FA:  ADDLW  22
60FC:  MOVWF  FE9
60FE:  MOVLW  01
6100:  ADDWFC 03,W
6102:  MOVWF  FEA
6104:  MOVFF  FEF,30C
6108:  MOVFF  FEC,30D
610C:  MOVFF  FEC,30E
6110:  MOVFF  FEC,30F
6114:  MOVFF  30F,313
6118:  MOVFF  30E,312
611C:  MOVFF  30D,311
6120:  MOVFF  30C,310
6124:  MOVLB  0
6126:  BRA    5C04
6128:  MOVFF  01,30B
....................            #if HTTP_USE_DOUBLE_ESCAPE 
....................             lastHTTPPutConstPos[which] += 2; 
....................            #else 
....................             lastHTTPPutConstPos[which] += 1; 
612C:  MOVLB  3
612E:  MOVF   x00,W
6130:  MULLW  04
6132:  MOVF   FF3,W
6134:  CLRF   03
6136:  ADDLW  22
6138:  MOVWF  FE9
613A:  MOVLW  01
613C:  ADDWFC 03,W
613E:  MOVWF  FEA
6140:  MOVLW  01
6142:  ADDWF  FEF,W
6144:  MOVWF  00
6146:  MOVLW  00
6148:  ADDWFC FEC,W
614A:  MOVWF  01
614C:  MOVLW  00
614E:  ADDWFC FEC,W
6150:  MOVWF  02
6152:  MOVLW  00
6154:  ADDWFC FEC,W
6156:  MOVF   FED,F
6158:  MOVF   FED,F
615A:  MOVF   FED,F
615C:  MOVFF  00,FEF
6160:  MOVFF  01,FEC
6164:  MOVFF  02,FEC
6168:  MOVWF  FEC
....................            #endif 
....................             http_format_char(file, escaped, &str[0], sizeof(str)-1); 
616A:  MOVFF  306,30F
616E:  MOVFF  305,30E
6172:  MOVFF  304,30D
6176:  MOVFF  303,30C
617A:  MOVFF  30B,310
617E:  MOVLW  01
6180:  MOVWF  x12
6182:  MOVLW  28
6184:  MOVWF  x11
6186:  MOVLW  27
6188:  MOVWF  x13
618A:  MOVLB  0
618C:  BRA    5DFE
....................             lastHTTPPutVarPos[which] = &str[0]; 
618E:  BCF    FD8.0
6190:  MOVLB  3
6192:  RLCF   x00,W
6194:  CLRF   03
6196:  ADDLW  26
6198:  MOVWF  FE9
619A:  MOVLW  01
619C:  ADDWFC 03,W
619E:  MOVWF  FEA
61A0:  MOVLW  01
61A2:  MOVWF  FEC
61A4:  MOVF   FED,F
61A6:  MOVLW  28
61A8:  MOVWF  FEF
....................             ec = TCPPutFileVarChunk(&lastHTTPPutVarPos[which]); 
61AA:  BCF    FD8.0
61AC:  RLCF   x00,W
61AE:  CLRF   03
61B0:  ADDLW  26
61B2:  MOVWF  x0C
61B4:  MOVLW  01
61B6:  ADDWFC 03,W
61B8:  MOVWF  x0D
61BA:  MOVWF  x0F
61BC:  MOVFF  30C,30E
61C0:  MOVLB  0
61C2:  CALL   58B6
61C6:  MOVFF  01,30A
....................             if (ec == TCP_PUT_CONST_EC_FINISH) 
61CA:  MOVLB  3
61CC:  MOVF   x0A,F
61CE:  BNZ   61E8
....................                lastHTTPPutVarPos[which] = 0; 
61D0:  BCF    FD8.0
61D2:  RLCF   x00,W
61D4:  CLRF   03
61D6:  ADDLW  26
61D8:  MOVWF  FE9
61DA:  MOVLW  01
61DC:  ADDWFC 03,W
61DE:  MOVWF  FEA
61E0:  CLRF   FEC
61E2:  MOVF   FED,F
61E4:  CLRF   FEF
....................             else 
61E6:  BRA    61EA
....................                break; 
61E8:  BRA    61FC
....................          } 
....................          else 
61EA:  BRA    61FA
....................          { 
....................             if (ec == TCP_PUT_CONST_EC_FINISH) 
61EC:  MOVF   x0A,F
61EE:  BNZ   61F8
....................                status = HTTP_PUT_FILE_CHUNK_END; 
61F0:  MOVLW  02
61F2:  MOVLB  1
61F4:  MOVWF  x50
61F6:  MOVLB  3
....................             break; 
61F8:  BRA    61FC
....................          } 
....................       } while (TRUE); 
....................    } 
61FA:  BRA    60C0
61FC:  MOVLB  1
....................  
....................    if (status == HTTP_PUT_FILE_CHUNK_END) 
61FE:  MOVF   x50,W
6200:  SUBLW  02
6202:  BNZ   6208
....................    { 
....................      #if HTTP_USE_CHUNKS 
....................       if (tcp_http_tx_left() > 8) 
....................       { 
....................          TCPPutFileChunkStart(0); 
....................          TCPPutFileChunkStop(); 
....................          status = HTTP_PUT_FILE_DONE; 
....................       } 
....................      #else 
....................       status = HTTP_PUT_FILE_DONE; 
6204:  MOVLW  03
6206:  MOVWF  x50
....................      #endif 
....................    } 
....................  
....................  
....................    TCPFlush(socket); 
6208:  MOVFF  309,331
620C:  MOVLB  0
620E:  CALL   536A
....................  
....................    return(status == HTTP_PUT_FILE_DONE); 
6212:  MOVLB  1
6214:  MOVF   x50,W
6216:  SUBLW  03
6218:  BZ    621E
621A:  MOVLW  00
621C:  BRA    6220
621E:  MOVLW  01
6220:  MOVWF  01
.................... } 
6222:  MOVLB  0
6224:  RETLW  00
....................  
.................... //initializes the HTTP state machine.  called automatically by the TCP/IP stack 
.................... void HTTP_Init(void) { 
....................    int8 i; 
....................    debug_http("\r\nHTTP OPENING"); 
....................    if (HTTP_PORT != 0) 
....................    { 
....................       for (i=0;i<HTTP_NUM_SOCKETS;i++) 
*
10FE:  MOVLB  2
1100:  CLRF   xEE
1102:  MOVF   xEE,F
1104:  BNZ   1162
....................       { 
....................          http_socket[i]=TCPListen(HTTP_PORT); 
1106:  CLRF   03
1108:  MOVF   xEE,W
110A:  ADDLW  1E
110C:  MOVWF  01
110E:  MOVLW  01
1110:  ADDWFC 03,F
1112:  MOVFF  01,2EF
1116:  MOVFF  03,2F0
111A:  CLRF   xF2
111C:  MOVLW  50
111E:  MOVWF  xF1
1120:  MOVLB  0
1122:  BRA    1002
1124:  MOVFF  2F0,FEA
1128:  MOVFF  2EF,FE9
112C:  MOVFF  01,FEF
....................          debug_http("\r\nHTTP SOCKET=%X", http_socket[i]); 
....................          if (http_socket[i]!=INVALID_SOCKET) 
1130:  CLRF   03
1132:  MOVLB  2
1134:  MOVF   xEE,W
1136:  ADDLW  1E
1138:  MOVWF  FE9
113A:  MOVLW  01
113C:  ADDWFC 03,W
113E:  MOVWF  FEA
1140:  MOVF   FEF,W
1142:  SUBLW  FE
1144:  BZ    115E
....................          { 
....................             http_state[i]=HTTP_LISTEN_WAIT; 
1146:  BCF    FD8.0
1148:  RLCF   xEE,W
114A:  CLRF   03
114C:  ADDLW  1F
114E:  MOVWF  FE9
1150:  MOVLW  01
1152:  ADDWFC 03,W
1154:  MOVWF  FEA
1156:  MOVLW  01
1158:  MOVWF  FEC
115A:  MOVF   FED,F
115C:  MOVWF  FEF
....................          } 
....................       } 
115E:  INCF   xEE,F
1160:  BRA    1102
....................    } 
....................    else 
....................    { 
....................       debug_http("\r\nHTTP DISABLED"); 
....................       for (i=0;i<HTTP_NUM_SOCKETS;i++) 
....................       { 
....................             http_state[i]=HTTP_DISABLED; 
....................       } 
....................    } 
.................... } 
1162:  MOVLB  0
1164:  GOTO   117A (RETURN)
....................  
.................... void HTTP_Task(void) { 
....................    static char tokens_header[]=" "; 
....................    static char tokens_get[]="?"; 
....................    static char http_get_str[]="GET"; 
....................    static char http_post_str[]="POST"; 
....................    static char http_len_str[]="Content-Length:"; 
....................    //static char http_keepalive_str[]="keep-alive"; 
....................    //static char http_connection_str[]="Connection"; 
....................  
....................    static char buffer[HTTP_NUM_SOCKETS][HTTP_GET_PARAM_MAX_SIZE]; 
....................  
....................    static int8 i[HTTP_NUM_SOCKETS]; 
....................    static enum {HTTP_REQ_GET=1, HTTP_REQ_POST=2, HTTP_REQ_UNKOWN=0} http_cmd[HTTP_NUM_SOCKETS]={0}; 
....................    static int32 http_page_req[HTTP_NUM_SOCKETS]; 
....................    static int16 http_post_len[HTTP_NUM_SOCKETS]={0}; 
....................    static int16 http_timer[HTTP_NUM_SOCKETS]; 
....................  #if HTTP_USE_CONTENT_TYPE 
....................    static char contentType[HTTP_NUM_SOCKETS][12]; 
....................  #endif 
....................  
....................    int1 doneSend, postContinue; 
....................  
....................    char c, *pKey, *pValue; 
....................    int8 hs, currSocket; 
....................  
....................    for (hs=0; hs<HTTP_NUM_SOCKETS; hs++) 
*
636A:  MOVLB  2
636C:  CLRF   xFA
636E:  MOVF   xFA,F
6370:  BTFSS  FD8.2
6372:  GOTO   6FCC
....................    { 
....................       if (http_state[hs]==HTTP_DISABLED) 
6376:  BCF    FD8.0
6378:  RLCF   xFA,W
637A:  CLRF   03
637C:  ADDLW  1F
637E:  MOVWF  FE9
6380:  MOVLW  01
6382:  ADDWFC 03,W
6384:  MOVWF  FEA
6386:  MOVFF  FEC,2FD
638A:  MOVF   FED,F
638C:  MOVFF  FEF,2FC
6390:  INCFSZ xFC,W
6392:  BRA    639C
6394:  MOVF   xFD,F
6396:  BNZ   639C
....................          return; 
6398:  GOTO   6FCC
....................  
....................       currSocket=http_socket[hs]; 
639C:  CLRF   03
639E:  MOVF   xFA,W
63A0:  ADDLW  1E
63A2:  MOVWF  FE9
63A4:  MOVLW  01
63A6:  ADDWFC 03,W
63A8:  MOVWF  FEA
63AA:  MOVFF  FEF,2FB
....................  
....................       if (!TCPIsConnected(currSocket)) 
63AE:  MOVFF  2FB,2FC
63B2:  MOVLB  0
63B4:  CALL   40C0
63B8:  MOVF   01,F
63BA:  BNZ   63D8
....................          http_state[hs]=HTTP_LISTEN_WAIT; 
63BC:  BCF    FD8.0
63BE:  MOVLB  2
63C0:  RLCF   xFA,W
63C2:  CLRF   03
63C4:  ADDLW  1F
63C6:  MOVWF  FE9
63C8:  MOVLW  01
63CA:  ADDWFC 03,W
63CC:  MOVWF  FEA
63CE:  MOVLW  01
63D0:  MOVWF  FEC
63D2:  MOVF   FED,F
63D4:  MOVWF  FEF
63D6:  MOVLB  0
....................  
....................       switch(http_state[hs]) 
....................       { 
63D8:  BCF    FD8.0
63DA:  MOVLB  2
63DC:  RLCF   xFA,W
63DE:  CLRF   03
63E0:  ADDLW  1F
63E2:  MOVWF  FE9
63E4:  MOVLW  01
63E6:  ADDWFC 03,W
63E8:  MOVWF  FEA
63EA:  MOVF   FEF,W
63EC:  MOVWF  00
63EE:  INCF   FE9,F
63F0:  MOVF   FEF,W
63F2:  DECF   FE9,F
63F4:  MOVWF  03
63F6:  MOVLW  01
63F8:  SUBWF  03,W
63FA:  BNZ   6406
63FC:  MOVLW  01
63FE:  SUBWF  00,W
6400:  MOVLB  0
6402:  BZ    64B4
6404:  MOVLB  2
6406:  MOVLW  01
6408:  SUBWF  03,W
640A:  BNZ   6416
640C:  MOVLW  02
640E:  SUBWF  00,W
6410:  MOVLB  0
6412:  BZ    64C4
6414:  MOVLB  2
6416:  MOVLW  01
6418:  SUBWF  03,W
641A:  BNZ   6428
641C:  MOVLW  03
641E:  SUBWF  00,W
6420:  MOVLB  0
6422:  BTFSC  FD8.2
6424:  BRA    6574
6426:  MOVLB  2
6428:  MOVLW  01
642A:  SUBWF  03,W
642C:  BNZ   643A
642E:  MOVLW  04
6430:  SUBWF  00,W
6432:  MOVLB  0
6434:  BTFSC  FD8.2
6436:  BRA    69D0
6438:  MOVLB  2
643A:  MOVLW  01
643C:  SUBWF  03,W
643E:  BNZ   644C
6440:  MOVLW  05
6442:  SUBWF  00,W
6444:  MOVLB  0
6446:  BTFSC  FD8.2
6448:  BRA    6A2E
644A:  MOVLB  2
644C:  MOVLW  01
644E:  SUBWF  03,W
6450:  BNZ   6460
6452:  MOVLW  06
6454:  SUBWF  00,W
6456:  MOVLB  0
6458:  BTFSC  FD8.2
645A:  GOTO   6CE8
645E:  MOVLB  2
6460:  MOVLW  01
6462:  SUBWF  03,W
6464:  BNZ   6474
6466:  MOVLW  07
6468:  SUBWF  00,W
646A:  MOVLB  0
646C:  BTFSC  FD8.2
646E:  GOTO   6D2A
6472:  MOVLB  2
6474:  MOVLW  01
6476:  SUBWF  03,W
6478:  BNZ   6488
647A:  MOVLW  08
647C:  SUBWF  00,W
647E:  MOVLB  0
6480:  BTFSC  FD8.2
6482:  GOTO   6E7C
6486:  MOVLB  2
6488:  MOVLW  01
648A:  SUBWF  03,W
648C:  BNZ   649C
648E:  MOVLW  09
6490:  SUBWF  00,W
6492:  MOVLB  0
6494:  BTFSC  FD8.2
6496:  GOTO   6EC6
649A:  MOVLB  2
649C:  MOVLW  01
649E:  SUBWF  03,W
64A0:  BNZ   64B0
64A2:  MOVLW  0A
64A4:  SUBWF  00,W
64A6:  MOVLB  0
64A8:  BTFSC  FD8.2
64AA:  GOTO   6FC0
64AE:  MOVLB  2
64B0:  GOTO   6FC0
....................          case HTTP_LISTEN_WAIT: 
....................             if (!TCPIsConnected(currSocket)) 
64B4:  MOVFF  2FB,2FC
64B8:  CALL   40C0
64BC:  MOVF   01,F
64BE:  BNZ   64C4
....................                break; 
64C0:  GOTO   6FC4
....................             debug_http("HTTP %U CONNECTED\r\n", hs); 
....................  
....................          //wait until we get '\r\n\r\n', which marks the end of the HTTP request header 
....................          case HTTP_CONNECTED: 
....................             debug_http("HTTP %U LISTENING\r\n", hs); 
....................             buffer[hs][0]=0; 
64C4:  MOVLB  2
64C6:  MOVF   xFA,W
64C8:  MULLW  FE
64CA:  MOVF   FF3,W
64CC:  CLRF   xFD
64CE:  MOVWF  xFC
64D0:  MOVLW  6E
64D2:  ADDWF  xFC,W
64D4:  MOVWF  FE9
64D6:  MOVLW  01
64D8:  ADDWFC xFD,W
64DA:  MOVWF  FEA
64DC:  CLRF   FEF
....................             i[hs]=0; 
64DE:  CLRF   03
64E0:  MOVF   xFA,W
64E2:  ADDLW  6C
64E4:  MOVWF  FE9
64E6:  MOVLW  02
64E8:  ADDWFC 03,W
64EA:  MOVWF  FEA
64EC:  CLRF   FEF
....................             http_state[hs]=HTTP_GET_HEADERS; 
64EE:  BCF    FD8.0
64F0:  RLCF   xFA,W
64F2:  CLRF   03
64F4:  ADDLW  1F
64F6:  MOVWF  FE9
64F8:  MOVLW  01
64FA:  ADDWFC 03,W
64FC:  MOVWF  FEA
64FE:  MOVLW  01
6500:  MOVWF  FEC
6502:  MOVF   FED,F
6504:  MOVLW  03
6506:  MOVWF  FEF
....................             http_timer[hs]=TickGet(); 
6508:  BCF    FD8.0
650A:  RLCF   xFA,W
650C:  CLRF   03
650E:  ADDLW  74
6510:  MOVWF  01
6512:  MOVLW  02
6514:  ADDWFC 03,F
6516:  MOVFF  01,2FC
651A:  MOVFF  03,2FD
651E:  MOVLB  0
6520:  CALL   2600
6524:  MOVFF  2FD,FEA
6528:  MOVFF  2FC,FE9
652C:  MOVFF  02,FEC
6530:  MOVF   FED,F
6532:  MOVFF  01,FEF
....................             http_page_req[hs]=0; 
6536:  MOVLB  2
6538:  MOVF   xFA,W
653A:  MULLW  04
653C:  MOVF   FF3,W
653E:  CLRF   03
6540:  ADDLW  6E
6542:  MOVWF  FE9
6544:  MOVLW  02
6546:  ADDWFC 03,W
6548:  MOVWF  FEA
654A:  MOVF   FEE,F
654C:  MOVF   FEE,F
654E:  CLRF   FEC
6550:  MOVF   FED,F
6552:  CLRF   FEF
6554:  MOVF   FED,F
6556:  CLRF   FEF
6558:  MOVF   FED,F
655A:  CLRF   FEF
....................             http_post_len[hs]=0; 
655C:  BCF    FD8.0
655E:  RLCF   xFA,W
6560:  CLRF   03
6562:  ADDLW  72
6564:  MOVWF  FE9
6566:  MOVLW  02
6568:  ADDWFC 03,W
656A:  MOVWF  FEA
656C:  CLRF   FEC
656E:  MOVF   FED,F
6570:  CLRF   FEF
6572:  MOVLB  0
....................             //http_got_headers[hs]=FALSE; 
....................             //http_isKeepAlive[hs]=FALSE; 
....................  
....................          case HTTP_GET_HEADERS: 
....................             postContinue=FALSE; 
6574:  MOVLB  2
6576:  BCF    xF4.1
....................             while (TCPIsGetReady(currSocket) && TCPGet(currSocket, &c)) 
....................             { 
6578:  MOVFF  2FB,2FC
657C:  MOVLB  0
657E:  CALL   40EA
6582:  MOVF   01,F
6584:  BTFSC  FD8.2
6586:  BRA    68D4
6588:  MOVFF  2FB,2FC
658C:  MOVLW  02
658E:  MOVLB  2
6590:  MOVWF  xFE
6592:  MOVLW  F5
6594:  MOVWF  xFD
6596:  MOVLB  0
6598:  CALL   4116
659C:  MOVF   01,F
659E:  BTFSC  FD8.2
65A0:  BRA    68D4
....................                //http_got_headers[hs]=TRUE; 
....................                if ( (c >= 0x20) && (i[hs] < HTTP_GET_PARAM_MAX_SIZE - 2) ) 
65A2:  MOVLB  2
65A4:  MOVF   xF5,W
65A6:  SUBLW  1F
65A8:  BC    65F4
65AA:  CLRF   03
65AC:  MOVF   xFA,W
65AE:  ADDLW  6C
65B0:  MOVWF  FE9
65B2:  MOVLW  02
65B4:  ADDWFC 03,W
65B6:  MOVWF  FEA
65B8:  MOVF   FEF,W
65BA:  SUBLW  FB
65BC:  BNC   65F4
....................                { 
....................                   buffer[hs][i[hs]++]=c; 
65BE:  MOVF   xFA,W
65C0:  MULLW  FE
65C2:  MOVF   FF3,W
65C4:  CLRF   xFD
65C6:  MOVWF  xFC
65C8:  CLRF   03
65CA:  MOVF   xFA,W
65CC:  ADDLW  6C
65CE:  MOVWF  FE9
65D0:  MOVLW  02
65D2:  ADDWFC 03,W
65D4:  MOVWF  FEA
65D6:  MOVF   FEF,W
65D8:  INCF   FEF,F
65DA:  CLRF   03
65DC:  ADDWF  xFC,W
65DE:  MOVWF  01
65E0:  MOVF   xFD,W
65E2:  ADDWFC 03,F
65E4:  MOVF   01,W
65E6:  ADDLW  6E
65E8:  MOVWF  FE9
65EA:  MOVLW  01
65EC:  ADDWFC 03,W
65EE:  MOVWF  FEA
65F0:  MOVFF  2F5,FEF
....................                } 
....................                if (c=='\n') 
65F4:  MOVF   xF5,W
65F6:  SUBLW  0A
65F8:  BTFSS  FD8.2
65FA:  BRA    68D0
....................                { 
....................                   buffer[hs][i[hs]]=0; 
65FC:  MOVF   xFA,W
65FE:  MULLW  FE
6600:  MOVF   FF3,W
6602:  CLRF   xFD
6604:  MOVWF  xFC
6606:  CLRF   03
6608:  MOVF   xFA,W
660A:  ADDLW  6C
660C:  MOVWF  FE9
660E:  MOVLW  02
6610:  ADDWFC 03,W
6612:  MOVWF  FEA
6614:  CLRF   03
6616:  MOVF   FEF,W
6618:  ADDWF  xFC,W
661A:  MOVWF  01
661C:  MOVF   xFD,W
661E:  ADDWFC 03,F
6620:  MOVF   01,W
6622:  ADDLW  6E
6624:  MOVWF  FE9
6626:  MOVLW  01
6628:  ADDWFC 03,W
662A:  MOVWF  FEA
662C:  CLRF   FEF
....................                   if ( 
....................                        ( ( pKey = strtok(&buffer[hs][0], tokens_header) ) !=0 ) && 
....................                        ( ( pValue = strtok(0, tokens_header) ) !=0 ) 
....................                      ) 
662E:  MOVF   xFA,W
6630:  MULLW  FE
6632:  MOVF   FF3,W
6634:  CLRF   xFD
6636:  MOVWF  xFC
6638:  MOVLW  6E
663A:  ADDWF  xFC,F
663C:  MOVLW  01
663E:  ADDWFC xFD,F
6640:  MOVFF  2FD,2FF
6644:  MOVFF  2FC,2FE
6648:  MOVLB  3
664A:  MOVWF  x01
664C:  MOVLW  51
664E:  MOVWF  x00
6650:  MOVLB  0
6652:  CALL   4306
6656:  MOVFF  02,2F7
665A:  MOVFF  01,2F6
665E:  MOVLB  2
6660:  MOVF   xF6,F
6662:  BNZ   666A
6664:  MOVF   xF7,F
6666:  BTFSC  FD8.2
6668:  BRA    6852
666A:  CLRF   xFF
666C:  CLRF   xFE
666E:  MOVLW  01
6670:  MOVLB  3
6672:  MOVWF  x01
6674:  MOVLW  51
6676:  MOVWF  x00
6678:  MOVLB  0
667A:  CALL   4306
667E:  MOVFF  02,2F9
6682:  MOVFF  01,2F8
6686:  MOVLB  2
6688:  MOVF   xF8,F
668A:  BNZ   6692
668C:  MOVF   xF9,F
668E:  BTFSC  FD8.2
6690:  BRA    6852
....................                   { 
....................                      debug_http("HTTP %U PAIR %s = %s\r\n", hs, pKey, pValue); 
....................                      if ( (strcmp(pKey, http_get_str)==0) || (strcmp(pKey, http_post_str)==0) ) 
6692:  MOVFF  2F7,2FD
6696:  MOVFF  2F6,2FC
669A:  MOVLW  01
669C:  MOVWF  xFF
669E:  MOVLW  55
66A0:  MOVWF  xFE
66A2:  MOVLB  0
66A4:  CALL   43B8
66A8:  MOVF   01,F
66AA:  BZ    66CA
66AC:  MOVFF  2F7,2FD
66B0:  MOVFF  2F6,2FC
66B4:  MOVLW  01
66B6:  MOVLB  2
66B8:  MOVWF  xFF
66BA:  MOVLW  59
66BC:  MOVWF  xFE
66BE:  MOVLB  0
66C0:  CALL   43B8
66C4:  MOVF   01,F
66C6:  BTFSS  FD8.2
66C8:  BRA    67E8
....................                      { 
....................                         pValue=strtok(pValue, tokens_get);  //chop the file after a ? 
66CA:  MOVFF  2F9,2FF
66CE:  MOVFF  2F8,2FE
66D2:  MOVLW  01
66D4:  MOVLB  3
66D6:  MOVWF  x01
66D8:  MOVLW  53
66DA:  MOVWF  x00
66DC:  MOVLB  0
66DE:  CALL   4306
66E2:  MOVFF  02,2F9
66E6:  MOVFF  01,2F8
....................                         http_escape_chars(pValue); 
66EA:  MOVFF  2F9,30E
66EE:  MOVFF  2F8,30D
66F2:  CALL   4942
....................                        #if HTTP_USE_CONTENT_TYPE 
....................                         http_get_page(pValue, &http_page_req[hs], &contentType[hs][0]); 
....................                        #else 
....................                         http_page_req[hs] = http_get_page(pValue); 
66F6:  MOVLB  2
66F8:  MOVF   xFA,W
66FA:  MULLW  04
66FC:  MOVF   FF3,W
66FE:  CLRF   03
6700:  ADDLW  6E
6702:  MOVWF  01
6704:  MOVLW  02
6706:  ADDWFC 03,F
6708:  MOVFF  01,2FC
670C:  MOVFF  03,2FD
6710:  MOVFF  2F9,2FF
6714:  MOVFF  2F8,2FE
6718:  MOVLB  0
671A:  GOTO   4CA2
671E:  MOVFF  2FD,FEA
6722:  MOVFF  2FC,FE9
6726:  MOVFF  00,FEF
672A:  MOVFF  01,FEC
672E:  MOVFF  02,FEC
6732:  MOVFF  03,FEC
....................                        #endif 
....................                         debug_http("HTTP %U FILE %s = %lx\r\n", hs, pValue, http_page_req[hs]); 
....................                         pValue=strtok(0, tokens_get); 
6736:  MOVLB  2
6738:  CLRF   xFF
673A:  CLRF   xFE
673C:  MOVLW  01
673E:  MOVLB  3
6740:  MOVWF  x01
6742:  MOVLW  53
6744:  MOVWF  x00
6746:  MOVLB  0
6748:  CALL   4306
674C:  MOVFF  02,2F9
6750:  MOVFF  01,2F8
....................                         if (pValue) 
6754:  MOVLB  2
6756:  MOVF   xF8,W
6758:  IORWF  xF9,W
675A:  BZ    679E
....................                            http_parse_cgi_string(http_page_req[hs], pValue); 
675C:  MOVF   xFA,W
675E:  MULLW  04
6760:  MOVF   FF3,W
6762:  CLRF   03
6764:  ADDLW  6E
6766:  MOVWF  FE9
6768:  MOVLW  02
676A:  ADDWFC 03,W
676C:  MOVWF  FEA
676E:  MOVFF  FEF,2FC
6772:  MOVFF  FEC,2FD
6776:  MOVFF  FEC,2FE
677A:  MOVFF  FEC,2FF
677E:  MOVFF  2FF,305
6782:  MOVFF  2FE,304
6786:  MOVFF  2FD,303
678A:  MOVFF  2FC,302
678E:  MOVFF  2F9,307
6792:  MOVFF  2F8,306
6796:  MOVLB  0
6798:  CALL   4FAE
679C:  MOVLB  2
....................  
....................                         if (strcmp(pKey, http_get_str)==0) 
679E:  MOVFF  2F7,2FD
67A2:  MOVFF  2F6,2FC
67A6:  MOVLW  01
67A8:  MOVWF  xFF
67AA:  MOVLW  55
67AC:  MOVWF  xFE
67AE:  MOVLB  0
67B0:  CALL   43B8
67B4:  MOVF   01,F
67B6:  BNZ   67D0
....................                            http_cmd[hs]=HTTP_REQ_GET; 
67B8:  CLRF   03
67BA:  MOVLB  2
67BC:  MOVF   xFA,W
67BE:  ADDLW  6D
67C0:  MOVWF  FE9
67C2:  MOVLW  02
67C4:  ADDWFC 03,W
67C6:  MOVWF  FEA
67C8:  MOVLW  01
67CA:  MOVWF  FEF
....................                         else 
67CC:  BRA    67E4
67CE:  MOVLB  0
....................                            http_cmd[hs]=HTTP_REQ_POST; 
67D0:  CLRF   03
67D2:  MOVLB  2
67D4:  MOVF   xFA,W
67D6:  ADDLW  6D
67D8:  MOVWF  FE9
67DA:  MOVLW  02
67DC:  ADDWFC 03,W
67DE:  MOVWF  FEA
67E0:  MOVLW  02
67E2:  MOVWF  FEF
....................                      } 
....................                      else if (http_cmd[hs] != HTTP_REQ_UNKOWN)   //we processed a GET or POST 
67E4:  BRA    6850
67E6:  MOVLB  0
67E8:  CLRF   03
67EA:  MOVLB  2
67EC:  MOVF   xFA,W
67EE:  ADDLW  6D
67F0:  MOVWF  FE9
67F2:  MOVLW  02
67F4:  ADDWFC 03,W
67F6:  MOVWF  FEA
67F8:  MOVF   FEF,F
67FA:  BZ    6850
....................                      { 
....................                         //if you want to parse HTTP headers, do it here. 
....................                         //pKey and pVal hold the individual headers. 
....................  
....................                         //this driver only parses the Content-Length header. 
....................                         if (strcmp(pKey, http_len_str)==0) 
67FC:  MOVFF  2F7,2FD
6800:  MOVFF  2F6,2FC
6804:  MOVLW  01
6806:  MOVWF  xFF
6808:  MOVLW  5E
680A:  MOVWF  xFE
680C:  MOVLB  0
680E:  CALL   43B8
6812:  MOVF   01,F
6814:  BNZ   684E
....................                         { 
....................                            http_post_len[hs]=atol(pValue); 
6816:  BCF    FD8.0
6818:  MOVLB  2
681A:  RLCF   xFA,W
681C:  CLRF   03
681E:  ADDLW  72
6820:  MOVWF  01
6822:  MOVLW  02
6824:  ADDWFC 03,F
6826:  MOVFF  01,2FC
682A:  MOVFF  03,2FD
682E:  MOVFF  2F9,2FF
6832:  MOVFF  2F8,2FE
6836:  MOVLB  0
6838:  GOTO   5056
683C:  MOVFF  2FD,FEA
6840:  MOVFF  2FC,FE9
6844:  MOVFF  02,FEC
6848:  MOVF   FED,F
684A:  MOVFF  01,FEF
684E:  MOVLB  2
....................                         } 
....................                      } 
....................                   } 
....................                   else if (i[hs] == 0) 
6850:  BRA    68C0
6852:  CLRF   03
6854:  MOVF   xFA,W
6856:  ADDLW  6C
6858:  MOVWF  FE9
685A:  MOVLW  02
685C:  ADDWFC 03,W
685E:  MOVWF  FEA
6860:  MOVF   FEF,F
6862:  BNZ   68C0
....................                   { 
....................                      //got a double \r\n 
....................                      debug_http("HTTP %U GET HEADER DONE\r\n", hs); 
....................                      if (http_cmd[hs] == HTTP_REQ_POST) 
6864:  CLRF   03
6866:  MOVF   xFA,W
6868:  ADDLW  6D
686A:  MOVWF  FE9
686C:  MOVLW  02
686E:  ADDWFC 03,W
6870:  MOVWF  FEA
6872:  MOVF   FEF,W
6874:  SUBLW  02
6876:  BNZ   6896
....................                      { 
....................                         http_state[hs]=HTTP_GET_POST; 
6878:  BCF    FD8.0
687A:  RLCF   xFA,W
687C:  CLRF   03
687E:  ADDLW  1F
6880:  MOVWF  FE9
6882:  MOVLW  01
6884:  ADDWFC 03,W
6886:  MOVWF  FEA
6888:  MOVLW  01
688A:  MOVWF  FEC
688C:  MOVF   FED,F
688E:  MOVLW  04
6890:  MOVWF  FEF
....................                         postContinue=TRUE; 
6892:  BSF    xF4.1
....................                      } 
....................                      else 
6894:  BRA    68BA
....................                      { 
....................                         http_state[hs]=HTTP_SEND_RESPONSE; 
6896:  BCF    FD8.0
6898:  RLCF   xFA,W
689A:  CLRF   03
689C:  ADDLW  1F
689E:  MOVWF  FE9
68A0:  MOVLW  01
68A2:  ADDWFC 03,W
68A4:  MOVWF  FEA
68A6:  MOVLW  01
68A8:  MOVWF  FEC
68AA:  MOVF   FED,F
68AC:  MOVLW  06
68AE:  MOVWF  FEF
....................                         TCPDiscard(currSocket); 
68B0:  MOVFF  2FB,303
68B4:  MOVLB  0
68B6:  CALL   5276
....................                      } 
....................                      break;   //break out of read from ethernet loop 
68BA:  MOVLB  0
68BC:  BRA    68D4
68BE:  MOVLB  2
....................                   } 
....................                   i[hs]=0; 
68C0:  CLRF   03
68C2:  MOVF   xFA,W
68C4:  ADDLW  6C
68C6:  MOVWF  FE9
68C8:  MOVLW  02
68CA:  ADDWFC 03,W
68CC:  MOVWF  FEA
68CE:  CLRF   FEF
....................                } 
....................             } 
68D0:  BRA    6578
68D2:  MOVLB  0
....................             if (TickGetDiff(TickGet(),http_timer[hs]) > TICKS_PER_SECOND*20) 
68D4:  CALL   2600
68D8:  MOVFF  02,2FD
68DC:  MOVFF  01,2FC
68E0:  BCF    FD8.0
68E2:  MOVLB  2
68E4:  RLCF   xFA,W
68E6:  CLRF   03
68E8:  ADDLW  74
68EA:  MOVWF  FE9
68EC:  MOVLW  02
68EE:  ADDWFC 03,W
68F0:  MOVWF  FEA
68F2:  MOVFF  FEC,03
68F6:  MOVF   FED,F
68F8:  MOVFF  FEF,01
68FC:  MOVF   02,W
68FE:  SUBWF  03,W
6900:  BNC   690A
6902:  BNZ   690E
6904:  MOVF   01,W
6906:  SUBWF  xFC,W
6908:  BNC   690E
690A:  MOVLW  00
690C:  BRA    6910
690E:  MOVLW  01
6910:  CLRF   03
6912:  IORWF  03,W
6914:  BZ    6958
6916:  BCF    FD8.0
6918:  RLCF   xFA,W
691A:  CLRF   03
691C:  ADDLW  74
691E:  MOVWF  FE9
6920:  MOVLW  02
6922:  ADDWFC 03,W
6924:  MOVWF  FEA
6926:  MOVFF  FEC,03
692A:  MOVF   FED,F
692C:  MOVF   FEF,W
692E:  SUBLW  FF
6930:  MOVWF  xFC
6932:  MOVLW  FF
6934:  SUBFWB 03,W
6936:  MOVWF  xFD
6938:  MOVLB  0
693A:  CALL   2600
693E:  MOVF   01,W
6940:  MOVLB  2
6942:  ADDWF  xFC,F
6944:  MOVF   02,W
6946:  ADDWFC xFD,F
6948:  MOVLW  01
694A:  ADDWF  xFC,W
694C:  MOVWF  01
694E:  MOVLW  00
6950:  ADDWFC xFD,W
6952:  MOVWF  03
6954:  MOVF   01,W
6956:  BRA    698C
6958:  MOVLB  0
695A:  CALL   2600
695E:  MOVFF  02,2FD
6962:  MOVFF  01,2FC
6966:  BCF    FD8.0
6968:  MOVLB  2
696A:  RLCF   xFA,W
696C:  CLRF   03
696E:  ADDLW  74
6970:  MOVWF  FE9
6972:  MOVLW  02
6974:  ADDWFC 03,W
6976:  MOVWF  FEA
6978:  MOVFF  FEC,03
697C:  MOVF   FED,F
697E:  MOVF   FEF,W
6980:  SUBWF  01,W
6982:  MOVWF  00
6984:  MOVF   03,W
6986:  SUBWFB 02,W
6988:  MOVWF  03
698A:  MOVF   00,W
698C:  SUBLW  C8
698E:  BC    69C6
....................             { 
....................                //if (http_got_headers[hs]) 
....................                //{ 
....................                   debug_http("HTTP %U GET HEADER TIMEOUT\r\n", hs); 
....................                   http_page_req[hs]=0xFFFFFFFF; 
6990:  MOVF   xFA,W
6992:  MULLW  04
6994:  MOVF   FF3,W
6996:  CLRF   03
6998:  ADDLW  6E
699A:  MOVWF  FE9
699C:  MOVLW  02
699E:  ADDWFC 03,W
69A0:  MOVWF  FEA
69A2:  MOVLW  FF
69A4:  MOVWF  FEF
69A6:  MOVWF  FEC
69A8:  MOVWF  FEC
69AA:  MOVWF  FEC
....................                   http_state[hs]=HTTP_SEND_RESPONSE; 
69AC:  BCF    FD8.0
69AE:  RLCF   xFA,W
69B0:  CLRF   03
69B2:  ADDLW  1F
69B4:  MOVWF  FE9
69B6:  MOVLW  01
69B8:  ADDWFC 03,W
69BA:  MOVWF  FEA
69BC:  MOVLW  01
69BE:  MOVWF  FEC
69C0:  MOVF   FED,F
69C2:  MOVLW  06
69C4:  MOVWF  FEF
....................                //} 
....................                //else 
....................                //{ 
....................                //   http_state[hs]=HTTP_CLOSE; 
....................                //} 
....................             } 
....................             if (!postContinue) 
69C6:  BTFSC  xF4.1
69C8:  BRA    69CE
....................                break; 
69CA:  MOVLB  0
69CC:  BRA    6FC4
69CE:  MOVLB  0
....................  
....................          case HTTP_GET_POST: 
....................             debug_http("HTTP %U GET POST %LU\r\n", hs, http_post_len[hs]); 
....................             http_state[hs]=HTTP_GET_POST_CONTINUE; 
69D0:  BCF    FD8.0
69D2:  MOVLB  2
69D4:  RLCF   xFA,W
69D6:  CLRF   03
69D8:  ADDLW  1F
69DA:  MOVWF  FE9
69DC:  MOVLW  01
69DE:  ADDWFC 03,W
69E0:  MOVWF  FEA
69E2:  MOVLW  01
69E4:  MOVWF  FEC
69E6:  MOVF   FED,F
69E8:  MOVLW  05
69EA:  MOVWF  FEF
....................             http_timer[hs]=TickGet(); 
69EC:  BCF    FD8.0
69EE:  RLCF   xFA,W
69F0:  CLRF   03
69F2:  ADDLW  74
69F4:  MOVWF  01
69F6:  MOVLW  02
69F8:  ADDWFC 03,F
69FA:  MOVFF  01,2FC
69FE:  MOVFF  03,2FD
6A02:  MOVLB  0
6A04:  CALL   2600
6A08:  MOVFF  2FD,FEA
6A0C:  MOVFF  2FC,FE9
6A10:  MOVFF  02,FEC
6A14:  MOVF   FED,F
6A16:  MOVFF  01,FEF
....................             i[hs]=0; 
6A1A:  CLRF   03
6A1C:  MOVLB  2
6A1E:  MOVF   xFA,W
6A20:  ADDLW  6C
6A22:  MOVWF  FE9
6A24:  MOVLW  02
6A26:  ADDWFC 03,W
6A28:  MOVWF  FEA
6A2A:  CLRF   FEF
6A2C:  MOVLB  0
....................  
....................          case HTTP_GET_POST_CONTINUE: 
....................             while ( 
....................                      TCPIsGetReady(currSocket) && 
....................                      TCPGet(currSocket, &c) && 
....................                      (http_post_len[hs] != 0) 
....................                   ) 
....................             { 
6A2E:  MOVFF  2FB,2FC
6A32:  CALL   40EA
6A36:  MOVF   01,F
6A38:  BTFSC  FD8.2
6A3A:  BRA    6BF2
6A3C:  MOVFF  2FB,2FC
6A40:  MOVLW  02
6A42:  MOVLB  2
6A44:  MOVWF  xFE
6A46:  MOVLW  F5
6A48:  MOVWF  xFD
6A4A:  MOVLB  0
6A4C:  CALL   4116
6A50:  MOVF   01,F
6A52:  BTFSC  FD8.2
6A54:  BRA    6BF2
6A56:  BCF    FD8.0
6A58:  MOVLB  2
6A5A:  RLCF   xFA,W
6A5C:  CLRF   03
6A5E:  ADDLW  72
6A60:  MOVWF  FE9
6A62:  MOVLW  02
6A64:  ADDWFC 03,W
6A66:  MOVWF  FEA
6A68:  MOVFF  FEC,2FD
6A6C:  MOVF   FED,F
6A6E:  MOVFF  FEF,2FC
6A72:  MOVF   xFC,F
6A74:  BNZ   6A80
6A76:  MOVF   xFD,F
6A78:  BTFSS  FD8.2
6A7A:  BRA    6A80
6A7C:  MOVLB  0
6A7E:  BRA    6BF2
....................                http_post_len[hs] -= 1; 
6A80:  BCF    FD8.0
6A82:  RLCF   xFA,W
6A84:  CLRF   03
6A86:  ADDLW  72
6A88:  MOVWF  FE9
6A8A:  MOVLW  02
6A8C:  ADDWFC 03,W
6A8E:  MOVWF  FEA
6A90:  MOVLW  01
6A92:  SUBWF  FEF,W
6A94:  MOVWF  00
6A96:  MOVLW  00
6A98:  SUBWFB FEC,W
6A9A:  MOVWF  03
6A9C:  MOVF   00,W
6A9E:  MOVF   FED,F
6AA0:  MOVWF  FEF
6AA2:  MOVFF  03,FEC
....................  
....................                if (c!='&') 
6AA6:  MOVF   xF5,W
6AA8:  SUBLW  26
6AAA:  BZ    6AE2
....................                { 
....................                   buffer[hs][i[hs]++]=c; 
6AAC:  MOVF   xFA,W
6AAE:  MULLW  FE
6AB0:  MOVF   FF3,W
6AB2:  CLRF   xFD
6AB4:  MOVWF  xFC
6AB6:  CLRF   03
6AB8:  MOVF   xFA,W
6ABA:  ADDLW  6C
6ABC:  MOVWF  FE9
6ABE:  MOVLW  02
6AC0:  ADDWFC 03,W
6AC2:  MOVWF  FEA
6AC4:  MOVF   FEF,W
6AC6:  INCF   FEF,F
6AC8:  CLRF   03
6ACA:  ADDWF  xFC,W
6ACC:  MOVWF  01
6ACE:  MOVF   xFD,W
6AD0:  ADDWFC 03,F
6AD2:  MOVF   01,W
6AD4:  ADDLW  6E
6AD6:  MOVWF  FE9
6AD8:  MOVLW  01
6ADA:  ADDWFC 03,W
6ADC:  MOVWF  FEA
6ADE:  MOVFF  2F5,FEF
....................                } 
....................  
....................                if ( (c=='&') || (http_post_len[hs] == 0) ) 
6AE2:  MOVF   xF5,W
6AE4:  SUBLW  26
6AE6:  BZ    6B0A
6AE8:  BCF    FD8.0
6AEA:  RLCF   xFA,W
6AEC:  CLRF   03
6AEE:  ADDLW  72
6AF0:  MOVWF  FE9
6AF2:  MOVLW  02
6AF4:  ADDWFC 03,W
6AF6:  MOVWF  FEA
6AF8:  MOVFF  FEC,2FD
6AFC:  MOVF   FED,F
6AFE:  MOVFF  FEF,2FC
6B02:  MOVF   xFC,F
6B04:  BNZ   6BEE
6B06:  MOVF   xFD,F
6B08:  BNZ   6BEE
....................                { 
....................                   buffer[hs][i[hs]]=0; 
6B0A:  MOVF   xFA,W
6B0C:  MULLW  FE
6B0E:  MOVF   FF3,W
6B10:  CLRF   xFD
6B12:  MOVWF  xFC
6B14:  CLRF   03
6B16:  MOVF   xFA,W
6B18:  ADDLW  6C
6B1A:  MOVWF  FE9
6B1C:  MOVLW  02
6B1E:  ADDWFC 03,W
6B20:  MOVWF  FEA
6B22:  CLRF   03
6B24:  MOVF   FEF,W
6B26:  ADDWF  xFC,W
6B28:  MOVWF  01
6B2A:  MOVF   xFD,W
6B2C:  ADDWFC 03,F
6B2E:  MOVF   01,W
6B30:  ADDLW  6E
6B32:  MOVWF  FE9
6B34:  MOVLW  01
6B36:  ADDWFC 03,W
6B38:  MOVWF  FEA
6B3A:  CLRF   FEF
....................  
....................                   debug_http("%lu - %s\r\n", http_post_len[hs], &buffer[hs][0]); 
....................  
....................                   http_parse_cgi_string(http_page_req[hs], &buffer[hs][0]); 
6B3C:  MOVF   xFA,W
6B3E:  MULLW  04
6B40:  MOVF   FF3,W
6B42:  CLRF   03
6B44:  ADDLW  6E
6B46:  MOVWF  FE9
6B48:  MOVLW  02
6B4A:  ADDWFC 03,W
6B4C:  MOVWF  FEA
6B4E:  MOVFF  FEF,2FC
6B52:  MOVFF  FEC,2FD
6B56:  MOVFF  FEC,2FE
6B5A:  MOVFF  FEC,2FF
6B5E:  MOVF   xFA,W
6B60:  MULLW  FE
6B62:  MOVF   FF3,W
6B64:  MOVLB  3
6B66:  CLRF   x01
6B68:  MOVWF  x00
6B6A:  MOVLW  6E
6B6C:  ADDWF  x00,F
6B6E:  MOVLW  01
6B70:  ADDWFC x01,F
6B72:  MOVFF  2FF,305
6B76:  MOVFF  2FE,304
6B7A:  MOVFF  2FD,303
6B7E:  MOVFF  2FC,302
6B82:  MOVFF  301,307
6B86:  MOVFF  300,306
6B8A:  MOVLB  0
6B8C:  CALL   4FAE
....................                   if (http_post_len[hs] == 0) 
6B90:  BCF    FD8.0
6B92:  MOVLB  2
6B94:  RLCF   xFA,W
6B96:  CLRF   03
6B98:  ADDLW  72
6B9A:  MOVWF  FE9
6B9C:  MOVLW  02
6B9E:  ADDWFC 03,W
6BA0:  MOVWF  FEA
6BA2:  MOVFF  FEC,2FD
6BA6:  MOVF   FED,F
6BA8:  MOVFF  FEF,2FC
6BAC:  MOVF   xFC,F
6BAE:  BNZ   6BDE
6BB0:  MOVF   xFD,F
6BB2:  BNZ   6BDE
....................                   { 
....................                      http_state[hs]=HTTP_SEND_RESPONSE; 
6BB4:  BCF    FD8.0
6BB6:  RLCF   xFA,W
6BB8:  CLRF   03
6BBA:  ADDLW  1F
6BBC:  MOVWF  FE9
6BBE:  MOVLW  01
6BC0:  ADDWFC 03,W
6BC2:  MOVWF  FEA
6BC4:  MOVLW  01
6BC6:  MOVWF  FEC
6BC8:  MOVF   FED,F
6BCA:  MOVLW  06
6BCC:  MOVWF  FEF
....................                      TCPDiscard(currSocket); 
6BCE:  MOVFF  2FB,303
6BD2:  MOVLB  0
6BD4:  CALL   5276
....................                      break; 
6BD8:  BRA    6BF2
....................                   } 
....................                   else 
6BDA:  BRA    6BF0
6BDC:  MOVLB  2
....................                      i[hs]=0; 
6BDE:  CLRF   03
6BE0:  MOVF   xFA,W
6BE2:  ADDLW  6C
6BE4:  MOVWF  FE9
6BE6:  MOVLW  02
6BE8:  ADDWFC 03,W
6BEA:  MOVWF  FEA
6BEC:  CLRF   FEF
6BEE:  MOVLB  0
....................                } 
....................             } 
6BF0:  BRA    6A2E
....................             if (TickGetDiff(TickGet(),http_timer[hs]) > TICKS_PER_SECOND*20) 
6BF2:  CALL   2600
6BF6:  MOVFF  02,2FD
6BFA:  MOVFF  01,2FC
6BFE:  BCF    FD8.0
6C00:  MOVLB  2
6C02:  RLCF   xFA,W
6C04:  CLRF   03
6C06:  ADDLW  74
6C08:  MOVWF  FE9
6C0A:  MOVLW  02
6C0C:  ADDWFC 03,W
6C0E:  MOVWF  FEA
6C10:  MOVFF  FEC,03
6C14:  MOVF   FED,F
6C16:  MOVFF  FEF,01
6C1A:  MOVF   02,W
6C1C:  SUBWF  03,W
6C1E:  BNC   6C28
6C20:  BNZ   6C2C
6C22:  MOVF   01,W
6C24:  SUBWF  xFC,W
6C26:  BNC   6C2C
6C28:  MOVLW  00
6C2A:  BRA    6C2E
6C2C:  MOVLW  01
6C2E:  CLRF   03
6C30:  IORWF  03,W
6C32:  BZ    6C76
6C34:  BCF    FD8.0
6C36:  RLCF   xFA,W
6C38:  CLRF   03
6C3A:  ADDLW  74
6C3C:  MOVWF  FE9
6C3E:  MOVLW  02
6C40:  ADDWFC 03,W
6C42:  MOVWF  FEA
6C44:  MOVFF  FEC,03
6C48:  MOVF   FED,F
6C4A:  MOVF   FEF,W
6C4C:  SUBLW  FF
6C4E:  MOVWF  xFC
6C50:  MOVLW  FF
6C52:  SUBFWB 03,W
6C54:  MOVWF  xFD
6C56:  MOVLB  0
6C58:  CALL   2600
6C5C:  MOVF   01,W
6C5E:  MOVLB  2
6C60:  ADDWF  xFC,F
6C62:  MOVF   02,W
6C64:  ADDWFC xFD,F
6C66:  MOVLW  01
6C68:  ADDWF  xFC,W
6C6A:  MOVWF  01
6C6C:  MOVLW  00
6C6E:  ADDWFC xFD,W
6C70:  MOVWF  03
6C72:  MOVF   01,W
6C74:  BRA    6CAA
6C76:  MOVLB  0
6C78:  CALL   2600
6C7C:  MOVFF  02,2FD
6C80:  MOVFF  01,2FC
6C84:  BCF    FD8.0
6C86:  MOVLB  2
6C88:  RLCF   xFA,W
6C8A:  CLRF   03
6C8C:  ADDLW  74
6C8E:  MOVWF  FE9
6C90:  MOVLW  02
6C92:  ADDWFC 03,W
6C94:  MOVWF  FEA
6C96:  MOVFF  FEC,03
6C9A:  MOVF   FED,F
6C9C:  MOVF   FEF,W
6C9E:  SUBWF  01,W
6CA0:  MOVWF  00
6CA2:  MOVF   03,W
6CA4:  SUBWFB 02,W
6CA6:  MOVWF  03
6CA8:  MOVF   00,W
6CAA:  SUBLW  C8
6CAC:  BC    6CE4
....................             { 
....................                debug_http("HTTP %U GET POST TIMEOUT\r\n", hs); 
....................                http_page_req[hs]=0xFFFFFFFF; 
6CAE:  MOVF   xFA,W
6CB0:  MULLW  04
6CB2:  MOVF   FF3,W
6CB4:  CLRF   03
6CB6:  ADDLW  6E
6CB8:  MOVWF  FE9
6CBA:  MOVLW  02
6CBC:  ADDWFC 03,W
6CBE:  MOVWF  FEA
6CC0:  MOVLW  FF
6CC2:  MOVWF  FEF
6CC4:  MOVWF  FEC
6CC6:  MOVWF  FEC
6CC8:  MOVWF  FEC
....................                http_state[hs]=HTTP_SEND_RESPONSE; 
6CCA:  BCF    FD8.0
6CCC:  RLCF   xFA,W
6CCE:  CLRF   03
6CD0:  ADDLW  1F
6CD2:  MOVWF  FE9
6CD4:  MOVLW  01
6CD6:  ADDWFC 03,W
6CD8:  MOVWF  FEA
6CDA:  MOVLW  01
6CDC:  MOVWF  FEC
6CDE:  MOVF   FED,F
6CE0:  MOVLW  06
6CE2:  MOVWF  FEF
....................             } 
....................             break; 
6CE4:  MOVLB  0
6CE6:  BRA    6FC4
....................  
....................          case HTTP_SEND_RESPONSE: 
....................             debug_http("HTTP %U SEND RESPONSE\r\n", hs); 
....................             lastHTTPPutConstPos[hs]=0; 
6CE8:  MOVLB  2
6CEA:  MOVF   xFA,W
6CEC:  MULLW  04
6CEE:  MOVF   FF3,W
6CF0:  CLRF   03
6CF2:  ADDLW  22
6CF4:  MOVWF  FE9
6CF6:  MOVLW  01
6CF8:  ADDWFC 03,W
6CFA:  MOVWF  FEA
6CFC:  MOVF   FEE,F
6CFE:  MOVF   FEE,F
6D00:  CLRF   FEC
6D02:  MOVF   FED,F
6D04:  CLRF   FEF
6D06:  MOVF   FED,F
6D08:  CLRF   FEF
6D0A:  MOVF   FED,F
6D0C:  CLRF   FEF
....................             http_state[hs]=HTTP_SEND_RESPONSE_CONTINUE; 
6D0E:  BCF    FD8.0
6D10:  RLCF   xFA,W
6D12:  CLRF   03
6D14:  ADDLW  1F
6D16:  MOVWF  FE9
6D18:  MOVLW  01
6D1A:  ADDWFC 03,W
6D1C:  MOVWF  FEA
6D1E:  MOVLW  01
6D20:  MOVWF  FEC
6D22:  MOVF   FED,F
6D24:  MOVLW  07
6D26:  MOVWF  FEF
6D28:  MOVLB  0
....................  
....................          case HTTP_SEND_RESPONSE_CONTINUE: 
....................             TCPDiscard(currSocket); 
6D2A:  MOVFF  2FB,303
6D2E:  CALL   5276
....................             if (TCPIsPutReady(currSocket)) 
6D32:  MOVFF  2FB,31F
6D36:  CALL   52C4
6D3A:  MOVF   01,F
6D3C:  BTFSC  FD8.2
6D3E:  BRA    6E7A
....................             { 
....................                debug_http("\r\nPUTTING HTTP SEG\r\n"); 
....................                if (http_page_req[hs]==0xFFFFFFFF) 
6D40:  MOVLB  2
6D42:  MOVF   xFA,W
6D44:  MULLW  04
6D46:  MOVF   FF3,W
6D48:  CLRF   03
6D4A:  ADDLW  6E
6D4C:  MOVWF  FE9
6D4E:  MOVLW  02
6D50:  ADDWFC 03,W
6D52:  MOVWF  FEA
6D54:  MOVFF  FEF,2FC
6D58:  MOVFF  FEC,2FD
6D5C:  MOVFF  FEC,2FE
6D60:  MOVFF  FEC,2FF
6D64:  INCFSZ xFC,W
6D66:  BRA    6DAE
6D68:  INCFSZ xFD,W
6D6A:  BRA    6DAE
6D6C:  INCFSZ xFE,W
6D6E:  BRA    6DAE
6D70:  INCFSZ xFF,W
6D72:  BRA    6DAE
....................                   doneSend=tcp_http_put_file(hs, 500, label_address(http_500_error), 0); 
6D74:  MOVLW  01
6D76:  MOVWF  03
6D78:  MOVLW  18
6D7A:  MOVWF  xFC
6D7C:  MOVFF  03,2FD
6D80:  MOVFF  2FA,300
6D84:  MOVLW  01
6D86:  MOVLB  3
6D88:  MOVWF  x02
6D8A:  MOVLW  F4
6D8C:  MOVWF  x01
6D8E:  CLRF   x06
6D90:  CLRF   x05
6D92:  MOVFF  03,304
6D96:  MOVFF  2FC,303
6D9A:  CLRF   x08
6D9C:  CLRF   x07
6D9E:  MOVLB  0
6DA0:  CALL   5EF2
6DA4:  MOVLB  2
6DA6:  BCF    xF4.0
6DA8:  BTFSC  01.0
6DAA:  BSF    xF4.0
....................                else if (http_page_req[hs]) 
6DAC:  BRA    6E5A
....................                 #if HTTP_USE_CONTENT_TYPE 
6DAE:  MOVF   xFA,W
6DB0:  MULLW  04
6DB2:  MOVF   FF3,W
6DB4:  CLRF   03
6DB6:  ADDLW  6E
6DB8:  MOVWF  FE9
6DBA:  MOVLW  02
6DBC:  ADDWFC 03,W
6DBE:  MOVWF  FEA
6DC0:  MOVF   FEF,F
6DC2:  BNZ   6DD0
6DC4:  MOVF   FEC,F
6DC6:  BNZ   6DD0
6DC8:  MOVF   FEC,F
6DCA:  BNZ   6DD0
6DCC:  MOVF   FEC,F
6DCE:  BZ    6E22
....................                   doneSend=tcp_http_put_file(hs, 200, http_page_req[hs], &contentType[hs][0]); 
....................                 #else 
....................                   doneSend=tcp_http_put_file(hs, 200, http_page_req[hs], 0); 
6DD0:  MOVF   xFA,W
6DD2:  MULLW  04
6DD4:  MOVF   FF3,W
6DD6:  CLRF   03
6DD8:  ADDLW  6E
6DDA:  MOVWF  FE9
6DDC:  MOVLW  02
6DDE:  ADDWFC 03,W
6DE0:  MOVWF  FEA
6DE2:  MOVFF  FEF,2FC
6DE6:  MOVFF  FEC,2FD
6DEA:  MOVFF  FEC,2FE
6DEE:  MOVFF  FEC,2FF
6DF2:  MOVFF  2FA,300
6DF6:  MOVLB  3
6DF8:  CLRF   x02
6DFA:  MOVLW  C8
6DFC:  MOVWF  x01
6DFE:  MOVFF  2FF,306
6E02:  MOVFF  2FE,305
6E06:  MOVFF  2FD,304
6E0A:  MOVFF  2FC,303
6E0E:  CLRF   x08
6E10:  CLRF   x07
6E12:  MOVLB  0
6E14:  CALL   5EF2
6E18:  MOVLB  2
6E1A:  BCF    xF4.0
6E1C:  BTFSC  01.0
6E1E:  BSF    xF4.0
....................                 #endif 
....................                else 
6E20:  BRA    6E5A
....................                   doneSend=tcp_http_put_file(hs, 404, label_address(http_404_error), 0); 
6E22:  MOVLW  00
6E24:  MOVWF  03
6E26:  MOVLW  D4
6E28:  MOVWF  xFC
6E2A:  MOVFF  03,2FD
6E2E:  MOVFF  2FA,300
6E32:  MOVLW  01
6E34:  MOVLB  3
6E36:  MOVWF  x02
6E38:  MOVLW  94
6E3A:  MOVWF  x01
6E3C:  CLRF   x06
6E3E:  CLRF   x05
6E40:  MOVFF  03,304
6E44:  MOVFF  2FC,303
6E48:  CLRF   x08
6E4A:  CLRF   x07
6E4C:  MOVLB  0
6E4E:  CALL   5EF2
6E52:  MOVLB  2
6E54:  BCF    xF4.0
6E56:  BTFSC  01.0
6E58:  BSF    xF4.0
....................  
....................                if (doneSend) 
6E5A:  BTFSS  xF4.0
6E5C:  BRA    6E78
....................                { 
....................                   //if (http_isKeepAlive[hs]) 
....................                   //   http_state[hs]=HTTP_CONNECTED; 
....................                   //else 
....................                   //   http_state[hs]=HTTP_CLOSE; 
....................                   http_state[hs] = HTTP_CLOSE; 
6E5E:  BCF    FD8.0
6E60:  RLCF   xFA,W
6E62:  CLRF   03
6E64:  ADDLW  1F
6E66:  MOVWF  FE9
6E68:  MOVLW  01
6E6A:  ADDWFC 03,W
6E6C:  MOVWF  FEA
6E6E:  MOVLW  01
6E70:  MOVWF  FEC
6E72:  MOVF   FED,F
6E74:  MOVLW  08
6E76:  MOVWF  FEF
6E78:  MOVLB  0
....................                   debug_http("HTTP %U RESPONSE SENT\r\n", hs); 
....................                } 
....................             } 
....................             /*else 
....................             { 
....................                debug_http("\r\nNR => RW=%LX B=%X IS=%U\r\n", 
....................                      TCB[currSocket].RemoteWindow, 
....................                      TCB[currSocket].TxBuffer, 
....................                      TCB[currSocket].Flags.bIsPutReady 
....................                   ); 
....................                delay_ms(100); 
....................             }*/ 
....................             break; 
6E7A:  BRA    6FC4
....................  
....................          case HTTP_CLOSE: 
....................             //since we set connection: close in the header, the client 
....................             //should automatically close.  but after so many seconds we 
....................             //shall kill the connection 
....................             http_state[hs]=HTTP_CLOSE_WAITING; 
6E7C:  BCF    FD8.0
6E7E:  MOVLB  2
6E80:  RLCF   xFA,W
6E82:  CLRF   03
6E84:  ADDLW  1F
6E86:  MOVWF  FE9
6E88:  MOVLW  01
6E8A:  ADDWFC 03,W
6E8C:  MOVWF  FEA
6E8E:  MOVLW  01
6E90:  MOVWF  FEC
6E92:  MOVF   FED,F
6E94:  MOVLW  09
6E96:  MOVWF  FEF
....................             http_timer[hs]=TickGet(); 
6E98:  BCF    FD8.0
6E9A:  RLCF   xFA,W
6E9C:  CLRF   03
6E9E:  ADDLW  74
6EA0:  MOVWF  01
6EA2:  MOVLW  02
6EA4:  ADDWFC 03,F
6EA6:  MOVFF  01,2FC
6EAA:  MOVFF  03,2FD
6EAE:  MOVLB  0
6EB0:  CALL   2600
6EB4:  MOVFF  2FD,FEA
6EB8:  MOVFF  2FC,FE9
6EBC:  MOVFF  02,FEC
6EC0:  MOVF   FED,F
6EC2:  MOVFF  01,FEF
....................  
....................          case HTTP_CLOSE_WAITING: 
....................             TCPDiscard(currSocket); 
6EC6:  MOVFF  2FB,303
6ECA:  CALL   5276
....................             if (  TCPIsPutReady(currSocket) || 
....................                   (TickGetDiff(TickGet(),http_timer[hs]) > (TICKS_PER_SECOND*5)) 
....................                ) 
6ECE:  MOVFF  2FB,31F
6ED2:  CALL   52C4
6ED6:  MOVF   01,F
6ED8:  BNZ   6F98
6EDA:  CALL   2600
6EDE:  MOVFF  02,2FD
6EE2:  MOVFF  01,2FC
6EE6:  BCF    FD8.0
6EE8:  MOVLB  2
6EEA:  RLCF   xFA,W
6EEC:  CLRF   03
6EEE:  ADDLW  74
6EF0:  MOVWF  FE9
6EF2:  MOVLW  02
6EF4:  ADDWFC 03,W
6EF6:  MOVWF  FEA
6EF8:  MOVFF  FEC,03
6EFC:  MOVF   FED,F
6EFE:  MOVFF  FEF,01
6F02:  MOVF   02,W
6F04:  SUBWF  03,W
6F06:  BNC   6F10
6F08:  BNZ   6F14
6F0A:  MOVF   01,W
6F0C:  SUBWF  xFC,W
6F0E:  BNC   6F14
6F10:  MOVLW  00
6F12:  BRA    6F16
6F14:  MOVLW  01
6F16:  CLRF   03
6F18:  IORWF  03,W
6F1A:  BZ    6F5E
6F1C:  BCF    FD8.0
6F1E:  RLCF   xFA,W
6F20:  CLRF   03
6F22:  ADDLW  74
6F24:  MOVWF  FE9
6F26:  MOVLW  02
6F28:  ADDWFC 03,W
6F2A:  MOVWF  FEA
6F2C:  MOVFF  FEC,03
6F30:  MOVF   FED,F
6F32:  MOVF   FEF,W
6F34:  SUBLW  FF
6F36:  MOVWF  xFC
6F38:  MOVLW  FF
6F3A:  SUBFWB 03,W
6F3C:  MOVWF  xFD
6F3E:  MOVLB  0
6F40:  CALL   2600
6F44:  MOVF   01,W
6F46:  MOVLB  2
6F48:  ADDWF  xFC,F
6F4A:  MOVF   02,W
6F4C:  ADDWFC xFD,F
6F4E:  MOVLW  01
6F50:  ADDWF  xFC,W
6F52:  MOVWF  01
6F54:  MOVLW  00
6F56:  ADDWFC xFD,W
6F58:  MOVWF  03
6F5A:  MOVF   01,W
6F5C:  BRA    6F92
6F5E:  MOVLB  0
6F60:  CALL   2600
6F64:  MOVFF  02,2FD
6F68:  MOVFF  01,2FC
6F6C:  BCF    FD8.0
6F6E:  MOVLB  2
6F70:  RLCF   xFA,W
6F72:  CLRF   03
6F74:  ADDLW  74
6F76:  MOVWF  FE9
6F78:  MOVLW  02
6F7A:  ADDWFC 03,W
6F7C:  MOVWF  FEA
6F7E:  MOVFF  FEC,03
6F82:  MOVF   FED,F
6F84:  MOVF   FEF,W
6F86:  SUBWF  01,W
6F88:  MOVWF  00
6F8A:  MOVF   03,W
6F8C:  SUBWFB 02,W
6F8E:  MOVWF  03
6F90:  MOVF   00,W
6F92:  SUBLW  32
6F94:  BC    6FBC
6F96:  MOVLB  0
....................             { 
....................                debug_http("HTTP %U FORCE CLOSED\r\n", hs); 
....................                TCPDisconnect(currSocket); 
6F98:  MOVFF  2FB,2FC
6F9C:  GOTO   6226
....................                http_state[hs]=HTTP_CLOSED; 
6FA0:  BCF    FD8.0
6FA2:  MOVLB  2
6FA4:  RLCF   xFA,W
6FA6:  CLRF   03
6FA8:  ADDLW  1F
6FAA:  MOVWF  FE9
6FAC:  MOVLW  01
6FAE:  ADDWFC 03,W
6FB0:  MOVWF  FEA
6FB2:  MOVLW  01
6FB4:  MOVWF  FEC
6FB6:  MOVF   FED,F
6FB8:  MOVLW  0A
6FBA:  MOVWF  FEF
....................             } 
....................             break; 
6FBC:  MOVLB  0
6FBE:  BRA    6FC4
....................  
....................          case HTTP_CLOSED: //do nothing until socket actually closes 
....................          default: 
....................             break; 
6FC0:  MOVLB  0
6FC2:  BRA    6FC4
....................       } 
....................    } 
6FC4:  MOVLB  2
6FC6:  INCF   xFA,F
6FC8:  GOTO   636E
.................... } 
6FCC:  MOVLB  0
6FCE:  GOTO   717E (RETURN)
....................  
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    #include "tcpip/http2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
....................    #include "tcpip/mpfs.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    #include "tcpip/smtp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
....................    #include "tcpip/dns.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ANNOUNCE 
....................    #include "tcpip/announce.h" 
....................    #include "tcpip/announce.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
....................    #include "tcpip/snmp.c" 
.................... #endif 
....................  
.................... //#define MAX_ICMP_DATA_LEN   64 //moved to icmp.h 
....................  
.................... /* 
....................  * Stack FSM states. 
....................  */ 
.................... typedef enum _SM_STACK 
.................... { 
....................     SM_STACK_IDLE=0, 
....................     SM_STACK_MAC, 
....................     SM_STACK_IP, 
....................     SM_STACK_ICMP, 
....................     SM_STACK_ICMP_REPLY, 
....................     SM_STACK_ARP, 
....................     SM_STACK_TCP, 
....................     SM_STACK_UDP 
.................... } SM_STACK; 
....................  
.................... static SM_STACK smStack; 
....................  
.................... NODE_INFO remoteNode; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componets are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines are used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void) 
.................... { 
....................     smStack                     = SM_STACK_IDLE; 
*
1168:  MOVLB  2
116A:  CLRF   x76
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     /* 
....................      * If DHCP or IP Gleaning is enabled, 
....................      * startup in Config Mode. 
....................      */ 
....................     AppConfig.Flags.bInConfigMode = TRUE; 
.................... #endif 
....................  
....................    TickInit(); 
116C:  MOVLB  0
116E:  GOTO   08CE
....................  
.................... #if STACK_USE_MAC 
....................     MACInit(); 
1172:  BRA    0BA0
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
....................     ARPInit(); 
1174:  BRA    0D6E
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................     UDPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................     TCPInit(); 
1176:  BRA    0EBC
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    DHCPReset(); 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    ppp_init(); 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    HTTP_Init(); 
1178:  BRA    10FE
.................... #endif 
.................... } 
117A:  GOTO   765C (RETURN)
....................  
.................... /* 
.................... #if STACK_USE_MCPENC 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U TXB0.ADD=0x%LX TXB0.FR=%U NPL=0x%LX CPL=0x%LX",NICCurrentTxBuffer, TxBuffers[0].StartAddress, TxBuffers[0].bFree, NextPacketLocation.Val, CurrentPacketLocation.Val) 
.................... #else 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U NPL=0x%LX CPL=0x%LX", NICCurrentTxBuffer, NextPacketLocation.Val, CurrentPacketLocation.Val) 
.................... #endif 
.................... #else 
....................  #define DebugDisplayVals() 
.................... #endif 
.................... */ 
....................  
.................... #define DebugDisplayVals() 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically to 
....................  *                  ensure timely responses. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void) 
.................... { 
*
6FD2:  MOVLB  2
6FD4:  BCF    xF3.0
....................     static WORD dataCount; 
....................  
.................... #if STACK_USE_ICMP 
....................     static BYTE data[MAX_ICMP_DATA_LEN]; 
....................     static WORD ICMPId; 
....................     static WORD ICMPSeq; 
.................... #endif 
....................     IP_ADDR tempLocalIP; 
....................  
....................  
....................     union 
....................     { 
....................         BYTE MACFrameType; 
....................         BYTE IPFrameType; 
.................... #if STACK_USE_ICMP 
....................         ICMP_CODE ICMPCode; 
.................... #endif 
....................     } type; 
....................  
....................  
....................     BOOL lbContinue=FALSE; 
....................  
....................     do 
....................     { 
....................         lbContinue = FALSE; 
6FD6:  BCF    xF3.0
....................         switch(smStack) 
....................         { 
6FD8:  MOVF   x76,W
6FDA:  ADDLW  F9
6FDC:  BTFSC  FD8.0
6FDE:  BRA    7170
6FE0:  ADDLW  07
6FE2:  MOVLB  0
6FE4:  GOTO   7182
....................         case SM_STACK_IDLE: 
....................         case SM_STACK_MAC: 
....................             if ( !MACGetHeader(&remoteNode.MACAddr, &type.MACFrameType) ) 
6FE8:  MOVLW  02
6FEA:  MOVLB  2
6FEC:  MOVWF  xF5
6FEE:  MOVLW  77
6FF0:  MOVWF  xF4
6FF2:  MOVLW  02
6FF4:  MOVWF  xF7
6FF6:  MOVLW  F2
6FF8:  MOVWF  xF6
6FFA:  MOVLB  0
6FFC:  GOTO   133C
7000:  MOVF   01,F
7002:  BNZ   7008
....................             { 
....................                 #if STACK_USE_DHCP 
....................                     // Normally, an application would not include  DHCP module 
....................                     // if it is not enabled. But in case some one wants to disable 
....................                     // DHCP module at run-time, remember to not clear our IP 
....................                     // address if link is removed. 
....................                     if ( !DHCPIsDisabled() ) 
....................                     { 
....................                         if ( !MACIsLinked() ) 
....................                         { 
....................                             AppConfig.MyIPAddr.Val = 0x00000000ul; 
....................                             AppConfig.Flags.bInConfigMode = TRUE; 
....................                             DHCPReset(); 
....................                         } 
....................                     } 
....................                 #endif 
....................                 break; 
7004:  MOVLB  2
7006:  BRA    7170
....................             } 
....................  
.................... //            debug_stack("\r\nMAC GET "); 
....................  
....................             lbContinue = TRUE; 
7008:  MOVLB  2
700A:  BSF    xF3.0
....................             if ( type.MACFrameType == MAC_IP ) { 
700C:  MOVF   xF2,F
700E:  BNZ   7016
....................                 smStack = SM_STACK_IP; 
7010:  MOVLW  02
7012:  MOVWF  x76
.................... //                debug_stack("IP "); 
....................             } 
....................             else if ( type.MACFrameType == MAC_ARP ) { 
7014:  BRA    702A
7016:  MOVF   xF2,W
7018:  SUBLW  06
701A:  BNZ   7022
....................                 smStack = SM_STACK_ARP; 
701C:  MOVLW  05
701E:  MOVWF  x76
.................... //                debug_stack("ARP "); 
....................             } 
....................             else { 
7020:  BRA    702A
....................                 MACDiscardRx(); 
7022:  MOVLB  0
7024:  CALL   1256
7028:  MOVLB  2
.................... //                debug_stack("DISCARD"); 
....................             } 
....................             break; 
702A:  BRA    7170
....................  
....................         case SM_STACK_ARP: 
.................... #if STACK_USE_ARP 
....................             if ( ARPProcess() ) { 
702C:  GOTO   1B88
7030:  MOVF   01,F
7032:  BZ    7038
....................                 smStack = SM_STACK_IDLE; 
7034:  MOVLB  2
7036:  CLRF   x76
....................             } 
.................... #else 
....................             smStack = SM_STACK_IDLE; 
.................... #endif 
....................             break; 
7038:  MOVLB  2
703A:  BRA    7170
....................  
....................         case SM_STACK_IP: 
....................             if ( IPGetHeader(&tempLocalIP, 
....................                              &remoteNode, 
....................                              &type.IPFrameType, 
....................                              &dataCount) ) 
703C:  MOVLW  02
703E:  MOVLB  2
7040:  MOVWF  xF5
7042:  MOVLW  EE
7044:  MOVWF  xF4
7046:  MOVLW  02
7048:  MOVWF  xF7
704A:  MOVLW  77
704C:  MOVWF  xF6
704E:  MOVLW  02
7050:  MOVWF  xF9
7052:  MOVLW  F2
7054:  MOVWF  xF8
7056:  MOVLW  02
7058:  MOVWF  xFB
705A:  MOVLW  81
705C:  MOVWF  xFA
705E:  MOVLB  0
7060:  GOTO   1E76
7064:  MOVF   01,F
7066:  BZ    7092
....................             { 
....................                 lbContinue = TRUE; 
7068:  MOVLB  2
706A:  BSF    xF3.0
....................                 if ( type.IPFrameType == IP_PROT_ICMP ) 
706C:  DECFSZ xF2,W
706E:  BRA    7076
....................                 { 
....................                     smStack = SM_STACK_ICMP; 
7070:  MOVLW  03
7072:  MOVWF  x76
.................... //                    debug_stack("ICMP "); 
.................... #if STACK_USE_IP_GLEANING 
....................                     if(AppConfig.Flags.bInConfigMode && !DHCPIsDisabled()) 
....................                     { 
....................                         /* 
....................                          * Accoriding to "IP Gleaning" procedure, 
....................                          * when we receive an ICMP packet with a valid 
....................                          * IP address while we are still in configuration 
....................                          * mode, accept that address as ours and conclude 
....................                          * configuration mode. 
....................                          */ 
....................                         if( tempLocalIP.Val != 0xffffffff ) 
....................                         { 
....................                             AppConfig.Flags.bInConfigMode = FALSE; 
....................                             AppConfig.MyIPAddr = tempLocalIP; 
....................                             myDHCPBindCount--; 
....................                         } 
....................                     } 
.................... #endif 
....................                 } 
....................  
.................... #if STACK_USE_TCP 
....................                 else if ( type.IPFrameType == IP_PROT_TCP ) { 
7074:  BRA    708E
7076:  MOVF   xF2,W
7078:  SUBLW  06
707A:  BNZ   7082
....................                     smStack = SM_STACK_TCP; 
707C:  MOVLW  06
707E:  MOVWF  x76
....................                     debug_stack("TCP "); 
....................                 } 
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................                 else if ( type.IPFrameType == IP_PROT_UDP ) { 
....................                     smStack = SM_STACK_UDP; 
.................... //                    debug_stack("UDP "); 
....................                 } 
.................... #endif 
....................  
....................                 else 
7080:  BRA    708E
....................                 { 
....................                     lbContinue = FALSE; 
7082:  BCF    xF3.0
....................                     MACDiscardRx(); 
7084:  MOVLB  0
7086:  CALL   1256
....................  
....................                     smStack = SM_STACK_IDLE; 
708A:  MOVLB  2
708C:  CLRF   x76
.................... //                    debug_stack("UNKOWN-IP1 "); 
....................                 } 
....................             } 
....................             else 
708E:  BRA    709A
7090:  MOVLB  0
....................             { 
....................                 MACDiscardRx(); 
7092:  CALL   1256
....................                 smStack = SM_STACK_IDLE; 
7096:  MOVLB  2
7098:  CLRF   x76
.................... //                debug_stack("UNKOWN-IP2 "); 
....................             } 
....................             break; 
709A:  BRA    7170
....................  
.................... #if STACK_USE_UDP 
....................         case SM_STACK_UDP: 
....................             if ( UDPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
....................             { 
.................... //                debug_stack("\r\nUDP PROCESSED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
....................             } 
....................             break; 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................         case SM_STACK_TCP: 
....................             if ( TCPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
709C:  MOVLW  02
709E:  MOVLB  2
70A0:  MOVWF  xF5
70A2:  MOVLW  77
70A4:  MOVWF  xF4
70A6:  MOVLW  02
70A8:  MOVWF  xF7
70AA:  MOVLW  EE
70AC:  MOVWF  xF6
70AE:  MOVFF  282,2F9
70B2:  MOVFF  281,2F8
70B6:  MOVLB  0
70B8:  GOTO   3740
70BC:  MOVF   01,F
70BE:  BZ    70C4
....................             { 
....................                 debug_stack("\r\nTCP PROCESSED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
70C0:  MOVLB  2
70C2:  CLRF   x76
....................             } 
....................             break; 
70C4:  MOVLB  2
70C6:  BRA    7170
.................... #endif 
....................  
....................         case SM_STACK_ICMP: 
....................             smStack = SM_STACK_IDLE; 
70C8:  MOVLB  2
70CA:  CLRF   x76
....................  
.................... #if STACK_USE_ICMP 
....................             //if ( dataCount <= (MAX_ICMP_DATA_LEN+9) ) 
....................             if ( dataCount <= (MAX_ICMP_DATA_LEN+8) ) 
70CC:  MOVF   x82,F
70CE:  BNZ   711E
70D0:  MOVF   x81,W
70D2:  SUBLW  48
70D4:  BNC   711E
....................             { 
....................                 if ( ICMPGet(&type.ICMPCode, 
....................                              data, 
....................                              (BYTE*)&dataCount, 
....................                              &ICMPId, 
....................                              &ICMPSeq) ) 
70D6:  MOVLW  02
70D8:  MOVWF  xF5
70DA:  MOVLW  81
70DC:  MOVWF  xF4
70DE:  MOVLW  02
70E0:  MOVWF  xF7
70E2:  MOVLW  F2
70E4:  MOVWF  xF6
70E6:  MOVLW  02
70E8:  MOVWF  xF9
70EA:  MOVLW  83
70EC:  MOVWF  xF8
70EE:  MOVFF  2F5,2FB
70F2:  MOVFF  2F4,2FA
70F6:  MOVLW  02
70F8:  MOVWF  xFD
70FA:  MOVLW  C3
70FC:  MOVWF  xFC
70FE:  MOVLW  02
7100:  MOVWF  xFF
7102:  MOVLW  C5
7104:  MOVWF  xFE
7106:  MOVLB  0
7108:  GOTO   39DE
710C:  MOVF   01,F
710E:  BZ    7120
....................                 { 
....................                     if ( type.ICMPCode == ICMP_ECHO_REQUEST ) 
7110:  MOVLB  2
7112:  MOVF   xF2,W
7114:  SUBLW  08
7116:  BNZ   711E
....................                     { 
.................... //                        debug_stack("\r\nICMP PROCESSED"); 
....................                         lbContinue = TRUE; 
7118:  BSF    xF3.0
....................                         smStack = SM_STACK_ICMP_REPLY; 
711A:  MOVLW  04
711C:  MOVWF  x76
711E:  MOVLB  0
....................                     } 
....................                 } 
....................             } 
....................             DebugDisplayVals(); 
.................... #endif 
....................             MACDiscardRx(); 
7120:  CALL   1256
....................             break; 
7124:  MOVLB  2
7126:  BRA    7170
....................  
.................... #if STACK_USE_ICMP 
....................         case SM_STACK_ICMP_REPLY: 
....................             if ( ICMPIsTxReady() ) 
7128:  MOVLW  01
712A:  MOVLB  3
712C:  MOVWF  x7D
712E:  MOVLB  0
7130:  CALL   271E
7134:  MOVF   01,F
7136:  BZ    716A
....................             { 
....................                 ICMPPut(&remoteNode, 
....................                         ICMP_ECHO_REPLY, 
....................                         data, 
....................                         (BYTE)dataCount, 
....................                         ICMPId, 
....................                         ICMPSeq); 
7138:  MOVLW  02
713A:  MOVLB  2
713C:  MOVWF  xF5
713E:  MOVLW  77
7140:  MOVWF  xF4
7142:  CLRF   xF6
7144:  MOVLW  02
7146:  MOVWF  xF8
7148:  MOVLW  83
714A:  MOVWF  xF7
714C:  MOVFF  281,2F9
7150:  MOVFF  2C4,2FB
7154:  MOVFF  2C3,2FA
7158:  MOVFF  2C6,2FD
715C:  MOVFF  2C5,2FC
7160:  MOVLB  0
7162:  GOTO   3ABA
....................  
.................... //                debug_stack("\r\nICMP REPLIED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
7166:  MOVLB  2
7168:  CLRF   x76
....................             } 
....................             break; 
716A:  MOVLB  2
716C:  BRA    7170
716E:  MOVLB  2
.................... #endif 
....................  
....................         } 
....................  
....................     } while( lbContinue ); 
7170:  BTFSC  xF3.0
7172:  BRA    6FD6
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPTask(); 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_TCP 
....................     // Perform timed TCP FSM. 
....................     TCPTick(); 
7174:  MOVLB  0
7176:  GOTO   3BD8
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    HTTP_Task(); 
717A:  GOTO   636A
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     /* 
....................      * DHCP must be called all the time even after IP configuration is 
....................      * discovered. 
....................      * DHCP has to account lease expiration time and renew the configuration 
....................      * time. 
....................      */ 
....................     DHCPTask(); 
....................  
....................     if ( DHCPIsBound() ) 
....................         AppConfig.Flags.bInConfigMode = FALSE; 
....................  
.................... #endif 
....................  
....................  
.................... } 
717E:  GOTO   7706 (RETURN)
....................  
....................  
.................... /*********************  PAGINA WEB A MOSTRAR **********************************/ 
.................... /* Página principal INDEX (/) */ 
.................... const char  HTML_INDEX_PAGE[]=" 
.................... <HTML><BODY BGCOLOR=#FFFFFF TEXT=#000000> 
....................  
.................... <center><H1>Servidor WEB con PIC 18f4550 </H1></center> 
.................... <BR><center><H2>ROBOTYPIC</H2></CENTER> 
....................  
....................  
.................... <FORM METHOD=GET> 
.................... <P>LCD: <INPUT TYPE=\"text\" NAME=\"lcd\" size=20 maxlength=16> 
.................... <input type=\"submit\" value=\"Enviar texto\"> 
.................... </FORM> 
....................  
.................... <FORM METHOD=GET> 
.................... <input type=\"submit\" name=\"boton1\" value=\"Botón 1\"> 
.................... </FORM> 
....................  
.................... <FORM METHOD=GET> 
.................... <input type=\"submit\" name=\"boton2\" value=\"Botón 2\"> 
.................... </FORM> 
....................  
.................... <FORM METHOD=GET> 
.................... <input type=\"submit\" name=\"boton3\" value=\"Botón 3\"> 
.................... </FORM> 
....................  
.................... <P><A HREF=\"/lecturas\">Lecturas del PIC</A> 
.................... </BODY></HTML> 
.................... "; 
....................  
.................... /* Página secundaria (\lecturas). Accesible desde la página principal */ 
.................... const char  HTML_LECTURAS_PAGE[]=" 
.................... <meta http-equiv=\"refresh\"content=\"3;url=lecturas\"> 
....................  
.................... <HTML><BODY BGCOLOR=#FFFFFF TEXT=#000000> 
.................... <P> 
.................... <center><H1>Servidor WEB con PIC 18f4550 </H1></center> 
.................... <BR><center><H2>ROBOTYPIC</H2></CENTER> 
.................... <br><center>LECTURAS</center> 
....................  
.................... <P><B>AN: </B>%0 </P> 
.................... <BR/> 
.................... <P><B>RE0: </B>%1 </P> 
.................... <BR/> 
....................  
....................  
.................... <P><A HREF=\"/\">LCD/LEDs</A> 
.................... </BODY></HTML> 
.................... "; 
....................  
.................... /* Elección de MAC. No puede haber 2 dispositivos con misma MAC en una misma red 
....................    Microchip Vendor ID  MAC: 00.04.A3.xx.xx.xx.  */ 
.................... void MACAddrInit(void) { 
....................    MY_MAC_BYTE1=0; 
*
0888:  CLRF   1B
....................    MY_MAC_BYTE2=0x04; 
088A:  MOVLW  04
088C:  MOVWF  1C
....................    MY_MAC_BYTE3=0xA3; 
088E:  MOVLW  A3
0890:  MOVWF  1D
....................    MY_MAC_BYTE4=0x06; 
0892:  MOVLW  06
0894:  MOVWF  1E
....................    MY_MAC_BYTE5=0x07; 
0896:  MOVLW  07
0898:  MOVWF  1F
....................    MY_MAC_BYTE6=0x08; 
089A:  MOVLW  08
089C:  MOVWF  20
.................... } 
089E:  GOTO   7654 (RETURN)
....................  
.................... void IPAddrInit(void) { 
....................    //Elección de la dirección IP.  
....................    MY_IP_BYTE1=192; 
08A2:  MOVLW  C0
08A4:  MOVWF  17
....................    MY_IP_BYTE2=168; 
08A6:  MOVLW  A8
08A8:  MOVWF  18
....................    MY_IP_BYTE3=1; 
08AA:  MOVLW  01
08AC:  MOVWF  19
....................    MY_IP_BYTE4=15; 
08AE:  MOVLW  0F
08B0:  MOVWF  1A
....................  
....................    //Elección de la dirección de puerta de enlace.  
....................    MY_GATE_BYTE1=192; 
08B2:  MOVLW  C0
08B4:  MOVWF  25
....................    MY_GATE_BYTE2=168; 
08B6:  MOVLW  A8
08B8:  MOVWF  26
....................    MY_GATE_BYTE3=1; 
08BA:  MOVLW  01
08BC:  MOVWF  27
....................    MY_GATE_BYTE4=1; 
08BE:  MOVWF  28
....................  
....................    //Elección de la máscara de red.Si no se indica nada se tomará 255.255.255.0 
....................    MY_MASK_BYTE1=255; 
08C0:  MOVLW  FF
08C2:  MOVWF  21
....................    MY_MASK_BYTE2=255; 
08C4:  MOVWF  22
....................    MY_MASK_BYTE3=255; 
08C6:  MOVWF  23
....................    MY_MASK_BYTE4=0; 
08C8:  CLRF   24
.................... } 
08CA:  GOTO   7658 (RETURN)
....................  
....................  
.................... /***************************  FUNCIÓN GET PAGE   ******************************/ 
.................... /* Esta función devuelve la posición de memoria donde se encuentra la página web  
.................... a mostrar. En este caso se trata de una web con 2 páginas. Una principal index(/)  
.................... y una secundaria(/lecturas)                                                   */ 
....................  
.................... int32 http_get_page(char *file_str) { 
*
4CA2:  MOVLB  3
4CA4:  CLRF   x03
4CA6:  CLRF   x02
4CA8:  CLRF   x01
4CAA:  CLRF   x00
....................    int32 file_loc=0; 
....................    static char index[]="/"; 
....................    static char lecturas[]="/lecturas"; 
....................     
....................    printf(lcd_putc,"\fRequest %s ",file_str);      //Muestra en lcd solicitud 
4CAC:  MOVLW  5A
4CAE:  MOVWF  FF6
4CB0:  MOVLW  05
4CB2:  MOVWF  FF7
4CB4:  MOVLW  09
4CB6:  MOVWF  x15
4CB8:  MOVLB  0
4CBA:  CALL   117E
4CBE:  MOVFF  2FF,FEA
4CC2:  MOVFF  2FE,FE9
4CC6:  RCALL  4A2E
4CC8:  MOVLW  20
4CCA:  MOVLB  3
4CCC:  MOVWF  x21
4CCE:  MOVLB  0
4CD0:  CALL   07F4
....................  
....................    /* Busca la posición de memoria donde se encuentra la página solicitada */ 
....................    if (stricmp(file_str,index)==0)                 //Si es la principal... 
4CD4:  MOVFF  2FF,316
4CD8:  MOVFF  2FE,315
4CDC:  MOVLW  02
4CDE:  MOVLB  3
4CE0:  MOVWF  x18
4CE2:  MOVLW  C7
4CE4:  MOVWF  x17
4CE6:  MOVLB  0
4CE8:  RCALL  4A54
4CEA:  MOVF   01,F
4CEC:  BNZ   4D02
....................       file_loc=label_address(HTML_INDEX_PAGE);     //...toma su posición en la memoria 
4CEE:  MOVLW  01
4CF0:  MOVWF  03
4CF2:  MOVLW  AA
4CF4:  MOVLB  3
4CF6:  MOVWF  x00
4CF8:  MOVFF  03,301
4CFC:  CLRF   x02
4CFE:  CLRF   x03
....................    else if (stricmp(file_str,lecturas)==0)            //O si es la secundaria... 
4D00:  BRA    4D2E
4D02:  MOVFF  2FF,316
4D06:  MOVFF  2FE,315
4D0A:  MOVLW  02
4D0C:  MOVLB  3
4D0E:  MOVWF  x18
4D10:  MOVLW  C9
4D12:  MOVWF  x17
4D14:  MOVLB  0
4D16:  RCALL  4A54
4D18:  MOVF   01,F
4D1A:  BNZ   4D2E
....................       file_loc=label_address(HTML_LECTURAS_PAGE);    //...toma su posición en la memoria 
4D1C:  MOVLW  03
4D1E:  MOVWF  03
4D20:  MOVLW  FE
4D22:  MOVLB  3
4D24:  MOVWF  x00
4D26:  MOVFF  03,301
4D2A:  CLRF   x02
4D2C:  CLRF   x03
....................  
....................    /* Muestra en lcd la página solicitada */ 
....................    if (file_loc){                                  //Si existe...  
4D2E:  MOVLB  3
4D30:  MOVF   x00,F
4D32:  BNZ   4D40
4D34:  MOVF   x01,F
4D36:  BNZ   4D40
4D38:  MOVF   x02,F
4D3A:  BNZ   4D40
4D3C:  MOVF   x03,F
4D3E:  BZ    4D78
....................       printf(lcd_putc,"\n(FILE=%LU)",file_loc);    //...muestra en lcd pos. de memoria 
4D40:  MOVLW  68
4D42:  MOVWF  FF6
4D44:  MOVLW  05
4D46:  MOVWF  FF7
4D48:  MOVLW  07
4D4A:  MOVWF  x15
4D4C:  MOVLB  0
4D4E:  CALL   117E
4D52:  MOVLW  41
4D54:  MOVWF  FE9
4D56:  MOVFF  303,307
4D5A:  MOVFF  302,306
4D5E:  MOVFF  301,305
4D62:  MOVFF  300,304
4D66:  BRA    4BDC
4D68:  MOVLW  29
4D6A:  MOVLB  3
4D6C:  MOVWF  x21
4D6E:  MOVLB  0
4D70:  CALL   07F4
....................    } 
....................    else{                                           //Si no existe... 
4D74:  BRA    4D86
4D76:  MOVLB  3
....................       printf(lcd_putc,"\n(File Not Found)");       //...muestra en lcd mensaje 
4D78:  MOVLW  74
4D7A:  MOVWF  FF6
4D7C:  MOVLW  05
4D7E:  MOVWF  FF7
4D80:  MOVLB  0
4D82:  CALL   0868
....................    } 
....................    /* Devuelve la posición en la memoria donde se encuentra la página a mostrar */ 
....................    return(file_loc);                                
4D86:  MOVFF  300,00
4D8A:  MOVFF  301,01
4D8E:  MOVFF  302,02
4D92:  MOVFF  303,03
.................... } 
4D96:  GOTO   671E (RETURN)
....................  
.................... /**************************  FUNCIÓN FORMAT CHAR  *****************************/ 
.................... /* Con  la función http_format_char  interconectamos las variables virtuales de  
.................... la página web con las variables del programa del PIC. Se encarga de enviar los  
.................... cambios producidos en la aplicación del PIC y reflejarlos en la aplicación web.  
.................... Muestra,por tanto, las lectura obtenidas por el PIC y las representa en la  
.................... aplicación de la página web       
....................  
.................... %0 es la variable virtual para representar el valor de la lectura del canal  
.................... analógico 
.................... %1 es la variable virtual para representar el valor de la lectura del bit 0 del  
.................... puerto E. 
.................... */ 
.................... int8 http_format_char(int32 file, char id, char *str, int8 max_ret) { 
*
5DFE:  MOVLB  3
5E00:  CLRF   x28
....................    char new_str[20]; 
....................    int8 len=0; 
....................    int8 AD0; 
....................    int8 RE0; 
....................  
....................    *str=0; 
5E02:  MOVFF  311,FE9
5E06:  MOVFF  312,FEA
5E0A:  CLRF   FEF
....................  
....................    switch(id) { 
5E0C:  MOVF   x10,W
5E0E:  XORLW  30
5E10:  MOVLB  0
5E12:  BZ    5E1A
5E14:  XORLW  01
5E16:  BZ    5E7E
5E18:  BRA    5EB4
....................       case '0': 
....................          set_adc_channel(0); 
5E1A:  MOVLW  00
5E1C:  MOVWF  01
5E1E:  MOVF   FC2,W
5E20:  ANDLW  C3
5E22:  IORWF  01,W
5E24:  MOVWF  FC2
....................          delay_us(100); 
5E26:  MOVLW  A6
5E28:  MOVWF  00
5E2A:  DECFSZ 00,F
5E2C:  BRA    5E2A
5E2E:  NOP   
....................          AD0=read_adc(); 
5E30:  BSF    FC2.1
5E32:  BTFSC  FC2.1
5E34:  BRA    5E32
5E36:  MOVFF  FC4,329
5E3A:  MOVLB  3
....................          sprintf(new_str,"0x%X",AD0); 
5E3C:  MOVLW  03
5E3E:  MOVLB  2
5E40:  MOVWF  xD4
5E42:  MOVLW  14
5E44:  MOVWF  xD3
5E46:  MOVLW  30
5E48:  MOVLB  3
5E4A:  MOVWF  x31
5E4C:  MOVLB  0
5E4E:  RCALL  5C30
5E50:  MOVLW  78
5E52:  MOVLB  3
5E54:  MOVWF  x31
5E56:  MOVLB  0
5E58:  RCALL  5C30
5E5A:  MOVFF  329,32B
5E5E:  MOVLW  37
5E60:  MOVLB  3
5E62:  MOVWF  x2C
5E64:  MOVLB  0
5E66:  BRA    5C52
....................          len=strlen(new_str); 
5E68:  MOVLW  03
5E6A:  MOVLB  3
5E6C:  MOVWF  x2C
5E6E:  MOVLW  14
5E70:  MOVWF  x2B
5E72:  MOVLB  0
5E74:  CALL   483E
5E78:  MOVFF  01,328
....................       break; 
5E7C:  BRA    5EB8
....................       case '1': 
....................          RE0=bit_test(porte,0); 
5E7E:  MOVLB  3
5E80:  CLRF   x2A
5E82:  BTFSC  F84.0
5E84:  INCF   x2A,F
....................          sprintf(new_str,"%d",RE0); 
5E86:  MOVLW  03
5E88:  MOVLB  2
5E8A:  MOVWF  xD4
5E8C:  MOVLW  14
5E8E:  MOVWF  xD3
5E90:  MOVFF  32A,32B
5E94:  MOVLW  1F
5E96:  MOVLB  3
5E98:  MOVWF  x2C
5E9A:  MOVLB  0
5E9C:  BRA    5C9A
....................          len=strlen(new_str); 
5E9E:  MOVLW  03
5EA0:  MOVLB  3
5EA2:  MOVWF  x2C
5EA4:  MOVLW  14
5EA6:  MOVWF  x2B
5EA8:  MOVLB  0
5EAA:  CALL   483E
5EAE:  MOVFF  01,328
....................       break;   
5EB2:  BRA    5EB8
....................       default: 
....................       len=0; 
5EB4:  MOVLB  3
5EB6:  CLRF   x28
....................    } 
....................  
....................    if (len)strncpy(str, new_str, max_ret); 
5EB8:  MOVLB  3
5EBA:  MOVF   x28,F
5EBC:  BZ    5EDC
5EBE:  MOVFF  312,32C
5EC2:  MOVFF  311,32B
5EC6:  MOVLW  03
5EC8:  MOVWF  x2E
5ECA:  MOVLW  14
5ECC:  MOVWF  x2D
5ECE:  MOVFF  313,32F
5ED2:  MOVLB  0
5ED4:  BRA    5D7E
....................    else  *str=0; 
5ED6:  MOVLB  0
5ED8:  BRA    5EE6
5EDA:  MOVLB  3
5EDC:  MOVFF  311,FE9
5EE0:  MOVFF  312,FEA
5EE4:  CLRF   FEF
....................     
....................    return(len); 
5EE6:  MOVLB  3
5EE8:  MOVFF  328,01
.................... } 
5EEC:  MOVLB  0
5EEE:  GOTO   618E (RETURN)
....................  
.................... /***************************  FUNCIÓN EXEC CGI   ******************************/ 
.................... /* Con la función http_exec_cgi interconectamos las variables virtuales de la  
.................... página web con las variables del programa del PIC. Se encarga de recibir  
.................... los cambios producidos en la aplicación web y reflejarlos en el hardware del PIC.  
.................... Ejecuta, por tanto, la acción elegida según el valor de la variable virtual recibida  
.................... de la página web 
....................  
.................... key es la variable virtual que viene de la pagina web 
.................... val es el valor de una variable virtual de la página web 
.................... file es la dirección de la página web devuelta por http_get_page () 
....................  
.................... */ 
....................  
.................... void http_exec_cgi(int32 file, char *key, char *val) { 
....................    static char boton1_key[]="boton1"; 
....................    static char boton2_key[]="boton2"; 
....................    static char boton3_key[]="boton3"; 
....................    static char lcd_key[]="lcd"; 
....................  
....................    printf(lcd_putc,"\fCGI FILE=%LD", file); 
*
4EBA:  MOVLW  86
4EBC:  MOVWF  FF6
4EBE:  MOVLW  05
4EC0:  MOVWF  FF7
4EC2:  MOVLW  0A
4EC4:  MOVLB  3
4EC6:  MOVWF  x15
4EC8:  MOVLB  0
4ECA:  CALL   117E
4ECE:  MOVLW  41
4ED0:  MOVWF  FE9
4ED2:  MOVFF  310,318
4ED6:  MOVFF  30F,317
4EDA:  MOVFF  30E,316
4EDE:  MOVFF  30D,315
4EE2:  BRA    4D9A
....................    printf(lcd_putc,"\nKEY=%S", key); 
4EE4:  MOVLW  94
4EE6:  MOVWF  FF6
4EE8:  MOVLW  05
4EEA:  MOVWF  FF7
4EEC:  MOVLW  05
4EEE:  MOVLB  3
4EF0:  MOVWF  x15
4EF2:  MOVLB  0
4EF4:  CALL   117E
4EF8:  MOVFF  312,FEA
4EFC:  MOVFF  311,FE9
4F00:  RCALL  4A2E
....................    printf(lcd_putc,"\nVAL=%S", val); 
4F02:  MOVLW  9C
4F04:  MOVWF  FF6
4F06:  MOVLW  05
4F08:  MOVWF  FF7
4F0A:  MOVLW  05
4F0C:  MOVLB  3
4F0E:  MOVWF  x15
4F10:  MOVLB  0
4F12:  CALL   117E
4F16:  MOVFF  314,FEA
4F1A:  MOVFF  313,FE9
4F1E:  RCALL  4A2E
....................  
....................    /* Se ejecutará al pulsar el botón "Botón 1" en la aplicación web */ 
....................    if (stricmp(key,boton1_key)==0) { 
4F20:  MOVFF  312,316
4F24:  MOVFF  311,315
4F28:  MOVLW  02
4F2A:  MOVLB  3
4F2C:  MOVWF  x18
4F2E:  MOVLW  D5
4F30:  MOVWF  x17
4F32:  MOVLB  0
4F34:  RCALL  4A54
4F36:  MOVF   01,F
4F38:  BNZ   4F3E
....................       output_toggle(PIN_C0); 
4F3A:  BCF    F94.0
4F3C:  BTG    F8B.0
....................    } 
....................    /* Se ejecutará al pulsar el botón "Botón 2" en la aplicación web */ 
....................    if (stricmp(key,boton2_key)==0) { 
4F3E:  MOVFF  312,316
4F42:  MOVFF  311,315
4F46:  MOVLW  02
4F48:  MOVLB  3
4F4A:  MOVWF  x18
4F4C:  MOVLW  DC
4F4E:  MOVWF  x17
4F50:  MOVLB  0
4F52:  RCALL  4A54
4F54:  MOVF   01,F
4F56:  BNZ   4F5C
....................       output_toggle(PIN_C1); 
4F58:  BCF    F94.1
4F5A:  BTG    F8B.1
....................    } 
....................    /* Se ejecutará al pulsar el botón "Botón 3" en la aplicación web */ 
....................    if (stricmp(key,boton3_key)==0) { 
4F5C:  MOVFF  312,316
4F60:  MOVFF  311,315
4F64:  MOVLW  02
4F66:  MOVLB  3
4F68:  MOVWF  x18
4F6A:  MOVLW  E3
4F6C:  MOVWF  x17
4F6E:  MOVLB  0
4F70:  RCALL  4A54
4F72:  MOVF   01,F
4F74:  BNZ   4F7A
....................       output_toggle(PIN_C2); 
4F76:  BCF    F94.2
4F78:  BTG    F8B.2
....................    } 
....................    /* Se ejecutará al pulsar el botón "Enviar texto" en la aplicación web */ 
....................    if (stricmp(key,lcd_key)==0) { 
4F7A:  MOVFF  312,316
4F7E:  MOVFF  311,315
4F82:  MOVLW  02
4F84:  MOVLB  3
4F86:  MOVWF  x18
4F88:  MOVLW  EA
4F8A:  MOVWF  x17
4F8C:  MOVLB  0
4F8E:  RCALL  4A54
4F90:  MOVF   01,F
4F92:  BNZ   4FAA
....................       printf(lcd_putc,"\f%s",val);  //Muestra en el lcd el texto recibido 
4F94:  MOVLW  0C
4F96:  MOVLB  3
4F98:  MOVWF  x21
4F9A:  MOVLB  0
4F9C:  CALL   07F4
4FA0:  MOVFF  314,FEA
4FA4:  MOVFF  313,FE9
4FA8:  RCALL  4A2E
....................    } 
.................... } 
4FAA:  GOTO   5014 (RETURN)
....................  
.................... /************************** FUNCIÓN PRINCIPAL *********************************/ 
.................... void main(void) { 
*
71B4:  CLRF   FF8
71B6:  BCF    FD0.7
71B8:  BSF    07.7
71BA:  CLRF   FEA
71BC:  CLRF   FE9
71BE:  CLRF   50
71C0:  CLRF   4F
71C2:  CLRF   51
71C4:  CLRF   52
71C6:  CLRF   5A
71C8:  CLRF   59
71CA:  MOVLW  04
71CC:  MOVWF  5D
71CE:  CLRF   5C
71D0:  MOVF   FC1,W
71D2:  ANDLW  C0
71D4:  IORLW  0F
71D6:  MOVWF  FC1
71D8:  MOVLW  07
71DA:  MOVWF  FB4
71DC:  CLRF   48
71DE:  CLRF   49
71E0:  CLRF   5B
71E2:  BCF    57.1
71E4:  MOVLB  1
71E6:  CLRF   x14
71E8:  CLRF   x15
71EA:  CLRF   x16
71EC:  CLRF   x17
71EE:  CLRF   x18
71F0:  CLRF   x19
71F2:  CLRF   x1A
71F4:  CLRF   x1B
71F6:  CLRF   x1C
71F8:  CLRF   x1D
71FA:  CLRF   x1F
71FC:  MOVLW  FE
71FE:  MOVWF  x1E
7200:  CLRF   x1F
7202:  MOVLW  01
7204:  MOVWF  x20
7206:  CLRF   x28
7208:  CLRF   x29
720A:  CLRF   x2A
720C:  CLRF   x2B
720E:  CLRF   x2C
7210:  CLRF   x2D
7212:  CLRF   x2E
7214:  CLRF   x2F
7216:  CLRF   x30
7218:  CLRF   x31
721A:  CLRF   x32
721C:  CLRF   x33
721E:  CLRF   x34
7220:  CLRF   x35
7222:  CLRF   x36
7224:  CLRF   x37
7226:  CLRF   x38
7228:  CLRF   x39
722A:  CLRF   x3A
722C:  CLRF   x3B
722E:  CLRF   x3C
7230:  CLRF   x3D
7232:  CLRF   x3E
7234:  CLRF   x3F
7236:  CLRF   x40
7238:  CLRF   x41
723A:  CLRF   x42
723C:  CLRF   x43
723E:  CLRF   x44
7240:  CLRF   x45
7242:  CLRF   x46
7244:  CLRF   x47
7246:  CLRF   x48
7248:  CLRF   x49
724A:  CLRF   x4A
724C:  CLRF   x4B
724E:  CLRF   x4C
7250:  CLRF   x4D
7252:  CLRF   x4E
7254:  CLRF   x4F
7256:  CLRF   x50
7258:  MOVLW  20
725A:  MOVWF  x51
725C:  CLRF   x52
725E:  MOVLW  3F
7260:  MOVWF  x53
7262:  CLRF   x54
7264:  MOVLW  47
7266:  MOVWF  x55
7268:  MOVLW  45
726A:  MOVWF  x56
726C:  MOVLW  54
726E:  MOVWF  x57
7270:  CLRF   x58
7272:  MOVLW  50
7274:  MOVWF  x59
7276:  MOVLW  4F
7278:  MOVWF  x5A
727A:  MOVLW  53
727C:  MOVWF  x5B
727E:  MOVLW  54
7280:  MOVWF  x5C
7282:  CLRF   x5D
7284:  MOVLW  43
7286:  MOVWF  x5E
7288:  MOVLW  6F
728A:  MOVWF  x5F
728C:  MOVLW  6E
728E:  MOVWF  x60
7290:  MOVLW  74
7292:  MOVWF  x61
7294:  MOVLW  65
7296:  MOVWF  x62
7298:  MOVLW  6E
729A:  MOVWF  x63
729C:  MOVLW  74
729E:  MOVWF  x64
72A0:  MOVLW  2D
72A2:  MOVWF  x65
72A4:  MOVLW  4C
72A6:  MOVWF  x66
72A8:  MOVLW  65
72AA:  MOVWF  x67
72AC:  MOVLW  6E
72AE:  MOVWF  x68
72B0:  MOVLW  67
72B2:  MOVWF  x69
72B4:  MOVLW  74
72B6:  MOVWF  x6A
72B8:  MOVLW  68
72BA:  MOVWF  x6B
72BC:  MOVLW  3A
72BE:  MOVWF  x6C
72C0:  CLRF   x6D
72C2:  CLRF   x6E
72C4:  CLRF   x6F
72C6:  CLRF   x70
72C8:  CLRF   x71
72CA:  CLRF   x72
72CC:  CLRF   x73
72CE:  CLRF   x74
72D0:  CLRF   x75
72D2:  CLRF   x76
72D4:  CLRF   x77
72D6:  CLRF   x78
72D8:  CLRF   x79
72DA:  CLRF   x7A
72DC:  CLRF   x7B
72DE:  CLRF   x7C
72E0:  CLRF   x7D
72E2:  CLRF   x7E
72E4:  CLRF   x7F
72E6:  CLRF   x80
72E8:  CLRF   x81
72EA:  CLRF   x82
72EC:  CLRF   x83
72EE:  CLRF   x84
72F0:  CLRF   x85
72F2:  CLRF   x86
72F4:  CLRF   x87
72F6:  CLRF   x88
72F8:  CLRF   x89
72FA:  CLRF   x8A
72FC:  CLRF   x8B
72FE:  CLRF   x8C
7300:  CLRF   x8D
7302:  CLRF   x8E
7304:  CLRF   x8F
7306:  CLRF   x90
7308:  CLRF   x91
730A:  CLRF   x92
730C:  CLRF   x93
730E:  CLRF   x94
7310:  CLRF   x95
7312:  CLRF   x96
7314:  CLRF   x97
7316:  CLRF   x98
7318:  CLRF   x99
731A:  CLRF   x9A
731C:  CLRF   x9B
731E:  CLRF   x9C
7320:  CLRF   x9D
7322:  CLRF   x9E
7324:  CLRF   x9F
7326:  CLRF   xA0
7328:  CLRF   xA1
732A:  CLRF   xA2
732C:  CLRF   xA3
732E:  CLRF   xA4
7330:  CLRF   xA5
7332:  CLRF   xA6
7334:  CLRF   xA7
7336:  CLRF   xA8
7338:  CLRF   xA9
733A:  CLRF   xAA
733C:  CLRF   xAB
733E:  CLRF   xAC
7340:  CLRF   xAD
7342:  CLRF   xAE
7344:  CLRF   xAF
7346:  CLRF   xB0
7348:  CLRF   xB1
734A:  CLRF   xB2
734C:  CLRF   xB3
734E:  CLRF   xB4
7350:  CLRF   xB5
7352:  CLRF   xB6
7354:  CLRF   xB7
7356:  CLRF   xB8
7358:  CLRF   xB9
735A:  CLRF   xBA
735C:  CLRF   xBB
735E:  CLRF   xBC
7360:  CLRF   xBD
7362:  CLRF   xBE
7364:  CLRF   xBF
7366:  CLRF   xC0
7368:  CLRF   xC1
736A:  CLRF   xC2
736C:  CLRF   xC3
736E:  CLRF   xC4
7370:  CLRF   xC5
7372:  CLRF   xC6
7374:  CLRF   xC7
7376:  CLRF   xC8
7378:  CLRF   xC9
737A:  CLRF   xCA
737C:  CLRF   xCB
737E:  CLRF   xCC
7380:  CLRF   xCD
7382:  CLRF   xCE
7384:  CLRF   xCF
7386:  CLRF   xD0
7388:  CLRF   xD1
738A:  CLRF   xD2
738C:  CLRF   xD3
738E:  CLRF   xD4
7390:  CLRF   xD5
7392:  CLRF   xD6
7394:  CLRF   xD7
7396:  CLRF   xD8
7398:  CLRF   xD9
739A:  CLRF   xDA
739C:  CLRF   xDB
739E:  CLRF   xDC
73A0:  CLRF   xDD
73A2:  CLRF   xDE
73A4:  CLRF   xDF
73A6:  CLRF   xE0
73A8:  CLRF   xE1
73AA:  CLRF   xE2
73AC:  CLRF   xE3
73AE:  CLRF   xE4
73B0:  CLRF   xE5
73B2:  CLRF   xE6
73B4:  CLRF   xE7
73B6:  CLRF   xE8
73B8:  CLRF   xE9
73BA:  CLRF   xEA
73BC:  CLRF   xEB
73BE:  CLRF   xEC
73C0:  CLRF   xED
73C2:  CLRF   xEE
73C4:  CLRF   xEF
73C6:  CLRF   xF0
73C8:  CLRF   xF1
73CA:  CLRF   xF2
73CC:  CLRF   xF3
73CE:  CLRF   xF4
73D0:  CLRF   xF5
73D2:  CLRF   xF6
73D4:  CLRF   xF7
73D6:  CLRF   xF8
73D8:  CLRF   xF9
73DA:  CLRF   xFA
73DC:  CLRF   xFB
73DE:  CLRF   xFC
73E0:  CLRF   xFD
73E2:  CLRF   xFE
73E4:  CLRF   xFF
73E6:  MOVLB  2
73E8:  CLRF   x00
73EA:  CLRF   x01
73EC:  CLRF   x02
73EE:  CLRF   x03
73F0:  CLRF   x04
73F2:  CLRF   x05
73F4:  CLRF   x06
73F6:  CLRF   x07
73F8:  CLRF   x08
73FA:  CLRF   x09
73FC:  CLRF   x0A
73FE:  CLRF   x0B
7400:  CLRF   x0C
7402:  CLRF   x0D
7404:  CLRF   x0E
7406:  CLRF   x0F
7408:  CLRF   x10
740A:  CLRF   x11
740C:  CLRF   x12
740E:  CLRF   x13
7410:  CLRF   x14
7412:  CLRF   x15
7414:  CLRF   x16
7416:  CLRF   x17
7418:  CLRF   x18
741A:  CLRF   x19
741C:  CLRF   x1A
741E:  CLRF   x1B
7420:  CLRF   x1C
7422:  CLRF   x1D
7424:  CLRF   x1E
7426:  CLRF   x1F
7428:  CLRF   x20
742A:  CLRF   x21
742C:  CLRF   x22
742E:  CLRF   x23
7430:  CLRF   x24
7432:  CLRF   x25
7434:  CLRF   x26
7436:  CLRF   x27
7438:  CLRF   x28
743A:  CLRF   x29
743C:  CLRF   x2A
743E:  CLRF   x2B
7440:  CLRF   x2C
7442:  CLRF   x2D
7444:  CLRF   x2E
7446:  CLRF   x2F
7448:  CLRF   x30
744A:  CLRF   x31
744C:  CLRF   x32
744E:  CLRF   x33
7450:  CLRF   x34
7452:  CLRF   x35
7454:  CLRF   x36
7456:  CLRF   x37
7458:  CLRF   x38
745A:  CLRF   x39
745C:  CLRF   x3A
745E:  CLRF   x3B
7460:  CLRF   x3C
7462:  CLRF   x3D
7464:  CLRF   x3E
7466:  CLRF   x3F
7468:  CLRF   x40
746A:  CLRF   x41
746C:  CLRF   x42
746E:  CLRF   x43
7470:  CLRF   x44
7472:  CLRF   x45
7474:  CLRF   x46
7476:  CLRF   x47
7478:  CLRF   x48
747A:  CLRF   x49
747C:  CLRF   x4A
747E:  CLRF   x4B
7480:  CLRF   x4C
7482:  CLRF   x4D
7484:  CLRF   x4E
7486:  CLRF   x4F
7488:  CLRF   x50
748A:  CLRF   x51
748C:  CLRF   x52
748E:  CLRF   x53
7490:  CLRF   x54
7492:  CLRF   x55
7494:  CLRF   x56
7496:  CLRF   x57
7498:  CLRF   x58
749A:  CLRF   x59
749C:  CLRF   x5A
749E:  CLRF   x5B
74A0:  CLRF   x5C
74A2:  CLRF   x5D
74A4:  CLRF   x5E
74A6:  CLRF   x5F
74A8:  CLRF   x60
74AA:  CLRF   x61
74AC:  CLRF   x62
74AE:  CLRF   x63
74B0:  CLRF   x64
74B2:  CLRF   x65
74B4:  CLRF   x66
74B6:  CLRF   x67
74B8:  CLRF   x68
74BA:  CLRF   x69
74BC:  CLRF   x6A
74BE:  CLRF   x6B
74C0:  CLRF   x6D
74C2:  CLRF   x6C
74C4:  CLRF   x6E
74C6:  CLRF   x6D
74C8:  CLRF   x6E
74CA:  CLRF   x6F
74CC:  CLRF   x70
74CE:  CLRF   x71
74D0:  CLRF   x72
74D2:  CLRF   x73
74D4:  CLRF   x74
74D6:  CLRF   x75
74D8:  CLRF   x76
74DA:  CLRF   x81
74DC:  CLRF   x82
74DE:  CLRF   x83
74E0:  CLRF   x84
74E2:  CLRF   x85
74E4:  CLRF   x86
74E6:  CLRF   x87
74E8:  CLRF   x88
74EA:  CLRF   x89
74EC:  CLRF   x8A
74EE:  CLRF   x8B
74F0:  CLRF   x8C
74F2:  CLRF   x8D
74F4:  CLRF   x8E
74F6:  CLRF   x8F
74F8:  CLRF   x90
74FA:  CLRF   x91
74FC:  CLRF   x92
74FE:  CLRF   x93
7500:  CLRF   x94
7502:  CLRF   x95
7504:  CLRF   x96
7506:  CLRF   x97
7508:  CLRF   x98
750A:  CLRF   x99
750C:  CLRF   x9A
750E:  CLRF   x9B
7510:  CLRF   x9C
7512:  CLRF   x9D
7514:  CLRF   x9E
7516:  CLRF   x9F
7518:  CLRF   xA0
751A:  CLRF   xA1
751C:  CLRF   xA2
751E:  CLRF   xA3
7520:  CLRF   xA4
7522:  CLRF   xA5
7524:  CLRF   xA6
7526:  CLRF   xA7
7528:  CLRF   xA8
752A:  CLRF   xA9
752C:  CLRF   xAA
752E:  CLRF   xAB
7530:  CLRF   xAC
7532:  CLRF   xAD
7534:  CLRF   xAE
7536:  CLRF   xAF
7538:  CLRF   xB0
753A:  CLRF   xB1
753C:  CLRF   xB2
753E:  CLRF   xB3
7540:  CLRF   xB4
7542:  CLRF   xB5
7544:  CLRF   xB6
7546:  CLRF   xB7
7548:  CLRF   xB8
754A:  CLRF   xB9
754C:  CLRF   xBA
754E:  CLRF   xBB
7550:  CLRF   xBC
7552:  CLRF   xBD
7554:  CLRF   xBE
7556:  CLRF   xBF
7558:  CLRF   xC0
755A:  CLRF   xC1
755C:  CLRF   xC2
755E:  CLRF   xC3
7560:  CLRF   xC4
7562:  CLRF   xC5
7564:  CLRF   xC6
7566:  MOVLW  2F
7568:  MOVWF  xC7
756A:  CLRF   xC8
756C:  MOVWF  xC9
756E:  MOVLW  6C
7570:  MOVWF  xCA
7572:  MOVLW  65
7574:  MOVWF  xCB
7576:  MOVLW  63
7578:  MOVWF  xCC
757A:  MOVLW  74
757C:  MOVWF  xCD
757E:  MOVLW  75
7580:  MOVWF  xCE
7582:  MOVLW  72
7584:  MOVWF  xCF
7586:  MOVLW  61
7588:  MOVWF  xD0
758A:  MOVLW  73
758C:  MOVWF  xD1
758E:  CLRF   xD2
7590:  CLRF   xD3
7592:  CLRF   xD4
7594:  MOVLW  62
7596:  MOVWF  xD5
7598:  MOVLW  6F
759A:  MOVWF  xD6
759C:  MOVLW  74
759E:  MOVWF  xD7
75A0:  MOVLW  6F
75A2:  MOVWF  xD8
75A4:  MOVLW  6E
75A6:  MOVWF  xD9
75A8:  MOVLW  31
75AA:  MOVWF  xDA
75AC:  CLRF   xDB
75AE:  MOVLW  62
75B0:  MOVWF  xDC
75B2:  MOVLW  6F
75B4:  MOVWF  xDD
75B6:  MOVLW  74
75B8:  MOVWF  xDE
75BA:  MOVLW  6F
75BC:  MOVWF  xDF
75BE:  MOVLW  6E
75C0:  MOVWF  xE0
75C2:  MOVLW  32
75C4:  MOVWF  xE1
75C6:  CLRF   xE2
75C8:  MOVLW  62
75CA:  MOVWF  xE3
75CC:  MOVLW  6F
75CE:  MOVWF  xE4
75D0:  MOVLW  74
75D2:  MOVWF  xE5
75D4:  MOVLW  6F
75D6:  MOVWF  xE6
75D8:  MOVLW  6E
75DA:  MOVWF  xE7
75DC:  MOVLW  33
75DE:  MOVWF  xE8
75E0:  CLRF   xE9
75E2:  MOVLW  6C
75E4:  MOVWF  xEA
75E6:  MOVLW  63
75E8:  MOVWF  xEB
75EA:  MOVLW  64
75EC:  MOVWF  xEC
75EE:  CLRF   xED
....................  
....................    /* Habilitación y configuración del canal analógico 0 */ 
....................    setup_adc(ADC_CLOCK_INTERNAL); 
75F0:  BSF    FC0.0
75F2:  BSF    FC0.1
75F4:  BSF    FC0.2
75F6:  BCF    FC0.7
75F8:  BSF    FC2.0
....................    setup_adc_ports(AN0); 
75FA:  MOVF   FC1,W
75FC:  ANDLW  C0
75FE:  IORLW  0E
7600:  MOVWF  FC1
....................    set_adc_channel(0); 
7602:  MOVLW  00
7604:  MOVWF  01
7606:  MOVF   FC2,W
7608:  ANDLW  C3
760A:  IORWF  01,W
760C:  MOVWF  FC2
....................    delay_ms(1); 
760E:  MOVLW  01
7610:  MOVLB  3
7612:  MOVWF  x22
7614:  MOVLB  0
7616:  CALL   05DC
....................     
....................    /*Reset de las salidas */ 
....................    output_low(PIN_C0); 
761A:  BCF    F94.0
761C:  BCF    F8B.0
....................    output_low(PIN_C1); 
761E:  BCF    F94.1
7620:  BCF    F8B.1
....................    output_low(PIN_C2); 
7622:  BCF    F94.2
7624:  BCF    F8B.2
....................      
....................    /* Inicialización del lcd */ 
....................    lcd_init(); 
7626:  GOTO   06F8
....................    printf(lcd_putc,"\fROBOTYPIC WEB SERVER");   //Mensaje de inicio en lcd  
762A:  MOVLW  A4
762C:  MOVWF  FF6
762E:  MOVLW  05
7630:  MOVWF  FF7
7632:  CALL   0868
....................    delay_ms(1000); 
7636:  MOVLW  04
7638:  MOVLB  2
763A:  MOVWF  xEE
763C:  MOVLW  FA
763E:  MOVLB  3
7640:  MOVWF  x22
7642:  MOVLB  0
7644:  CALL   05DC
7648:  MOVLB  2
764A:  DECFSZ xEE,F
764C:  BRA    763C
....................    
....................    /* Inicialización del Stack */ 
....................    MACAddrInit(); //Se asigna la dirección MAC elegida  
764E:  MOVLB  0
7650:  GOTO   0888
....................    IPAddrInit();  //Se asigna IP, mascara de red y puerta de enlace elegidos 
7654:  GOTO   08A2
....................    StackInit();   //Inicializa el stack 
7658:  GOTO   1168
....................     
....................    /* Muestra la IP elegida en lcd */ 
....................    printf(lcd_putc,"\n\n IP: %u.%u.%u.%u", MY_IP_BYTE1, MY_IP_BYTE2, MY_IP_BYTE3, MY_IP_BYTE4); 
765C:  MOVLW  BA
765E:  MOVWF  FF6
7660:  MOVLW  05
7662:  MOVWF  FF7
7664:  MOVLW  07
7666:  MOVLB  3
7668:  MOVWF  x15
766A:  MOVLB  0
766C:  CALL   117E
7670:  MOVFF  17,2EE
7674:  MOVLW  1B
7676:  MOVLB  2
7678:  MOVWF  xEF
767A:  MOVLB  0
767C:  CALL   11D4
7680:  MOVLW  2E
7682:  MOVLB  3
7684:  MOVWF  x21
7686:  MOVLB  0
7688:  CALL   07F4
768C:  MOVFF  18,2EE
7690:  MOVLW  1B
7692:  MOVLB  2
7694:  MOVWF  xEF
7696:  MOVLB  0
7698:  CALL   11D4
769C:  MOVLW  2E
769E:  MOVLB  3
76A0:  MOVWF  x21
76A2:  MOVLB  0
76A4:  CALL   07F4
76A8:  MOVFF  19,2EE
76AC:  MOVLW  1B
76AE:  MOVLB  2
76B0:  MOVWF  xEF
76B2:  MOVLB  0
76B4:  CALL   11D4
76B8:  MOVLW  2E
76BA:  MOVLB  3
76BC:  MOVWF  x21
76BE:  MOVLB  0
76C0:  CALL   07F4
76C4:  MOVFF  1A,2EE
76C8:  MOVLW  1B
76CA:  MOVLB  2
76CC:  MOVWF  xEF
76CE:  MOVLB  0
76D0:  CALL   11D4
....................    printf(lcd_putc,"\n Puerto: %u", HTTP_SOCKET); 
76D4:  MOVLW  CE
76D6:  MOVWF  FF6
76D8:  MOVLW  05
76DA:  MOVWF  FF7
76DC:  MOVLW  0A
76DE:  MOVLB  3
76E0:  MOVWF  x15
76E2:  MOVLB  0
76E4:  CALL   117E
76E8:  MOVLW  50
76EA:  MOVLB  2
76EC:  MOVWF  xEE
76EE:  MOVLW  1B
76F0:  MOVWF  xEF
76F2:  MOVLB  0
76F4:  CALL   11D4
....................    delay_ms(10); 
76F8:  MOVLW  0A
76FA:  MOVLB  3
76FC:  MOVWF  x22
76FE:  MOVLB  0
7700:  CALL   05DC
....................  
....................    while(TRUE) { 
....................       StackTask(); 
7704:  BRA    6FD2
....................     } 
7706:  BRA    7704
.................... } 
7708:  SLEEP 

Configuration Fuses:
   Word  1: CC3F   IESO FCMEN HS PLL12 CPUDIV4 USBDIV
   Word  2: 1E3E   BROWNOUT NOWDT BORV20 PUT WDT32768 VREGEN
   Word  3: 8500   NOPBADEN CCP2C1 MCLR LPT1OSC
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST NOICPRT
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: A00F   NOWRT NOWRTD NOWRTC WRTB
   Word  7: 400F   NOEBTR NOEBTRB
